
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Province
 */

export type Province = {
  id: number
  name: string
  created_at: Date
  updated_at: Date
}

/**
 * Model City
 */

export type City = {
  id: number
  name: string
  province_id: number | null
  created_at: Date
  updated_at: Date
}

/**
 * Model User
 */

export type User = {
  id: number
  uid: string
  email: string
  name: string | null
  username: string | null
  phone_number: string | null
  profile_picture_url: string | null
  gender: Gender | null
  birthdate: string | null
  password: string | null
  is_active: boolean | null
  created_at: Date
  updated_at: Date | null
  deleted_at: Date | null
}

/**
 * Model Admins
 */

export type Admins = {
  id: number
  uid: string
  email: string
  name: string | null
  username: string | null
  phone_number: string | null
  profile_picture_url: string | null
  gender: Gender | null
  password: string | null
  is_active: boolean
  created_at: Date
}

/**
 * Model Token
 */

export type Token = {
  id: number
  created_at: Date
  updated_at: Date
  valid: boolean
  expiration: Date
  AdminsId: number
}

/**
 * Model UserPets
 */

export type UserPets = {
  id: number
  uid: string
  name: string
  species: string | null
  breed: string | null
  date_of_birth: Date | null
  color: string | null
  profile_picture_url: string | null
  gender: Gender | null
  is_neutered: boolean | null
  is_dog_friendly: boolean | null
  is_cat_friendly: boolean | null
  is_under_10_child_friendly: boolean | null
  is_over_10_child_friendly: boolean | null
  is_microchipped: boolean | null
  is_purebred: boolean | null
  created_at: Date
  updated_at: Date | null
  deleted_at: Date | null
  UserId: string
}

/**
 * Model User_Address
 */

export type User_Address = {
  id: number
  uid: string
  label: string
  address: string
  is_default: boolean
  created_at: Date
  updated_at: Date
  deleted_at: Date | null
  city_id: number | null
  province_id: number | null
  user_id: string
}

/**
 * Model User_Bank
 */

export type User_Bank = {
  id: number
  uid: string
  alias: string
  bank_name: string
  account_number: string
  bank_username: string
  is_default: boolean
  created_at: Date
  updated_at: Date
  deleted_at: Date | null
  UserId: number
}

/**
 * Model Vendor_Bank
 */

export type Vendor_Bank = {
  id: number
  uid: string
  alias: string
  bank_name: string
  account_number: string
  bank_username: string
  is_default: boolean
  created_at: Date
  updated_at: Date
}

/**
 * Model VaccineType
 */

export type VaccineType = {
  id: number
  name: string
  description: string
  created_at: Date
  updated_at: Date
}

/**
 * Model VaccineHistory
 */

export type VaccineHistory = {
  id: number
  uid: string
  pet_id: string
  veterinary: string
  vaccine_photo: string
  date_administered: Date
  is_manual: boolean
  date_valid_until: Date
  vaccine_type_id: number | null
  created_at: Date
  updated_at: Date
}

/**
 * Model VaccineHistoryPhoto
 */

export type VaccineHistoryPhoto = {
  id: number
  uid: string
  vaccine_history_id: number
  path: string
  description: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Vendors
 */

export type Vendors = {
  id: number
  uid: string
  email: string
  is_verified: boolean
  vendor_role: Type | null
  price: number
  total_patient: number | null
  rating: number | null
  name: string
  username: string
  address: string
  phone_number: string
  profile_picture_url: string
  gender: Gender | null
  speciality: string
  birthdate: string
  google_maps_url: string
  str_number: string
  str_issued_date: string
  alumni: string
  city_id: number
  province_id: number
  lat: string
  long: string
  days: string
  ops_start_time: string
  ops_end_time: string
  duration: number
  rest: number
  total_poli: number
  image_url: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Schedule
 */

export type Schedule = {
  id: number
  uid: string
  time_start: string
  time_end: string
  day_start: string
  day_end: string
  homecare_customer_limit: number
  price: number
  created_at: Date
  updated_at: Date
}

/**
 * Model Vendor_Documents
 */

export type Vendor_Documents = {
  id: number
  uid: string
  document_type: string
  document_path: string
  created_at: Date
  updated_at: Date
  VendorsId: number
}

/**
 * Model Vendor_Medtreats
 */

export type Vendor_Medtreats = {
  id: number
  uid: string
  medical_treatment_id: string
  is_homecare: boolean
  created_at: Date
  updated_at: Date
  VendorsId: number
}

/**
 * Model Class
 */

export type Class = {
  id: number
  name: string
  created_at: Date
  updated_at: Date
  deleted_at: Date | null
}

/**
 * Model Species
 */

export type Species = {
  id: number
  name: string
  created_at: Date
  updated_at: Date
  deleted_at: Date | null
  ClassId: number
}

/**
 * Model Medical_Treatment
 */

export type Medical_Treatment = {
  id: number
  name: string
  description: string
  created_at: Date
  updated_at: Date
}

/**
 * Model Consultations
 */

export type Consultations = {
  id: number
  uid: string
  user_id: string
  pet_id: string
  vendor_id: string
  chat_room_id: string
  vendor_role: Type | null
  diagnose: string
  prerequisite: string
  date: string
  time_start: string
  time_end: string
  order_status: string
  reject_reason: string
  total_payment: number
  payment_image_url: string
  rating: number
  comment: string
  user_bank_id: number
  vendor_bank_id: number
  user_address_id: number
  created_at: Date
  updated_at: Date
}

/**
 * Model Articles
 */

export type Articles = {
  id: number
  title: string
  content: string
  species_id: number
  image_url: string
  is_active: boolean
  created_at: Date
  updated_at: Date
}

/**
 * Model Feedbacks
 */

export type Feedbacks = {
  id: number
  user_id: number
  vendor_id: string
  email: string
  title: string
  content: string
  rating: number
  created_at: Date
  updated_at: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const Gender: {
  Male: 'Male',
  Female: 'Female'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const Type: {
  Home_Care: 'Home_Care',
  Pet_Clinic: 'Pet_Clinic',
  Veterinary: 'Veterinary'
};

export type Type = (typeof Type)[keyof typeof Type]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Provinces
 * const provinces = await prisma.province.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Provinces
   * const provinces = await prisma.province.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.$executeRaw``, values will be escaped automatically
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.$executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.$queryRaw``, values will be escaped automatically
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.$queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.province`: Exposes CRUD operations for the **Province** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Provinces
    * const provinces = await prisma.province.findMany()
    * ```
    */
  get province(): Prisma.ProvinceDelegate<GlobalReject>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.admins`: Exposes CRUD operations for the **Admins** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admins.findMany()
    * ```
    */
  get admins(): Prisma.AdminsDelegate<GlobalReject>;

  /**
   * `prisma.token`: Exposes CRUD operations for the **Token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.token.findMany()
    * ```
    */
  get token(): Prisma.TokenDelegate<GlobalReject>;

  /**
   * `prisma.userPets`: Exposes CRUD operations for the **UserPets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPets
    * const userPets = await prisma.userPets.findMany()
    * ```
    */
  get userPets(): Prisma.UserPetsDelegate<GlobalReject>;

  /**
   * `prisma.user_Address`: Exposes CRUD operations for the **User_Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_Addresses
    * const user_Addresses = await prisma.user_Address.findMany()
    * ```
    */
  get user_Address(): Prisma.User_AddressDelegate<GlobalReject>;

  /**
   * `prisma.user_Bank`: Exposes CRUD operations for the **User_Bank** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_Banks
    * const user_Banks = await prisma.user_Bank.findMany()
    * ```
    */
  get user_Bank(): Prisma.User_BankDelegate<GlobalReject>;

  /**
   * `prisma.vendor_Bank`: Exposes CRUD operations for the **Vendor_Bank** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendor_Banks
    * const vendor_Banks = await prisma.vendor_Bank.findMany()
    * ```
    */
  get vendor_Bank(): Prisma.Vendor_BankDelegate<GlobalReject>;

  /**
   * `prisma.vaccineType`: Exposes CRUD operations for the **VaccineType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VaccineTypes
    * const vaccineTypes = await prisma.vaccineType.findMany()
    * ```
    */
  get vaccineType(): Prisma.VaccineTypeDelegate<GlobalReject>;

  /**
   * `prisma.vaccineHistory`: Exposes CRUD operations for the **VaccineHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VaccineHistories
    * const vaccineHistories = await prisma.vaccineHistory.findMany()
    * ```
    */
  get vaccineHistory(): Prisma.VaccineHistoryDelegate<GlobalReject>;

  /**
   * `prisma.vaccineHistoryPhoto`: Exposes CRUD operations for the **VaccineHistoryPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VaccineHistoryPhotos
    * const vaccineHistoryPhotos = await prisma.vaccineHistoryPhoto.findMany()
    * ```
    */
  get vaccineHistoryPhoto(): Prisma.VaccineHistoryPhotoDelegate<GlobalReject>;

  /**
   * `prisma.vendors`: Exposes CRUD operations for the **Vendors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendors.findMany()
    * ```
    */
  get vendors(): Prisma.VendorsDelegate<GlobalReject>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.ScheduleDelegate<GlobalReject>;

  /**
   * `prisma.vendor_Documents`: Exposes CRUD operations for the **Vendor_Documents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendor_Documents
    * const vendor_Documents = await prisma.vendor_Documents.findMany()
    * ```
    */
  get vendor_Documents(): Prisma.Vendor_DocumentsDelegate<GlobalReject>;

  /**
   * `prisma.vendor_Medtreats`: Exposes CRUD operations for the **Vendor_Medtreats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendor_Medtreats
    * const vendor_Medtreats = await prisma.vendor_Medtreats.findMany()
    * ```
    */
  get vendor_Medtreats(): Prisma.Vendor_MedtreatsDelegate<GlobalReject>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<GlobalReject>;

  /**
   * `prisma.species`: Exposes CRUD operations for the **Species** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Species
    * const species = await prisma.species.findMany()
    * ```
    */
  get species(): Prisma.SpeciesDelegate<GlobalReject>;

  /**
   * `prisma.medical_Treatment`: Exposes CRUD operations for the **Medical_Treatment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medical_Treatments
    * const medical_Treatments = await prisma.medical_Treatment.findMany()
    * ```
    */
  get medical_Treatment(): Prisma.Medical_TreatmentDelegate<GlobalReject>;

  /**
   * `prisma.consultations`: Exposes CRUD operations for the **Consultations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consultations
    * const consultations = await prisma.consultations.findMany()
    * ```
    */
  get consultations(): Prisma.ConsultationsDelegate<GlobalReject>;

  /**
   * `prisma.articles`: Exposes CRUD operations for the **Articles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Articles
    * const articles = await prisma.articles.findMany()
    * ```
    */
  get articles(): Prisma.ArticlesDelegate<GlobalReject>;

  /**
   * `prisma.feedbacks`: Exposes CRUD operations for the **Feedbacks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedbacks.findMany()
    * ```
    */
  get feedbacks(): Prisma.FeedbacksDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.28.0
   * Query Engine version: 89facabd0366f63911d089156a7a70125bfbcd27
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Province: 'Province',
    City: 'City',
    User: 'User',
    Admins: 'Admins',
    Token: 'Token',
    UserPets: 'UserPets',
    User_Address: 'User_Address',
    User_Bank: 'User_Bank',
    Vendor_Bank: 'Vendor_Bank',
    VaccineType: 'VaccineType',
    VaccineHistory: 'VaccineHistory',
    VaccineHistoryPhoto: 'VaccineHistoryPhoto',
    Vendors: 'Vendors',
    Schedule: 'Schedule',
    Vendor_Documents: 'Vendor_Documents',
    Vendor_Medtreats: 'Vendor_Medtreats',
    Class: 'Class',
    Species: 'Species',
    Medical_Treatment: 'Medical_Treatment',
    Consultations: 'Consultations',
    Articles: 'Articles',
    Feedbacks: 'Feedbacks'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model Province
   */


  export type AggregateProvince = {
    _count: ProvinceCountAggregateOutputType | null
    count: ProvinceCountAggregateOutputType | null
    _avg: ProvinceAvgAggregateOutputType | null
    avg: ProvinceAvgAggregateOutputType | null
    _sum: ProvinceSumAggregateOutputType | null
    sum: ProvinceSumAggregateOutputType | null
    _min: ProvinceMinAggregateOutputType | null
    min: ProvinceMinAggregateOutputType | null
    _max: ProvinceMaxAggregateOutputType | null
    max: ProvinceMaxAggregateOutputType | null
  }

  export type ProvinceAvgAggregateOutputType = {
    id: number | null
  }

  export type ProvinceSumAggregateOutputType = {
    id: number | null
  }

  export type ProvinceMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProvinceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProvinceCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProvinceAvgAggregateInputType = {
    id?: true
  }

  export type ProvinceSumAggregateInputType = {
    id?: true
  }

  export type ProvinceMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type ProvinceMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type ProvinceCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProvinceAggregateArgs = {
    /**
     * Filter which Province to aggregate.
     * 
    **/
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     * 
    **/
    orderBy?: Enumerable<ProvinceOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Provinces
    **/
    _count?: true | ProvinceCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ProvinceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProvinceAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ProvinceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProvinceSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ProvinceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvinceMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ProvinceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvinceMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ProvinceMaxAggregateInputType
  }

  export type GetProvinceAggregateType<T extends ProvinceAggregateArgs> = {
        [P in keyof T & keyof AggregateProvince]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvince[P]>
      : GetScalarType<T[P], AggregateProvince[P]>
  }


    
    
  export type ProvinceGroupByArgs = {
    where?: ProvinceWhereInput
    orderBy?: Enumerable<ProvinceOrderByInput>
    by: Array<ProvinceScalarFieldEnum>
    having?: ProvinceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvinceCountAggregateInputType | true
    _avg?: ProvinceAvgAggregateInputType
    _sum?: ProvinceSumAggregateInputType
    _min?: ProvinceMinAggregateInputType
    _max?: ProvinceMaxAggregateInputType
  }


  export type ProvinceGroupByOutputType = {
    id: number
    name: string
    created_at: Date
    updated_at: Date
    _count: ProvinceCountAggregateOutputType | null
    _avg: ProvinceAvgAggregateOutputType | null
    _sum: ProvinceSumAggregateOutputType | null
    _min: ProvinceMinAggregateOutputType | null
    _max: ProvinceMaxAggregateOutputType | null
  }

  type GetProvinceGroupByPayload<T extends ProvinceGroupByArgs> = Promise<
    Array<
      PickArray<ProvinceGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ProvinceGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ProvinceGroupByOutputType[P]> 
            : GetScalarType<T[P], ProvinceGroupByOutputType[P]>
        }
      > 
    >


  export type ProvinceSelect = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    City?: boolean | CityFindManyArgs
    User_Address?: boolean | User_AddressFindManyArgs
  }

  export type ProvinceInclude = {
    City?: boolean | CityFindManyArgs
    User_Address?: boolean | User_AddressFindManyArgs
  }

  export type ProvinceGetPayload<
    S extends boolean | null | undefined | ProvinceArgs,
    U = keyof S
      > = S extends true
        ? Province
    : S extends undefined
    ? never
    : S extends ProvinceArgs | ProvinceFindManyArgs
    ?'include' extends U
    ? Province  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'City'
        ? Array < CityGetPayload<S['include'][P]>>  :
        P extends 'User_Address'
        ? Array < User_AddressGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Province ?Province [P]
  : 
          P extends 'City'
        ? Array < CityGetPayload<S['select'][P]>>  :
        P extends 'User_Address'
        ? Array < User_AddressGetPayload<S['select'][P]>>  : never
  } 
    : Province
  : Province


  type ProvinceCountArgs = Merge<
    Omit<ProvinceFindManyArgs, 'select' | 'include'> & {
      select?: ProvinceCountAggregateInputType | true
    }
  >

  export interface ProvinceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Province that matches the filter.
     * @param {ProvinceFindUniqueArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProvinceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProvinceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Province'> extends True ? CheckSelect<T, Prisma__ProvinceClient<Province>, Prisma__ProvinceClient<ProvinceGetPayload<T>>> : CheckSelect<T, Prisma__ProvinceClient<Province | null >, Prisma__ProvinceClient<ProvinceGetPayload<T> | null >>

    /**
     * Find the first Province that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceFindFirstArgs} args - Arguments to find a Province
     * @example
     * // Get one Province
     * const province = await prisma.province.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProvinceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProvinceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Province'> extends True ? CheckSelect<T, Prisma__ProvinceClient<Province>, Prisma__ProvinceClient<ProvinceGetPayload<T>>> : CheckSelect<T, Prisma__ProvinceClient<Province | null >, Prisma__ProvinceClient<ProvinceGetPayload<T> | null >>

    /**
     * Find zero or more Provinces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provinces
     * const provinces = await prisma.province.findMany()
     * 
     * // Get first 10 Provinces
     * const provinces = await prisma.province.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const provinceWithIdOnly = await prisma.province.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProvinceFindManyArgs>(
      args?: SelectSubset<T, ProvinceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Province>>, PrismaPromise<Array<ProvinceGetPayload<T>>>>

    /**
     * Create a Province.
     * @param {ProvinceCreateArgs} args - Arguments to create a Province.
     * @example
     * // Create one Province
     * const Province = await prisma.province.create({
     *   data: {
     *     // ... data to create a Province
     *   }
     * })
     * 
    **/
    create<T extends ProvinceCreateArgs>(
      args: SelectSubset<T, ProvinceCreateArgs>
    ): CheckSelect<T, Prisma__ProvinceClient<Province>, Prisma__ProvinceClient<ProvinceGetPayload<T>>>

    /**
     * Create many Provinces.
     *     @param {ProvinceCreateManyArgs} args - Arguments to create many Provinces.
     *     @example
     *     // Create many Provinces
     *     const province = await prisma.province.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProvinceCreateManyArgs>(
      args?: SelectSubset<T, ProvinceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Province.
     * @param {ProvinceDeleteArgs} args - Arguments to delete one Province.
     * @example
     * // Delete one Province
     * const Province = await prisma.province.delete({
     *   where: {
     *     // ... filter to delete one Province
     *   }
     * })
     * 
    **/
    delete<T extends ProvinceDeleteArgs>(
      args: SelectSubset<T, ProvinceDeleteArgs>
    ): CheckSelect<T, Prisma__ProvinceClient<Province>, Prisma__ProvinceClient<ProvinceGetPayload<T>>>

    /**
     * Update one Province.
     * @param {ProvinceUpdateArgs} args - Arguments to update one Province.
     * @example
     * // Update one Province
     * const province = await prisma.province.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProvinceUpdateArgs>(
      args: SelectSubset<T, ProvinceUpdateArgs>
    ): CheckSelect<T, Prisma__ProvinceClient<Province>, Prisma__ProvinceClient<ProvinceGetPayload<T>>>

    /**
     * Delete zero or more Provinces.
     * @param {ProvinceDeleteManyArgs} args - Arguments to filter Provinces to delete.
     * @example
     * // Delete a few Provinces
     * const { count } = await prisma.province.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProvinceDeleteManyArgs>(
      args?: SelectSubset<T, ProvinceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provinces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provinces
     * const province = await prisma.province.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProvinceUpdateManyArgs>(
      args: SelectSubset<T, ProvinceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Province.
     * @param {ProvinceUpsertArgs} args - Arguments to update or create a Province.
     * @example
     * // Update or create a Province
     * const province = await prisma.province.upsert({
     *   create: {
     *     // ... data to create a Province
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Province we want to update
     *   }
     * })
    **/
    upsert<T extends ProvinceUpsertArgs>(
      args: SelectSubset<T, ProvinceUpsertArgs>
    ): CheckSelect<T, Prisma__ProvinceClient<Province>, Prisma__ProvinceClient<ProvinceGetPayload<T>>>

    /**
     * Count the number of Provinces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceCountArgs} args - Arguments to filter Provinces to count.
     * @example
     * // Count the number of Provinces
     * const count = await prisma.province.count({
     *   where: {
     *     // ... the filter for the Provinces we want to count
     *   }
     * })
    **/
    count<T extends ProvinceCountArgs>(
      args?: Subset<T, ProvinceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvinceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Province.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvinceAggregateArgs>(args: Subset<T, ProvinceAggregateArgs>): PrismaPromise<GetProvinceAggregateType<T>>

    /**
     * Group by Province.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProvinceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProvinceGroupByArgs['orderBy'] }
        : { orderBy?: ProvinceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProvinceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvinceGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Province.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProvinceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    City<T extends CityFindManyArgs = {}>(args?: Subset<T, CityFindManyArgs>): CheckSelect<T, PrismaPromise<Array<City>>, PrismaPromise<Array<CityGetPayload<T>>>>;

    User_Address<T extends User_AddressFindManyArgs = {}>(args?: Subset<T, User_AddressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User_Address>>, PrismaPromise<Array<User_AddressGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Province findUnique
   */
  export type ProvinceFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Province
     * 
    **/
    select?: ProvinceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProvinceInclude | null
    /**
     * Throw an Error if a Province can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Province to fetch.
     * 
    **/
    where: ProvinceWhereUniqueInput
  }


  /**
   * Province findFirst
   */
  export type ProvinceFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Province
     * 
    **/
    select?: ProvinceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProvinceInclude | null
    /**
     * Throw an Error if a Province can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Province to fetch.
     * 
    **/
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     * 
    **/
    orderBy?: Enumerable<ProvinceOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Provinces.
     * 
    **/
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Provinces.
     * 
    **/
    distinct?: Enumerable<ProvinceScalarFieldEnum>
  }


  /**
   * Province findMany
   */
  export type ProvinceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Province
     * 
    **/
    select?: ProvinceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProvinceInclude | null
    /**
     * Filter, which Provinces to fetch.
     * 
    **/
    where?: ProvinceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinces to fetch.
     * 
    **/
    orderBy?: Enumerable<ProvinceOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Provinces.
     * 
    **/
    cursor?: ProvinceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinces from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinces.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProvinceScalarFieldEnum>
  }


  /**
   * Province create
   */
  export type ProvinceCreateArgs = {
    /**
     * Select specific fields to fetch from the Province
     * 
    **/
    select?: ProvinceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProvinceInclude | null
    /**
     * The data needed to create a Province.
     * 
    **/
    data: XOR<ProvinceCreateInput, ProvinceUncheckedCreateInput>
  }


  /**
   * Province createMany
   */
  export type ProvinceCreateManyArgs = {
    data: Enumerable<ProvinceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Province update
   */
  export type ProvinceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Province
     * 
    **/
    select?: ProvinceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProvinceInclude | null
    /**
     * The data needed to update a Province.
     * 
    **/
    data: XOR<ProvinceUpdateInput, ProvinceUncheckedUpdateInput>
    /**
     * Choose, which Province to update.
     * 
    **/
    where: ProvinceWhereUniqueInput
  }


  /**
   * Province updateMany
   */
  export type ProvinceUpdateManyArgs = {
    data: XOR<ProvinceUpdateManyMutationInput, ProvinceUncheckedUpdateManyInput>
    where?: ProvinceWhereInput
  }


  /**
   * Province upsert
   */
  export type ProvinceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Province
     * 
    **/
    select?: ProvinceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProvinceInclude | null
    /**
     * The filter to search for the Province to update in case it exists.
     * 
    **/
    where: ProvinceWhereUniqueInput
    /**
     * In case the Province found by the `where` argument doesn't exist, create a new Province with this data.
     * 
    **/
    create: XOR<ProvinceCreateInput, ProvinceUncheckedCreateInput>
    /**
     * In case the Province was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProvinceUpdateInput, ProvinceUncheckedUpdateInput>
  }


  /**
   * Province delete
   */
  export type ProvinceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Province
     * 
    **/
    select?: ProvinceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProvinceInclude | null
    /**
     * Filter which Province to delete.
     * 
    **/
    where: ProvinceWhereUniqueInput
  }


  /**
   * Province deleteMany
   */
  export type ProvinceDeleteManyArgs = {
    where?: ProvinceWhereInput
  }


  /**
   * Province without action
   */
  export type ProvinceArgs = {
    /**
     * Select specific fields to fetch from the Province
     * 
    **/
    select?: ProvinceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProvinceInclude | null
  }



  /**
   * Model City
   */


  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
    max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    id: number | null
    province_id: number | null
  }

  export type CitySumAggregateOutputType = {
    id: number | null
    province_id: number | null
  }

  export type CityMinAggregateOutputType = {
    id: number | null
    name: string | null
    province_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    province_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    province_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    id?: true
    province_id?: true
  }

  export type CitySumAggregateInputType = {
    id?: true
    province_id?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    province_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    province_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    province_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CityAggregateArgs = {
    /**
     * Filter which City to aggregate.
     * 
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     * 
    **/
    orderBy?: Enumerable<CityOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }


    
    
  export type CityGroupByArgs = {
    where?: CityWhereInput
    orderBy?: Enumerable<CityOrderByInput>
    by: Array<CityScalarFieldEnum>
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }


  export type CityGroupByOutputType = {
    id: number
    name: string
    province_id: number | null
    created_at: Date
    updated_at: Date
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Promise<
    Array<
      PickArray<CityGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CityGroupByOutputType[P]> 
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      > 
    >


  export type CitySelect = {
    id?: boolean
    name?: boolean
    Province?: boolean | ProvinceArgs
    province_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    User_Address?: boolean | User_AddressFindManyArgs
  }

  export type CityInclude = {
    Province?: boolean | ProvinceArgs
    User_Address?: boolean | User_AddressFindManyArgs
  }

  export type CityGetPayload<
    S extends boolean | null | undefined | CityArgs,
    U = keyof S
      > = S extends true
        ? City
    : S extends undefined
    ? never
    : S extends CityArgs | CityFindManyArgs
    ?'include' extends U
    ? City  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Province'
        ? ProvinceGetPayload<S['include'][P]> | null :
        P extends 'User_Address'
        ? Array < User_AddressGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof City ?City [P]
  : 
          P extends 'Province'
        ? ProvinceGetPayload<S['select'][P]> | null :
        P extends 'User_Address'
        ? Array < User_AddressGetPayload<S['select'][P]>>  : never
  } 
    : City
  : City


  type CityCountArgs = Merge<
    Omit<CityFindManyArgs, 'select' | 'include'> & {
      select?: CityCountAggregateInputType | true
    }
  >

  export interface CityDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'City'> extends True ? CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>> : CheckSelect<T, Prisma__CityClient<City | null >, Prisma__CityClient<CityGetPayload<T> | null >>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'City'> extends True ? CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>> : CheckSelect<T, Prisma__CityClient<City | null >, Prisma__CityClient<CityGetPayload<T> | null >>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CityFindManyArgs>(
      args?: SelectSubset<T, CityFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<City>>, PrismaPromise<Array<CityGetPayload<T>>>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
    **/
    create<T extends CityCreateArgs>(
      args: SelectSubset<T, CityCreateArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Create many Cities.
     *     @param {CityCreateManyArgs} args - Arguments to create many Cities.
     *     @example
     *     // Create many Cities
     *     const city = await prisma.city.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CityCreateManyArgs>(
      args?: SelectSubset<T, CityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
    **/
    delete<T extends CityDeleteArgs>(
      args: SelectSubset<T, CityDeleteArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CityUpdateArgs>(
      args: SelectSubset<T, CityUpdateArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CityDeleteManyArgs>(
      args?: SelectSubset<T, CityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CityUpdateManyArgs>(
      args: SelectSubset<T, CityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
    **/
    upsert<T extends CityUpsertArgs>(
      args: SelectSubset<T, CityUpsertArgs>
    ): CheckSelect<T, Prisma__CityClient<City>, Prisma__CityClient<CityGetPayload<T>>>

    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CityClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Province<T extends ProvinceArgs = {}>(args?: Subset<T, ProvinceArgs>): CheckSelect<T, Prisma__ProvinceClient<Province | null >, Prisma__ProvinceClient<ProvinceGetPayload<T> | null >>;

    User_Address<T extends User_AddressFindManyArgs = {}>(args?: Subset<T, User_AddressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User_Address>>, PrismaPromise<Array<User_AddressGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * City findUnique
   */
  export type CityFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Throw an Error if a City can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which City to fetch.
     * 
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City findFirst
   */
  export type CityFindFirstArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Throw an Error if a City can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which City to fetch.
     * 
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     * 
    **/
    orderBy?: Enumerable<CityOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     * 
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     * 
    **/
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * City findMany
   */
  export type CityFindManyArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter, which Cities to fetch.
     * 
    **/
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     * 
    **/
    orderBy?: Enumerable<CityOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     * 
    **/
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * City create
   */
  export type CityCreateArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * The data needed to create a City.
     * 
    **/
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }


  /**
   * City createMany
   */
  export type CityCreateManyArgs = {
    data: Enumerable<CityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * City update
   */
  export type CityUpdateArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * The data needed to update a City.
     * 
    **/
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     * 
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City updateMany
   */
  export type CityUpdateManyArgs = {
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    where?: CityWhereInput
  }


  /**
   * City upsert
   */
  export type CityUpsertArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * The filter to search for the City to update in case it exists.
     * 
    **/
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     * 
    **/
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }


  /**
   * City delete
   */
  export type CityDeleteArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
    /**
     * Filter which City to delete.
     * 
    **/
    where: CityWhereUniqueInput
  }


  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs = {
    where?: CityWhereInput
  }


  /**
   * City without action
   */
  export type CityArgs = {
    /**
     * Select specific fields to fetch from the City
     * 
    **/
    select?: CitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CityInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    uid: string | null
    email: string | null
    name: string | null
    username: string | null
    phone_number: string | null
    profile_picture_url: string | null
    gender: Gender | null
    birthdate: string | null
    password: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    email: string | null
    name: string | null
    username: string | null
    phone_number: string | null
    profile_picture_url: string | null
    gender: Gender | null
    birthdate: string | null
    password: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    uid: number
    email: number
    name: number
    username: number
    phone_number: number
    profile_picture_url: number
    gender: number
    birthdate: number
    password: number
    is_active: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    uid?: true
    email?: true
    name?: true
    username?: true
    phone_number?: true
    profile_picture_url?: true
    gender?: true
    birthdate?: true
    password?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    uid?: true
    email?: true
    name?: true
    username?: true
    phone_number?: true
    profile_picture_url?: true
    gender?: true
    birthdate?: true
    password?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    uid?: true
    email?: true
    name?: true
    username?: true
    phone_number?: true
    profile_picture_url?: true
    gender?: true
    birthdate?: true
    password?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }


    
    
  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    uid: string
    email: string
    name: string | null
    username: string | null
    phone_number: string | null
    profile_picture_url: string | null
    gender: Gender | null
    birthdate: string | null
    password: string | null
    is_active: boolean | null
    created_at: Date
    updated_at: Date | null
    deleted_at: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Promise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], UserGroupByOutputType[P]> 
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      > 
    >


  export type UserSelect = {
    id?: boolean
    uid?: boolean
    email?: boolean
    name?: boolean
    username?: boolean
    phone_number?: boolean
    profile_picture_url?: boolean
    gender?: boolean
    birthdate?: boolean
    password?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    user_address?: boolean | User_AddressFindManyArgs
    user_bank?: boolean | User_BankFindManyArgs
    user_pets?: boolean | UserPetsFindManyArgs
    Consultations?: boolean | ConsultationsFindManyArgs
  }

  export type UserInclude = {
    user_address?: boolean | User_AddressFindManyArgs
    user_bank?: boolean | User_BankFindManyArgs
    user_pets?: boolean | UserPetsFindManyArgs
    Consultations?: boolean | ConsultationsFindManyArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user_address'
        ? Array < User_AddressGetPayload<S['include'][P]>>  :
        P extends 'user_bank'
        ? Array < User_BankGetPayload<S['include'][P]>>  :
        P extends 'user_pets'
        ? Array < UserPetsGetPayload<S['include'][P]>>  :
        P extends 'Consultations'
        ? Array < ConsultationsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'user_address'
        ? Array < User_AddressGetPayload<S['select'][P]>>  :
        P extends 'user_bank'
        ? Array < User_BankGetPayload<S['select'][P]>>  :
        P extends 'user_pets'
        ? Array < UserPetsGetPayload<S['select'][P]>>  :
        P extends 'Consultations'
        ? Array < ConsultationsGetPayload<S['select'][P]>>  : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user_address<T extends User_AddressFindManyArgs = {}>(args?: Subset<T, User_AddressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User_Address>>, PrismaPromise<Array<User_AddressGetPayload<T>>>>;

    user_bank<T extends User_BankFindManyArgs = {}>(args?: Subset<T, User_BankFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User_Bank>>, PrismaPromise<Array<User_BankGetPayload<T>>>>;

    user_pets<T extends UserPetsFindManyArgs = {}>(args?: Subset<T, UserPetsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserPets>>, PrismaPromise<Array<UserPetsGetPayload<T>>>>;

    Consultations<T extends ConsultationsFindManyArgs = {}>(args?: Subset<T, ConsultationsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Consultations>>, PrismaPromise<Array<ConsultationsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Admins
   */


  export type AggregateAdmins = {
    _count: AdminsCountAggregateOutputType | null
    count: AdminsCountAggregateOutputType | null
    _avg: AdminsAvgAggregateOutputType | null
    avg: AdminsAvgAggregateOutputType | null
    _sum: AdminsSumAggregateOutputType | null
    sum: AdminsSumAggregateOutputType | null
    _min: AdminsMinAggregateOutputType | null
    min: AdminsMinAggregateOutputType | null
    _max: AdminsMaxAggregateOutputType | null
    max: AdminsMaxAggregateOutputType | null
  }

  export type AdminsAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminsSumAggregateOutputType = {
    id: number | null
  }

  export type AdminsMinAggregateOutputType = {
    id: number | null
    uid: string | null
    email: string | null
    name: string | null
    username: string | null
    phone_number: string | null
    profile_picture_url: string | null
    gender: Gender | null
    password: string | null
    is_active: boolean | null
    created_at: Date | null
  }

  export type AdminsMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    email: string | null
    name: string | null
    username: string | null
    phone_number: string | null
    profile_picture_url: string | null
    gender: Gender | null
    password: string | null
    is_active: boolean | null
    created_at: Date | null
  }

  export type AdminsCountAggregateOutputType = {
    id: number
    uid: number
    email: number
    name: number
    username: number
    phone_number: number
    profile_picture_url: number
    gender: number
    password: number
    is_active: number
    created_at: number
    _all: number
  }


  export type AdminsAvgAggregateInputType = {
    id?: true
  }

  export type AdminsSumAggregateInputType = {
    id?: true
  }

  export type AdminsMinAggregateInputType = {
    id?: true
    uid?: true
    email?: true
    name?: true
    username?: true
    phone_number?: true
    profile_picture_url?: true
    gender?: true
    password?: true
    is_active?: true
    created_at?: true
  }

  export type AdminsMaxAggregateInputType = {
    id?: true
    uid?: true
    email?: true
    name?: true
    username?: true
    phone_number?: true
    profile_picture_url?: true
    gender?: true
    password?: true
    is_active?: true
    created_at?: true
  }

  export type AdminsCountAggregateInputType = {
    id?: true
    uid?: true
    email?: true
    name?: true
    username?: true
    phone_number?: true
    profile_picture_url?: true
    gender?: true
    password?: true
    is_active?: true
    created_at?: true
    _all?: true
  }

  export type AdminsAggregateArgs = {
    /**
     * Filter which Admins to aggregate.
     * 
    **/
    where?: AdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     * 
    **/
    orderBy?: Enumerable<AdminsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminsCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | AdminsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminsAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: AdminsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminsSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: AdminsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminsMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: AdminsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminsMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: AdminsMaxAggregateInputType
  }

  export type GetAdminsAggregateType<T extends AdminsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmins[P]>
      : GetScalarType<T[P], AggregateAdmins[P]>
  }


    
    
  export type AdminsGroupByArgs = {
    where?: AdminsWhereInput
    orderBy?: Enumerable<AdminsOrderByInput>
    by: Array<AdminsScalarFieldEnum>
    having?: AdminsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminsCountAggregateInputType | true
    _avg?: AdminsAvgAggregateInputType
    _sum?: AdminsSumAggregateInputType
    _min?: AdminsMinAggregateInputType
    _max?: AdminsMaxAggregateInputType
  }


  export type AdminsGroupByOutputType = {
    id: number
    uid: string
    email: string
    name: string | null
    username: string | null
    phone_number: string | null
    profile_picture_url: string | null
    gender: Gender | null
    password: string | null
    is_active: boolean
    created_at: Date
    _count: AdminsCountAggregateOutputType | null
    _avg: AdminsAvgAggregateOutputType | null
    _sum: AdminsSumAggregateOutputType | null
    _min: AdminsMinAggregateOutputType | null
    _max: AdminsMaxAggregateOutputType | null
  }

  type GetAdminsGroupByPayload<T extends AdminsGroupByArgs> = Promise<
    Array<
      PickArray<AdminsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof AdminsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], AdminsGroupByOutputType[P]> 
            : GetScalarType<T[P], AdminsGroupByOutputType[P]>
        }
      > 
    >


  export type AdminsSelect = {
    id?: boolean
    uid?: boolean
    email?: boolean
    name?: boolean
    username?: boolean
    phone_number?: boolean
    profile_picture_url?: boolean
    gender?: boolean
    password?: boolean
    tokens?: boolean | TokenFindManyArgs
    is_active?: boolean
    created_at?: boolean
  }

  export type AdminsInclude = {
    tokens?: boolean | TokenFindManyArgs
  }

  export type AdminsGetPayload<
    S extends boolean | null | undefined | AdminsArgs,
    U = keyof S
      > = S extends true
        ? Admins
    : S extends undefined
    ? never
    : S extends AdminsArgs | AdminsFindManyArgs
    ?'include' extends U
    ? Admins  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'tokens'
        ? Array < TokenGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Admins ?Admins [P]
  : 
          P extends 'tokens'
        ? Array < TokenGetPayload<S['select'][P]>>  : never
  } 
    : Admins
  : Admins


  type AdminsCountArgs = Merge<
    Omit<AdminsFindManyArgs, 'select' | 'include'> & {
      select?: AdminsCountAggregateInputType | true
    }
  >

  export interface AdminsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Admins that matches the filter.
     * @param {AdminsFindUniqueArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AdminsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Admins'> extends True ? CheckSelect<T, Prisma__AdminsClient<Admins>, Prisma__AdminsClient<AdminsGetPayload<T>>> : CheckSelect<T, Prisma__AdminsClient<Admins | null >, Prisma__AdminsClient<AdminsGetPayload<T> | null >>

    /**
     * Find the first Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsFindFirstArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AdminsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Admins'> extends True ? CheckSelect<T, Prisma__AdminsClient<Admins>, Prisma__AdminsClient<AdminsGetPayload<T>>> : CheckSelect<T, Prisma__AdminsClient<Admins | null >, Prisma__AdminsClient<AdminsGetPayload<T> | null >>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admins.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admins.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminsWithIdOnly = await prisma.admins.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminsFindManyArgs>(
      args?: SelectSubset<T, AdminsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Admins>>, PrismaPromise<Array<AdminsGetPayload<T>>>>

    /**
     * Create a Admins.
     * @param {AdminsCreateArgs} args - Arguments to create a Admins.
     * @example
     * // Create one Admins
     * const Admins = await prisma.admins.create({
     *   data: {
     *     // ... data to create a Admins
     *   }
     * })
     * 
    **/
    create<T extends AdminsCreateArgs>(
      args: SelectSubset<T, AdminsCreateArgs>
    ): CheckSelect<T, Prisma__AdminsClient<Admins>, Prisma__AdminsClient<AdminsGetPayload<T>>>

    /**
     * Create many Admins.
     *     @param {AdminsCreateManyArgs} args - Arguments to create many Admins.
     *     @example
     *     // Create many Admins
     *     const admins = await prisma.admins.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminsCreateManyArgs>(
      args?: SelectSubset<T, AdminsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Admins.
     * @param {AdminsDeleteArgs} args - Arguments to delete one Admins.
     * @example
     * // Delete one Admins
     * const Admins = await prisma.admins.delete({
     *   where: {
     *     // ... filter to delete one Admins
     *   }
     * })
     * 
    **/
    delete<T extends AdminsDeleteArgs>(
      args: SelectSubset<T, AdminsDeleteArgs>
    ): CheckSelect<T, Prisma__AdminsClient<Admins>, Prisma__AdminsClient<AdminsGetPayload<T>>>

    /**
     * Update one Admins.
     * @param {AdminsUpdateArgs} args - Arguments to update one Admins.
     * @example
     * // Update one Admins
     * const admins = await prisma.admins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminsUpdateArgs>(
      args: SelectSubset<T, AdminsUpdateArgs>
    ): CheckSelect<T, Prisma__AdminsClient<Admins>, Prisma__AdminsClient<AdminsGetPayload<T>>>

    /**
     * Delete zero or more Admins.
     * @param {AdminsDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminsDeleteManyArgs>(
      args?: SelectSubset<T, AdminsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admins = await prisma.admins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminsUpdateManyArgs>(
      args: SelectSubset<T, AdminsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Admins.
     * @param {AdminsUpsertArgs} args - Arguments to update or create a Admins.
     * @example
     * // Update or create a Admins
     * const admins = await prisma.admins.upsert({
     *   create: {
     *     // ... data to create a Admins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admins we want to update
     *   }
     * })
    **/
    upsert<T extends AdminsUpsertArgs>(
      args: SelectSubset<T, AdminsUpsertArgs>
    ): CheckSelect<T, Prisma__AdminsClient<Admins>, Prisma__AdminsClient<AdminsGetPayload<T>>>

    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admins.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminsCountArgs>(
      args?: Subset<T, AdminsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminsAggregateArgs>(args: Subset<T, AdminsAggregateArgs>): PrismaPromise<GetAdminsAggregateType<T>>

    /**
     * Group by Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminsGroupByArgs['orderBy'] }
        : { orderBy?: AdminsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AdminsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    tokens<T extends TokenFindManyArgs = {}>(args?: Subset<T, TokenFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Token>>, PrismaPromise<Array<TokenGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Admins findUnique
   */
  export type AdminsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Admins
     * 
    **/
    select?: AdminsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminsInclude | null
    /**
     * Throw an Error if a Admins can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Admins to fetch.
     * 
    **/
    where: AdminsWhereUniqueInput
  }


  /**
   * Admins findFirst
   */
  export type AdminsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Admins
     * 
    **/
    select?: AdminsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminsInclude | null
    /**
     * Throw an Error if a Admins can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Admins to fetch.
     * 
    **/
    where?: AdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     * 
    **/
    orderBy?: Enumerable<AdminsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     * 
    **/
    cursor?: AdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     * 
    **/
    distinct?: Enumerable<AdminsScalarFieldEnum>
  }


  /**
   * Admins findMany
   */
  export type AdminsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Admins
     * 
    **/
    select?: AdminsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminsInclude | null
    /**
     * Filter, which Admins to fetch.
     * 
    **/
    where?: AdminsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     * 
    **/
    orderBy?: Enumerable<AdminsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     * 
    **/
    cursor?: AdminsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AdminsScalarFieldEnum>
  }


  /**
   * Admins create
   */
  export type AdminsCreateArgs = {
    /**
     * Select specific fields to fetch from the Admins
     * 
    **/
    select?: AdminsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminsInclude | null
    /**
     * The data needed to create a Admins.
     * 
    **/
    data: XOR<AdminsCreateInput, AdminsUncheckedCreateInput>
  }


  /**
   * Admins createMany
   */
  export type AdminsCreateManyArgs = {
    data: Enumerable<AdminsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Admins update
   */
  export type AdminsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Admins
     * 
    **/
    select?: AdminsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminsInclude | null
    /**
     * The data needed to update a Admins.
     * 
    **/
    data: XOR<AdminsUpdateInput, AdminsUncheckedUpdateInput>
    /**
     * Choose, which Admins to update.
     * 
    **/
    where: AdminsWhereUniqueInput
  }


  /**
   * Admins updateMany
   */
  export type AdminsUpdateManyArgs = {
    data: XOR<AdminsUpdateManyMutationInput, AdminsUncheckedUpdateManyInput>
    where?: AdminsWhereInput
  }


  /**
   * Admins upsert
   */
  export type AdminsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Admins
     * 
    **/
    select?: AdminsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminsInclude | null
    /**
     * The filter to search for the Admins to update in case it exists.
     * 
    **/
    where: AdminsWhereUniqueInput
    /**
     * In case the Admins found by the `where` argument doesn't exist, create a new Admins with this data.
     * 
    **/
    create: XOR<AdminsCreateInput, AdminsUncheckedCreateInput>
    /**
     * In case the Admins was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AdminsUpdateInput, AdminsUncheckedUpdateInput>
  }


  /**
   * Admins delete
   */
  export type AdminsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Admins
     * 
    **/
    select?: AdminsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminsInclude | null
    /**
     * Filter which Admins to delete.
     * 
    **/
    where: AdminsWhereUniqueInput
  }


  /**
   * Admins deleteMany
   */
  export type AdminsDeleteManyArgs = {
    where?: AdminsWhereInput
  }


  /**
   * Admins without action
   */
  export type AdminsArgs = {
    /**
     * Select specific fields to fetch from the Admins
     * 
    **/
    select?: AdminsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AdminsInclude | null
  }



  /**
   * Model Token
   */


  export type AggregateToken = {
    _count: TokenCountAggregateOutputType | null
    count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
    max: TokenMaxAggregateOutputType | null
  }

  export type TokenAvgAggregateOutputType = {
    id: number | null
    AdminsId: number | null
  }

  export type TokenSumAggregateOutputType = {
    id: number | null
    AdminsId: number | null
  }

  export type TokenMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    valid: boolean | null
    expiration: Date | null
    AdminsId: number | null
  }

  export type TokenMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    updated_at: Date | null
    valid: boolean | null
    expiration: Date | null
    AdminsId: number | null
  }

  export type TokenCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    valid: number
    expiration: number
    AdminsId: number
    _all: number
  }


  export type TokenAvgAggregateInputType = {
    id?: true
    AdminsId?: true
  }

  export type TokenSumAggregateInputType = {
    id?: true
    AdminsId?: true
  }

  export type TokenMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    valid?: true
    expiration?: true
    AdminsId?: true
  }

  export type TokenMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    valid?: true
    expiration?: true
    AdminsId?: true
  }

  export type TokenCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    valid?: true
    expiration?: true
    AdminsId?: true
    _all?: true
  }

  export type TokenAggregateArgs = {
    /**
     * Filter which Token to aggregate.
     * 
    **/
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     * 
    **/
    orderBy?: Enumerable<TokenOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tokens
    **/
    _count?: true | TokenCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | TokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: TokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: TokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: TokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: TokenMaxAggregateInputType
  }

  export type GetTokenAggregateType<T extends TokenAggregateArgs> = {
        [P in keyof T & keyof AggregateToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken[P]>
      : GetScalarType<T[P], AggregateToken[P]>
  }


    
    
  export type TokenGroupByArgs = {
    where?: TokenWhereInput
    orderBy?: Enumerable<TokenOrderByInput>
    by: Array<TokenScalarFieldEnum>
    having?: TokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenCountAggregateInputType | true
    _avg?: TokenAvgAggregateInputType
    _sum?: TokenSumAggregateInputType
    _min?: TokenMinAggregateInputType
    _max?: TokenMaxAggregateInputType
  }


  export type TokenGroupByOutputType = {
    id: number
    created_at: Date
    updated_at: Date
    valid: boolean
    expiration: Date
    AdminsId: number
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  type GetTokenGroupByPayload<T extends TokenGroupByArgs> = Promise<
    Array<
      PickArray<TokenGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof TokenGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], TokenGroupByOutputType[P]> 
            : GetScalarType<T[P], TokenGroupByOutputType[P]>
        }
      > 
    >


  export type TokenSelect = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    valid?: boolean
    expiration?: boolean
    Admins?: boolean | AdminsArgs
    AdminsId?: boolean
  }

  export type TokenInclude = {
    Admins?: boolean | AdminsArgs
  }

  export type TokenGetPayload<
    S extends boolean | null | undefined | TokenArgs,
    U = keyof S
      > = S extends true
        ? Token
    : S extends undefined
    ? never
    : S extends TokenArgs | TokenFindManyArgs
    ?'include' extends U
    ? Token  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Admins'
        ? AdminsGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Token ?Token [P]
  : 
          P extends 'Admins'
        ? AdminsGetPayload<S['select'][P]> : never
  } 
    : Token
  : Token


  type TokenCountArgs = Merge<
    Omit<TokenFindManyArgs, 'select' | 'include'> & {
      select?: TokenCountAggregateInputType | true
    }
  >

  export interface TokenDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Token that matches the filter.
     * @param {TokenFindUniqueArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TokenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TokenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Token'> extends True ? CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>> : CheckSelect<T, Prisma__TokenClient<Token | null >, Prisma__TokenClient<TokenGetPayload<T> | null >>

    /**
     * Find the first Token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TokenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TokenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Token'> extends True ? CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>> : CheckSelect<T, Prisma__TokenClient<Token | null >, Prisma__TokenClient<TokenGetPayload<T> | null >>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.token.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenWithIdOnly = await prisma.token.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TokenFindManyArgs>(
      args?: SelectSubset<T, TokenFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Token>>, PrismaPromise<Array<TokenGetPayload<T>>>>

    /**
     * Create a Token.
     * @param {TokenCreateArgs} args - Arguments to create a Token.
     * @example
     * // Create one Token
     * const Token = await prisma.token.create({
     *   data: {
     *     // ... data to create a Token
     *   }
     * })
     * 
    **/
    create<T extends TokenCreateArgs>(
      args: SelectSubset<T, TokenCreateArgs>
    ): CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>>

    /**
     * Create many Tokens.
     *     @param {TokenCreateManyArgs} args - Arguments to create many Tokens.
     *     @example
     *     // Create many Tokens
     *     const token = await prisma.token.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TokenCreateManyArgs>(
      args?: SelectSubset<T, TokenCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Token.
     * @param {TokenDeleteArgs} args - Arguments to delete one Token.
     * @example
     * // Delete one Token
     * const Token = await prisma.token.delete({
     *   where: {
     *     // ... filter to delete one Token
     *   }
     * })
     * 
    **/
    delete<T extends TokenDeleteArgs>(
      args: SelectSubset<T, TokenDeleteArgs>
    ): CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>>

    /**
     * Update one Token.
     * @param {TokenUpdateArgs} args - Arguments to update one Token.
     * @example
     * // Update one Token
     * const token = await prisma.token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TokenUpdateArgs>(
      args: SelectSubset<T, TokenUpdateArgs>
    ): CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>>

    /**
     * Delete zero or more Tokens.
     * @param {TokenDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TokenDeleteManyArgs>(
      args?: SelectSubset<T, TokenDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TokenUpdateManyArgs>(
      args: SelectSubset<T, TokenUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Token.
     * @param {TokenUpsertArgs} args - Arguments to update or create a Token.
     * @example
     * // Update or create a Token
     * const token = await prisma.token.upsert({
     *   create: {
     *     // ... data to create a Token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token we want to update
     *   }
     * })
    **/
    upsert<T extends TokenUpsertArgs>(
      args: SelectSubset<T, TokenUpsertArgs>
    ): CheckSelect<T, Prisma__TokenClient<Token>, Prisma__TokenClient<TokenGetPayload<T>>>

    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.token.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends TokenCountArgs>(
      args?: Subset<T, TokenCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenAggregateArgs>(args: Subset<T, TokenAggregateArgs>): PrismaPromise<GetTokenAggregateType<T>>

    /**
     * Group by Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenGroupByArgs['orderBy'] }
        : { orderBy?: TokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TokenClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Admins<T extends AdminsArgs = {}>(args?: Subset<T, AdminsArgs>): CheckSelect<T, Prisma__AdminsClient<Admins | null >, Prisma__AdminsClient<AdminsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Token findUnique
   */
  export type TokenFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * Throw an Error if a Token can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Token to fetch.
     * 
    **/
    where: TokenWhereUniqueInput
  }


  /**
   * Token findFirst
   */
  export type TokenFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * Throw an Error if a Token can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Token to fetch.
     * 
    **/
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     * 
    **/
    orderBy?: Enumerable<TokenOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     * 
    **/
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     * 
    **/
    distinct?: Enumerable<TokenScalarFieldEnum>
  }


  /**
   * Token findMany
   */
  export type TokenFindManyArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * Filter, which Tokens to fetch.
     * 
    **/
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     * 
    **/
    orderBy?: Enumerable<TokenOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tokens.
     * 
    **/
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TokenScalarFieldEnum>
  }


  /**
   * Token create
   */
  export type TokenCreateArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * The data needed to create a Token.
     * 
    **/
    data: XOR<TokenCreateInput, TokenUncheckedCreateInput>
  }


  /**
   * Token createMany
   */
  export type TokenCreateManyArgs = {
    data: Enumerable<TokenCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Token update
   */
  export type TokenUpdateArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * The data needed to update a Token.
     * 
    **/
    data: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    /**
     * Choose, which Token to update.
     * 
    **/
    where: TokenWhereUniqueInput
  }


  /**
   * Token updateMany
   */
  export type TokenUpdateManyArgs = {
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    where?: TokenWhereInput
  }


  /**
   * Token upsert
   */
  export type TokenUpsertArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * The filter to search for the Token to update in case it exists.
     * 
    **/
    where: TokenWhereUniqueInput
    /**
     * In case the Token found by the `where` argument doesn't exist, create a new Token with this data.
     * 
    **/
    create: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    /**
     * In case the Token was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
  }


  /**
   * Token delete
   */
  export type TokenDeleteArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
    /**
     * Filter which Token to delete.
     * 
    **/
    where: TokenWhereUniqueInput
  }


  /**
   * Token deleteMany
   */
  export type TokenDeleteManyArgs = {
    where?: TokenWhereInput
  }


  /**
   * Token without action
   */
  export type TokenArgs = {
    /**
     * Select specific fields to fetch from the Token
     * 
    **/
    select?: TokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TokenInclude | null
  }



  /**
   * Model UserPets
   */


  export type AggregateUserPets = {
    _count: UserPetsCountAggregateOutputType | null
    count: UserPetsCountAggregateOutputType | null
    _avg: UserPetsAvgAggregateOutputType | null
    avg: UserPetsAvgAggregateOutputType | null
    _sum: UserPetsSumAggregateOutputType | null
    sum: UserPetsSumAggregateOutputType | null
    _min: UserPetsMinAggregateOutputType | null
    min: UserPetsMinAggregateOutputType | null
    _max: UserPetsMaxAggregateOutputType | null
    max: UserPetsMaxAggregateOutputType | null
  }

  export type UserPetsAvgAggregateOutputType = {
    id: number | null
  }

  export type UserPetsSumAggregateOutputType = {
    id: number | null
  }

  export type UserPetsMinAggregateOutputType = {
    id: number | null
    uid: string | null
    name: string | null
    species: string | null
    breed: string | null
    date_of_birth: Date | null
    color: string | null
    profile_picture_url: string | null
    gender: Gender | null
    is_neutered: boolean | null
    is_dog_friendly: boolean | null
    is_cat_friendly: boolean | null
    is_under_10_child_friendly: boolean | null
    is_over_10_child_friendly: boolean | null
    is_microchipped: boolean | null
    is_purebred: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    UserId: string | null
  }

  export type UserPetsMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    name: string | null
    species: string | null
    breed: string | null
    date_of_birth: Date | null
    color: string | null
    profile_picture_url: string | null
    gender: Gender | null
    is_neutered: boolean | null
    is_dog_friendly: boolean | null
    is_cat_friendly: boolean | null
    is_under_10_child_friendly: boolean | null
    is_over_10_child_friendly: boolean | null
    is_microchipped: boolean | null
    is_purebred: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    UserId: string | null
  }

  export type UserPetsCountAggregateOutputType = {
    id: number
    uid: number
    name: number
    species: number
    breed: number
    date_of_birth: number
    color: number
    profile_picture_url: number
    gender: number
    is_neutered: number
    is_dog_friendly: number
    is_cat_friendly: number
    is_under_10_child_friendly: number
    is_over_10_child_friendly: number
    is_microchipped: number
    is_purebred: number
    created_at: number
    updated_at: number
    deleted_at: number
    UserId: number
    _all: number
  }


  export type UserPetsAvgAggregateInputType = {
    id?: true
  }

  export type UserPetsSumAggregateInputType = {
    id?: true
  }

  export type UserPetsMinAggregateInputType = {
    id?: true
    uid?: true
    name?: true
    species?: true
    breed?: true
    date_of_birth?: true
    color?: true
    profile_picture_url?: true
    gender?: true
    is_neutered?: true
    is_dog_friendly?: true
    is_cat_friendly?: true
    is_under_10_child_friendly?: true
    is_over_10_child_friendly?: true
    is_microchipped?: true
    is_purebred?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    UserId?: true
  }

  export type UserPetsMaxAggregateInputType = {
    id?: true
    uid?: true
    name?: true
    species?: true
    breed?: true
    date_of_birth?: true
    color?: true
    profile_picture_url?: true
    gender?: true
    is_neutered?: true
    is_dog_friendly?: true
    is_cat_friendly?: true
    is_under_10_child_friendly?: true
    is_over_10_child_friendly?: true
    is_microchipped?: true
    is_purebred?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    UserId?: true
  }

  export type UserPetsCountAggregateInputType = {
    id?: true
    uid?: true
    name?: true
    species?: true
    breed?: true
    date_of_birth?: true
    color?: true
    profile_picture_url?: true
    gender?: true
    is_neutered?: true
    is_dog_friendly?: true
    is_cat_friendly?: true
    is_under_10_child_friendly?: true
    is_over_10_child_friendly?: true
    is_microchipped?: true
    is_purebred?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    UserId?: true
    _all?: true
  }

  export type UserPetsAggregateArgs = {
    /**
     * Filter which UserPets to aggregate.
     * 
    **/
    where?: UserPetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPets to fetch.
     * 
    **/
    orderBy?: Enumerable<UserPetsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserPetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPets
    **/
    _count?: true | UserPetsCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | UserPetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPetsAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: UserPetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPetsSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: UserPetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPetsMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: UserPetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPetsMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: UserPetsMaxAggregateInputType
  }

  export type GetUserPetsAggregateType<T extends UserPetsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPets[P]>
      : GetScalarType<T[P], AggregateUserPets[P]>
  }


    
    
  export type UserPetsGroupByArgs = {
    where?: UserPetsWhereInput
    orderBy?: Enumerable<UserPetsOrderByInput>
    by: Array<UserPetsScalarFieldEnum>
    having?: UserPetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPetsCountAggregateInputType | true
    _avg?: UserPetsAvgAggregateInputType
    _sum?: UserPetsSumAggregateInputType
    _min?: UserPetsMinAggregateInputType
    _max?: UserPetsMaxAggregateInputType
  }


  export type UserPetsGroupByOutputType = {
    id: number
    uid: string
    name: string
    species: string | null
    breed: string | null
    date_of_birth: Date | null
    color: string | null
    profile_picture_url: string | null
    gender: Gender | null
    is_neutered: boolean | null
    is_dog_friendly: boolean | null
    is_cat_friendly: boolean | null
    is_under_10_child_friendly: boolean | null
    is_over_10_child_friendly: boolean | null
    is_microchipped: boolean | null
    is_purebred: boolean | null
    created_at: Date
    updated_at: Date | null
    deleted_at: Date | null
    UserId: string
    _count: UserPetsCountAggregateOutputType | null
    _avg: UserPetsAvgAggregateOutputType | null
    _sum: UserPetsSumAggregateOutputType | null
    _min: UserPetsMinAggregateOutputType | null
    _max: UserPetsMaxAggregateOutputType | null
  }

  type GetUserPetsGroupByPayload<T extends UserPetsGroupByArgs> = Promise<
    Array<
      PickArray<UserPetsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof UserPetsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], UserPetsGroupByOutputType[P]> 
            : GetScalarType<T[P], UserPetsGroupByOutputType[P]>
        }
      > 
    >


  export type UserPetsSelect = {
    id?: boolean
    uid?: boolean
    name?: boolean
    species?: boolean
    breed?: boolean
    date_of_birth?: boolean
    color?: boolean
    profile_picture_url?: boolean
    gender?: boolean
    is_neutered?: boolean
    is_dog_friendly?: boolean
    is_cat_friendly?: boolean
    is_under_10_child_friendly?: boolean
    is_over_10_child_friendly?: boolean
    is_microchipped?: boolean
    is_purebred?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    User?: boolean | UserArgs
    UserId?: boolean
    VaccineHistory?: boolean | VaccineHistoryFindManyArgs
    Consultations?: boolean | ConsultationsFindManyArgs
  }

  export type UserPetsInclude = {
    User?: boolean | UserArgs
    VaccineHistory?: boolean | VaccineHistoryFindManyArgs
    Consultations?: boolean | ConsultationsFindManyArgs
  }

  export type UserPetsGetPayload<
    S extends boolean | null | undefined | UserPetsArgs,
    U = keyof S
      > = S extends true
        ? UserPets
    : S extends undefined
    ? never
    : S extends UserPetsArgs | UserPetsFindManyArgs
    ?'include' extends U
    ? UserPets  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? UserGetPayload<S['include'][P]> :
        P extends 'VaccineHistory'
        ? Array < VaccineHistoryGetPayload<S['include'][P]>>  :
        P extends 'Consultations'
        ? Array < ConsultationsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserPets ?UserPets [P]
  : 
          P extends 'User'
        ? UserGetPayload<S['select'][P]> :
        P extends 'VaccineHistory'
        ? Array < VaccineHistoryGetPayload<S['select'][P]>>  :
        P extends 'Consultations'
        ? Array < ConsultationsGetPayload<S['select'][P]>>  : never
  } 
    : UserPets
  : UserPets


  type UserPetsCountArgs = Merge<
    Omit<UserPetsFindManyArgs, 'select' | 'include'> & {
      select?: UserPetsCountAggregateInputType | true
    }
  >

  export interface UserPetsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserPets that matches the filter.
     * @param {UserPetsFindUniqueArgs} args - Arguments to find a UserPets
     * @example
     * // Get one UserPets
     * const userPets = await prisma.userPets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserPetsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserPetsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserPets'> extends True ? CheckSelect<T, Prisma__UserPetsClient<UserPets>, Prisma__UserPetsClient<UserPetsGetPayload<T>>> : CheckSelect<T, Prisma__UserPetsClient<UserPets | null >, Prisma__UserPetsClient<UserPetsGetPayload<T> | null >>

    /**
     * Find the first UserPets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPetsFindFirstArgs} args - Arguments to find a UserPets
     * @example
     * // Get one UserPets
     * const userPets = await prisma.userPets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserPetsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserPetsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserPets'> extends True ? CheckSelect<T, Prisma__UserPetsClient<UserPets>, Prisma__UserPetsClient<UserPetsGetPayload<T>>> : CheckSelect<T, Prisma__UserPetsClient<UserPets | null >, Prisma__UserPetsClient<UserPetsGetPayload<T> | null >>

    /**
     * Find zero or more UserPets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPetsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPets
     * const userPets = await prisma.userPets.findMany()
     * 
     * // Get first 10 UserPets
     * const userPets = await prisma.userPets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPetsWithIdOnly = await prisma.userPets.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserPetsFindManyArgs>(
      args?: SelectSubset<T, UserPetsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserPets>>, PrismaPromise<Array<UserPetsGetPayload<T>>>>

    /**
     * Create a UserPets.
     * @param {UserPetsCreateArgs} args - Arguments to create a UserPets.
     * @example
     * // Create one UserPets
     * const UserPets = await prisma.userPets.create({
     *   data: {
     *     // ... data to create a UserPets
     *   }
     * })
     * 
    **/
    create<T extends UserPetsCreateArgs>(
      args: SelectSubset<T, UserPetsCreateArgs>
    ): CheckSelect<T, Prisma__UserPetsClient<UserPets>, Prisma__UserPetsClient<UserPetsGetPayload<T>>>

    /**
     * Create many UserPets.
     *     @param {UserPetsCreateManyArgs} args - Arguments to create many UserPets.
     *     @example
     *     // Create many UserPets
     *     const userPets = await prisma.userPets.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserPetsCreateManyArgs>(
      args?: SelectSubset<T, UserPetsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserPets.
     * @param {UserPetsDeleteArgs} args - Arguments to delete one UserPets.
     * @example
     * // Delete one UserPets
     * const UserPets = await prisma.userPets.delete({
     *   where: {
     *     // ... filter to delete one UserPets
     *   }
     * })
     * 
    **/
    delete<T extends UserPetsDeleteArgs>(
      args: SelectSubset<T, UserPetsDeleteArgs>
    ): CheckSelect<T, Prisma__UserPetsClient<UserPets>, Prisma__UserPetsClient<UserPetsGetPayload<T>>>

    /**
     * Update one UserPets.
     * @param {UserPetsUpdateArgs} args - Arguments to update one UserPets.
     * @example
     * // Update one UserPets
     * const userPets = await prisma.userPets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserPetsUpdateArgs>(
      args: SelectSubset<T, UserPetsUpdateArgs>
    ): CheckSelect<T, Prisma__UserPetsClient<UserPets>, Prisma__UserPetsClient<UserPetsGetPayload<T>>>

    /**
     * Delete zero or more UserPets.
     * @param {UserPetsDeleteManyArgs} args - Arguments to filter UserPets to delete.
     * @example
     * // Delete a few UserPets
     * const { count } = await prisma.userPets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserPetsDeleteManyArgs>(
      args?: SelectSubset<T, UserPetsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPets
     * const userPets = await prisma.userPets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserPetsUpdateManyArgs>(
      args: SelectSubset<T, UserPetsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPets.
     * @param {UserPetsUpsertArgs} args - Arguments to update or create a UserPets.
     * @example
     * // Update or create a UserPets
     * const userPets = await prisma.userPets.upsert({
     *   create: {
     *     // ... data to create a UserPets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPets we want to update
     *   }
     * })
    **/
    upsert<T extends UserPetsUpsertArgs>(
      args: SelectSubset<T, UserPetsUpsertArgs>
    ): CheckSelect<T, Prisma__UserPetsClient<UserPets>, Prisma__UserPetsClient<UserPetsGetPayload<T>>>

    /**
     * Count the number of UserPets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPetsCountArgs} args - Arguments to filter UserPets to count.
     * @example
     * // Count the number of UserPets
     * const count = await prisma.userPets.count({
     *   where: {
     *     // ... the filter for the UserPets we want to count
     *   }
     * })
    **/
    count<T extends UserPetsCountArgs>(
      args?: Subset<T, UserPetsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPetsAggregateArgs>(args: Subset<T, UserPetsAggregateArgs>): PrismaPromise<GetUserPetsAggregateType<T>>

    /**
     * Group by UserPets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPetsGroupByArgs['orderBy'] }
        : { orderBy?: UserPetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPetsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserPetsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    VaccineHistory<T extends VaccineHistoryFindManyArgs = {}>(args?: Subset<T, VaccineHistoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<VaccineHistory>>, PrismaPromise<Array<VaccineHistoryGetPayload<T>>>>;

    Consultations<T extends ConsultationsFindManyArgs = {}>(args?: Subset<T, ConsultationsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Consultations>>, PrismaPromise<Array<ConsultationsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserPets findUnique
   */
  export type UserPetsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserPets
     * 
    **/
    select?: UserPetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPetsInclude | null
    /**
     * Throw an Error if a UserPets can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserPets to fetch.
     * 
    **/
    where: UserPetsWhereUniqueInput
  }


  /**
   * UserPets findFirst
   */
  export type UserPetsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserPets
     * 
    **/
    select?: UserPetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPetsInclude | null
    /**
     * Throw an Error if a UserPets can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserPets to fetch.
     * 
    **/
    where?: UserPetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPets to fetch.
     * 
    **/
    orderBy?: Enumerable<UserPetsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPets.
     * 
    **/
    cursor?: UserPetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPets.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPets.
     * 
    **/
    distinct?: Enumerable<UserPetsScalarFieldEnum>
  }


  /**
   * UserPets findMany
   */
  export type UserPetsFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserPets
     * 
    **/
    select?: UserPetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPetsInclude | null
    /**
     * Filter, which UserPets to fetch.
     * 
    **/
    where?: UserPetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPets to fetch.
     * 
    **/
    orderBy?: Enumerable<UserPetsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPets.
     * 
    **/
    cursor?: UserPetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPets from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPets.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserPetsScalarFieldEnum>
  }


  /**
   * UserPets create
   */
  export type UserPetsCreateArgs = {
    /**
     * Select specific fields to fetch from the UserPets
     * 
    **/
    select?: UserPetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPetsInclude | null
    /**
     * The data needed to create a UserPets.
     * 
    **/
    data: XOR<UserPetsCreateInput, UserPetsUncheckedCreateInput>
  }


  /**
   * UserPets createMany
   */
  export type UserPetsCreateManyArgs = {
    data: Enumerable<UserPetsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserPets update
   */
  export type UserPetsUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserPets
     * 
    **/
    select?: UserPetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPetsInclude | null
    /**
     * The data needed to update a UserPets.
     * 
    **/
    data: XOR<UserPetsUpdateInput, UserPetsUncheckedUpdateInput>
    /**
     * Choose, which UserPets to update.
     * 
    **/
    where: UserPetsWhereUniqueInput
  }


  /**
   * UserPets updateMany
   */
  export type UserPetsUpdateManyArgs = {
    data: XOR<UserPetsUpdateManyMutationInput, UserPetsUncheckedUpdateManyInput>
    where?: UserPetsWhereInput
  }


  /**
   * UserPets upsert
   */
  export type UserPetsUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserPets
     * 
    **/
    select?: UserPetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPetsInclude | null
    /**
     * The filter to search for the UserPets to update in case it exists.
     * 
    **/
    where: UserPetsWhereUniqueInput
    /**
     * In case the UserPets found by the `where` argument doesn't exist, create a new UserPets with this data.
     * 
    **/
    create: XOR<UserPetsCreateInput, UserPetsUncheckedCreateInput>
    /**
     * In case the UserPets was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserPetsUpdateInput, UserPetsUncheckedUpdateInput>
  }


  /**
   * UserPets delete
   */
  export type UserPetsDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserPets
     * 
    **/
    select?: UserPetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPetsInclude | null
    /**
     * Filter which UserPets to delete.
     * 
    **/
    where: UserPetsWhereUniqueInput
  }


  /**
   * UserPets deleteMany
   */
  export type UserPetsDeleteManyArgs = {
    where?: UserPetsWhereInput
  }


  /**
   * UserPets without action
   */
  export type UserPetsArgs = {
    /**
     * Select specific fields to fetch from the UserPets
     * 
    **/
    select?: UserPetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserPetsInclude | null
  }



  /**
   * Model User_Address
   */


  export type AggregateUser_Address = {
    _count: User_AddressCountAggregateOutputType | null
    count: User_AddressCountAggregateOutputType | null
    _avg: User_AddressAvgAggregateOutputType | null
    avg: User_AddressAvgAggregateOutputType | null
    _sum: User_AddressSumAggregateOutputType | null
    sum: User_AddressSumAggregateOutputType | null
    _min: User_AddressMinAggregateOutputType | null
    min: User_AddressMinAggregateOutputType | null
    _max: User_AddressMaxAggregateOutputType | null
    max: User_AddressMaxAggregateOutputType | null
  }

  export type User_AddressAvgAggregateOutputType = {
    id: number | null
    city_id: number | null
    province_id: number | null
  }

  export type User_AddressSumAggregateOutputType = {
    id: number | null
    city_id: number | null
    province_id: number | null
  }

  export type User_AddressMinAggregateOutputType = {
    id: number | null
    uid: string | null
    label: string | null
    address: string | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    city_id: number | null
    province_id: number | null
    user_id: string | null
  }

  export type User_AddressMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    label: string | null
    address: string | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    city_id: number | null
    province_id: number | null
    user_id: string | null
  }

  export type User_AddressCountAggregateOutputType = {
    id: number
    uid: number
    label: number
    address: number
    is_default: number
    created_at: number
    updated_at: number
    deleted_at: number
    city_id: number
    province_id: number
    user_id: number
    _all: number
  }


  export type User_AddressAvgAggregateInputType = {
    id?: true
    city_id?: true
    province_id?: true
  }

  export type User_AddressSumAggregateInputType = {
    id?: true
    city_id?: true
    province_id?: true
  }

  export type User_AddressMinAggregateInputType = {
    id?: true
    uid?: true
    label?: true
    address?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    city_id?: true
    province_id?: true
    user_id?: true
  }

  export type User_AddressMaxAggregateInputType = {
    id?: true
    uid?: true
    label?: true
    address?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    city_id?: true
    province_id?: true
    user_id?: true
  }

  export type User_AddressCountAggregateInputType = {
    id?: true
    uid?: true
    label?: true
    address?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    city_id?: true
    province_id?: true
    user_id?: true
    _all?: true
  }

  export type User_AddressAggregateArgs = {
    /**
     * Filter which User_Address to aggregate.
     * 
    **/
    where?: User_AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<User_AddressOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: User_AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned User_Addresses
    **/
    _count?: true | User_AddressCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | User_AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_AddressAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: User_AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_AddressSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: User_AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_AddressMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: User_AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_AddressMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: User_AddressMaxAggregateInputType
  }

  export type GetUser_AddressAggregateType<T extends User_AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_Address]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_Address[P]>
      : GetScalarType<T[P], AggregateUser_Address[P]>
  }


    
    
  export type User_AddressGroupByArgs = {
    where?: User_AddressWhereInput
    orderBy?: Enumerable<User_AddressOrderByInput>
    by: Array<User_AddressScalarFieldEnum>
    having?: User_AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_AddressCountAggregateInputType | true
    _avg?: User_AddressAvgAggregateInputType
    _sum?: User_AddressSumAggregateInputType
    _min?: User_AddressMinAggregateInputType
    _max?: User_AddressMaxAggregateInputType
  }


  export type User_AddressGroupByOutputType = {
    id: number
    uid: string
    label: string
    address: string
    is_default: boolean
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    city_id: number | null
    province_id: number | null
    user_id: string
    _count: User_AddressCountAggregateOutputType | null
    _avg: User_AddressAvgAggregateOutputType | null
    _sum: User_AddressSumAggregateOutputType | null
    _min: User_AddressMinAggregateOutputType | null
    _max: User_AddressMaxAggregateOutputType | null
  }

  type GetUser_AddressGroupByPayload<T extends User_AddressGroupByArgs> = Promise<
    Array<
      PickArray<User_AddressGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof User_AddressGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], User_AddressGroupByOutputType[P]> 
            : GetScalarType<T[P], User_AddressGroupByOutputType[P]>
        }
      > 
    >


  export type User_AddressSelect = {
    id?: boolean
    uid?: boolean
    label?: boolean
    address?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    City?: boolean | CityArgs
    city_id?: boolean
    Province?: boolean | ProvinceArgs
    province_id?: boolean
    User?: boolean | UserArgs
    user_id?: boolean
  }

  export type User_AddressInclude = {
    City?: boolean | CityArgs
    Province?: boolean | ProvinceArgs
    User?: boolean | UserArgs
  }

  export type User_AddressGetPayload<
    S extends boolean | null | undefined | User_AddressArgs,
    U = keyof S
      > = S extends true
        ? User_Address
    : S extends undefined
    ? never
    : S extends User_AddressArgs | User_AddressFindManyArgs
    ?'include' extends U
    ? User_Address  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'City'
        ? CityGetPayload<S['include'][P]> | null :
        P extends 'Province'
        ? ProvinceGetPayload<S['include'][P]> | null :
        P extends 'User'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User_Address ?User_Address [P]
  : 
          P extends 'City'
        ? CityGetPayload<S['select'][P]> | null :
        P extends 'Province'
        ? ProvinceGetPayload<S['select'][P]> | null :
        P extends 'User'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : User_Address
  : User_Address


  type User_AddressCountArgs = Merge<
    Omit<User_AddressFindManyArgs, 'select' | 'include'> & {
      select?: User_AddressCountAggregateInputType | true
    }
  >

  export interface User_AddressDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User_Address that matches the filter.
     * @param {User_AddressFindUniqueArgs} args - Arguments to find a User_Address
     * @example
     * // Get one User_Address
     * const user_Address = await prisma.user_Address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends User_AddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, User_AddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User_Address'> extends True ? CheckSelect<T, Prisma__User_AddressClient<User_Address>, Prisma__User_AddressClient<User_AddressGetPayload<T>>> : CheckSelect<T, Prisma__User_AddressClient<User_Address | null >, Prisma__User_AddressClient<User_AddressGetPayload<T> | null >>

    /**
     * Find the first User_Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_AddressFindFirstArgs} args - Arguments to find a User_Address
     * @example
     * // Get one User_Address
     * const user_Address = await prisma.user_Address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends User_AddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, User_AddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User_Address'> extends True ? CheckSelect<T, Prisma__User_AddressClient<User_Address>, Prisma__User_AddressClient<User_AddressGetPayload<T>>> : CheckSelect<T, Prisma__User_AddressClient<User_Address | null >, Prisma__User_AddressClient<User_AddressGetPayload<T> | null >>

    /**
     * Find zero or more User_Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_AddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_Addresses
     * const user_Addresses = await prisma.user_Address.findMany()
     * 
     * // Get first 10 User_Addresses
     * const user_Addresses = await prisma.user_Address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_AddressWithIdOnly = await prisma.user_Address.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends User_AddressFindManyArgs>(
      args?: SelectSubset<T, User_AddressFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User_Address>>, PrismaPromise<Array<User_AddressGetPayload<T>>>>

    /**
     * Create a User_Address.
     * @param {User_AddressCreateArgs} args - Arguments to create a User_Address.
     * @example
     * // Create one User_Address
     * const User_Address = await prisma.user_Address.create({
     *   data: {
     *     // ... data to create a User_Address
     *   }
     * })
     * 
    **/
    create<T extends User_AddressCreateArgs>(
      args: SelectSubset<T, User_AddressCreateArgs>
    ): CheckSelect<T, Prisma__User_AddressClient<User_Address>, Prisma__User_AddressClient<User_AddressGetPayload<T>>>

    /**
     * Create many User_Addresses.
     *     @param {User_AddressCreateManyArgs} args - Arguments to create many User_Addresses.
     *     @example
     *     // Create many User_Addresses
     *     const user_Address = await prisma.user_Address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends User_AddressCreateManyArgs>(
      args?: SelectSubset<T, User_AddressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User_Address.
     * @param {User_AddressDeleteArgs} args - Arguments to delete one User_Address.
     * @example
     * // Delete one User_Address
     * const User_Address = await prisma.user_Address.delete({
     *   where: {
     *     // ... filter to delete one User_Address
     *   }
     * })
     * 
    **/
    delete<T extends User_AddressDeleteArgs>(
      args: SelectSubset<T, User_AddressDeleteArgs>
    ): CheckSelect<T, Prisma__User_AddressClient<User_Address>, Prisma__User_AddressClient<User_AddressGetPayload<T>>>

    /**
     * Update one User_Address.
     * @param {User_AddressUpdateArgs} args - Arguments to update one User_Address.
     * @example
     * // Update one User_Address
     * const user_Address = await prisma.user_Address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends User_AddressUpdateArgs>(
      args: SelectSubset<T, User_AddressUpdateArgs>
    ): CheckSelect<T, Prisma__User_AddressClient<User_Address>, Prisma__User_AddressClient<User_AddressGetPayload<T>>>

    /**
     * Delete zero or more User_Addresses.
     * @param {User_AddressDeleteManyArgs} args - Arguments to filter User_Addresses to delete.
     * @example
     * // Delete a few User_Addresses
     * const { count } = await prisma.user_Address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends User_AddressDeleteManyArgs>(
      args?: SelectSubset<T, User_AddressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_Addresses
     * const user_Address = await prisma.user_Address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends User_AddressUpdateManyArgs>(
      args: SelectSubset<T, User_AddressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User_Address.
     * @param {User_AddressUpsertArgs} args - Arguments to update or create a User_Address.
     * @example
     * // Update or create a User_Address
     * const user_Address = await prisma.user_Address.upsert({
     *   create: {
     *     // ... data to create a User_Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_Address we want to update
     *   }
     * })
    **/
    upsert<T extends User_AddressUpsertArgs>(
      args: SelectSubset<T, User_AddressUpsertArgs>
    ): CheckSelect<T, Prisma__User_AddressClient<User_Address>, Prisma__User_AddressClient<User_AddressGetPayload<T>>>

    /**
     * Count the number of User_Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_AddressCountArgs} args - Arguments to filter User_Addresses to count.
     * @example
     * // Count the number of User_Addresses
     * const count = await prisma.user_Address.count({
     *   where: {
     *     // ... the filter for the User_Addresses we want to count
     *   }
     * })
    **/
    count<T extends User_AddressCountArgs>(
      args?: Subset<T, User_AddressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_AddressAggregateArgs>(args: Subset<T, User_AddressAggregateArgs>): PrismaPromise<GetUser_AddressAggregateType<T>>

    /**
     * Group by User_Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_AddressGroupByArgs['orderBy'] }
        : { orderBy?: User_AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_AddressGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User_Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__User_AddressClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    City<T extends CityArgs = {}>(args?: Subset<T, CityArgs>): CheckSelect<T, Prisma__CityClient<City | null >, Prisma__CityClient<CityGetPayload<T> | null >>;

    Province<T extends ProvinceArgs = {}>(args?: Subset<T, ProvinceArgs>): CheckSelect<T, Prisma__ProvinceClient<Province | null >, Prisma__ProvinceClient<ProvinceGetPayload<T> | null >>;

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User_Address findUnique
   */
  export type User_AddressFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User_Address
     * 
    **/
    select?: User_AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_AddressInclude | null
    /**
     * Throw an Error if a User_Address can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User_Address to fetch.
     * 
    **/
    where: User_AddressWhereUniqueInput
  }


  /**
   * User_Address findFirst
   */
  export type User_AddressFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User_Address
     * 
    **/
    select?: User_AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_AddressInclude | null
    /**
     * Throw an Error if a User_Address can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User_Address to fetch.
     * 
    **/
    where?: User_AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<User_AddressOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for User_Addresses.
     * 
    **/
    cursor?: User_AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of User_Addresses.
     * 
    **/
    distinct?: Enumerable<User_AddressScalarFieldEnum>
  }


  /**
   * User_Address findMany
   */
  export type User_AddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the User_Address
     * 
    **/
    select?: User_AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_AddressInclude | null
    /**
     * Filter, which User_Addresses to fetch.
     * 
    **/
    where?: User_AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<User_AddressOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing User_Addresses.
     * 
    **/
    cursor?: User_AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Addresses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<User_AddressScalarFieldEnum>
  }


  /**
   * User_Address create
   */
  export type User_AddressCreateArgs = {
    /**
     * Select specific fields to fetch from the User_Address
     * 
    **/
    select?: User_AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_AddressInclude | null
    /**
     * The data needed to create a User_Address.
     * 
    **/
    data: XOR<User_AddressCreateInput, User_AddressUncheckedCreateInput>
  }


  /**
   * User_Address createMany
   */
  export type User_AddressCreateManyArgs = {
    data: Enumerable<User_AddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User_Address update
   */
  export type User_AddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the User_Address
     * 
    **/
    select?: User_AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_AddressInclude | null
    /**
     * The data needed to update a User_Address.
     * 
    **/
    data: XOR<User_AddressUpdateInput, User_AddressUncheckedUpdateInput>
    /**
     * Choose, which User_Address to update.
     * 
    **/
    where: User_AddressWhereUniqueInput
  }


  /**
   * User_Address updateMany
   */
  export type User_AddressUpdateManyArgs = {
    data: XOR<User_AddressUpdateManyMutationInput, User_AddressUncheckedUpdateManyInput>
    where?: User_AddressWhereInput
  }


  /**
   * User_Address upsert
   */
  export type User_AddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the User_Address
     * 
    **/
    select?: User_AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_AddressInclude | null
    /**
     * The filter to search for the User_Address to update in case it exists.
     * 
    **/
    where: User_AddressWhereUniqueInput
    /**
     * In case the User_Address found by the `where` argument doesn't exist, create a new User_Address with this data.
     * 
    **/
    create: XOR<User_AddressCreateInput, User_AddressUncheckedCreateInput>
    /**
     * In case the User_Address was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<User_AddressUpdateInput, User_AddressUncheckedUpdateInput>
  }


  /**
   * User_Address delete
   */
  export type User_AddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the User_Address
     * 
    **/
    select?: User_AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_AddressInclude | null
    /**
     * Filter which User_Address to delete.
     * 
    **/
    where: User_AddressWhereUniqueInput
  }


  /**
   * User_Address deleteMany
   */
  export type User_AddressDeleteManyArgs = {
    where?: User_AddressWhereInput
  }


  /**
   * User_Address without action
   */
  export type User_AddressArgs = {
    /**
     * Select specific fields to fetch from the User_Address
     * 
    **/
    select?: User_AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_AddressInclude | null
  }



  /**
   * Model User_Bank
   */


  export type AggregateUser_Bank = {
    _count: User_BankCountAggregateOutputType | null
    count: User_BankCountAggregateOutputType | null
    _avg: User_BankAvgAggregateOutputType | null
    avg: User_BankAvgAggregateOutputType | null
    _sum: User_BankSumAggregateOutputType | null
    sum: User_BankSumAggregateOutputType | null
    _min: User_BankMinAggregateOutputType | null
    min: User_BankMinAggregateOutputType | null
    _max: User_BankMaxAggregateOutputType | null
    max: User_BankMaxAggregateOutputType | null
  }

  export type User_BankAvgAggregateOutputType = {
    id: number | null
    UserId: number | null
  }

  export type User_BankSumAggregateOutputType = {
    id: number | null
    UserId: number | null
  }

  export type User_BankMinAggregateOutputType = {
    id: number | null
    uid: string | null
    alias: string | null
    bank_name: string | null
    account_number: string | null
    bank_username: string | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    UserId: number | null
  }

  export type User_BankMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    alias: string | null
    bank_name: string | null
    account_number: string | null
    bank_username: string | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    UserId: number | null
  }

  export type User_BankCountAggregateOutputType = {
    id: number
    uid: number
    alias: number
    bank_name: number
    account_number: number
    bank_username: number
    is_default: number
    created_at: number
    updated_at: number
    deleted_at: number
    UserId: number
    _all: number
  }


  export type User_BankAvgAggregateInputType = {
    id?: true
    UserId?: true
  }

  export type User_BankSumAggregateInputType = {
    id?: true
    UserId?: true
  }

  export type User_BankMinAggregateInputType = {
    id?: true
    uid?: true
    alias?: true
    bank_name?: true
    account_number?: true
    bank_username?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    UserId?: true
  }

  export type User_BankMaxAggregateInputType = {
    id?: true
    uid?: true
    alias?: true
    bank_name?: true
    account_number?: true
    bank_username?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    UserId?: true
  }

  export type User_BankCountAggregateInputType = {
    id?: true
    uid?: true
    alias?: true
    bank_name?: true
    account_number?: true
    bank_username?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    UserId?: true
    _all?: true
  }

  export type User_BankAggregateArgs = {
    /**
     * Filter which User_Bank to aggregate.
     * 
    **/
    where?: User_BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Banks to fetch.
     * 
    **/
    orderBy?: Enumerable<User_BankOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: User_BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Banks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Banks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned User_Banks
    **/
    _count?: true | User_BankCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | User_BankCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_BankAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: User_BankAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_BankSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: User_BankSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_BankMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: User_BankMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_BankMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: User_BankMaxAggregateInputType
  }

  export type GetUser_BankAggregateType<T extends User_BankAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_Bank]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_Bank[P]>
      : GetScalarType<T[P], AggregateUser_Bank[P]>
  }


    
    
  export type User_BankGroupByArgs = {
    where?: User_BankWhereInput
    orderBy?: Enumerable<User_BankOrderByInput>
    by: Array<User_BankScalarFieldEnum>
    having?: User_BankScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_BankCountAggregateInputType | true
    _avg?: User_BankAvgAggregateInputType
    _sum?: User_BankSumAggregateInputType
    _min?: User_BankMinAggregateInputType
    _max?: User_BankMaxAggregateInputType
  }


  export type User_BankGroupByOutputType = {
    id: number
    uid: string
    alias: string
    bank_name: string
    account_number: string
    bank_username: string
    is_default: boolean
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    UserId: number
    _count: User_BankCountAggregateOutputType | null
    _avg: User_BankAvgAggregateOutputType | null
    _sum: User_BankSumAggregateOutputType | null
    _min: User_BankMinAggregateOutputType | null
    _max: User_BankMaxAggregateOutputType | null
  }

  type GetUser_BankGroupByPayload<T extends User_BankGroupByArgs> = Promise<
    Array<
      PickArray<User_BankGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof User_BankGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], User_BankGroupByOutputType[P]> 
            : GetScalarType<T[P], User_BankGroupByOutputType[P]>
        }
      > 
    >


  export type User_BankSelect = {
    id?: boolean
    uid?: boolean
    alias?: boolean
    bank_name?: boolean
    account_number?: boolean
    bank_username?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    User?: boolean | UserArgs
    UserId?: boolean
  }

  export type User_BankInclude = {
    User?: boolean | UserArgs
  }

  export type User_BankGetPayload<
    S extends boolean | null | undefined | User_BankArgs,
    U = keyof S
      > = S extends true
        ? User_Bank
    : S extends undefined
    ? never
    : S extends User_BankArgs | User_BankFindManyArgs
    ?'include' extends U
    ? User_Bank  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User_Bank ?User_Bank [P]
  : 
          P extends 'User'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : User_Bank
  : User_Bank


  type User_BankCountArgs = Merge<
    Omit<User_BankFindManyArgs, 'select' | 'include'> & {
      select?: User_BankCountAggregateInputType | true
    }
  >

  export interface User_BankDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User_Bank that matches the filter.
     * @param {User_BankFindUniqueArgs} args - Arguments to find a User_Bank
     * @example
     * // Get one User_Bank
     * const user_Bank = await prisma.user_Bank.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends User_BankFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, User_BankFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User_Bank'> extends True ? CheckSelect<T, Prisma__User_BankClient<User_Bank>, Prisma__User_BankClient<User_BankGetPayload<T>>> : CheckSelect<T, Prisma__User_BankClient<User_Bank | null >, Prisma__User_BankClient<User_BankGetPayload<T> | null >>

    /**
     * Find the first User_Bank that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_BankFindFirstArgs} args - Arguments to find a User_Bank
     * @example
     * // Get one User_Bank
     * const user_Bank = await prisma.user_Bank.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends User_BankFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, User_BankFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User_Bank'> extends True ? CheckSelect<T, Prisma__User_BankClient<User_Bank>, Prisma__User_BankClient<User_BankGetPayload<T>>> : CheckSelect<T, Prisma__User_BankClient<User_Bank | null >, Prisma__User_BankClient<User_BankGetPayload<T> | null >>

    /**
     * Find zero or more User_Banks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_BankFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_Banks
     * const user_Banks = await prisma.user_Bank.findMany()
     * 
     * // Get first 10 User_Banks
     * const user_Banks = await prisma.user_Bank.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_BankWithIdOnly = await prisma.user_Bank.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends User_BankFindManyArgs>(
      args?: SelectSubset<T, User_BankFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User_Bank>>, PrismaPromise<Array<User_BankGetPayload<T>>>>

    /**
     * Create a User_Bank.
     * @param {User_BankCreateArgs} args - Arguments to create a User_Bank.
     * @example
     * // Create one User_Bank
     * const User_Bank = await prisma.user_Bank.create({
     *   data: {
     *     // ... data to create a User_Bank
     *   }
     * })
     * 
    **/
    create<T extends User_BankCreateArgs>(
      args: SelectSubset<T, User_BankCreateArgs>
    ): CheckSelect<T, Prisma__User_BankClient<User_Bank>, Prisma__User_BankClient<User_BankGetPayload<T>>>

    /**
     * Create many User_Banks.
     *     @param {User_BankCreateManyArgs} args - Arguments to create many User_Banks.
     *     @example
     *     // Create many User_Banks
     *     const user_Bank = await prisma.user_Bank.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends User_BankCreateManyArgs>(
      args?: SelectSubset<T, User_BankCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User_Bank.
     * @param {User_BankDeleteArgs} args - Arguments to delete one User_Bank.
     * @example
     * // Delete one User_Bank
     * const User_Bank = await prisma.user_Bank.delete({
     *   where: {
     *     // ... filter to delete one User_Bank
     *   }
     * })
     * 
    **/
    delete<T extends User_BankDeleteArgs>(
      args: SelectSubset<T, User_BankDeleteArgs>
    ): CheckSelect<T, Prisma__User_BankClient<User_Bank>, Prisma__User_BankClient<User_BankGetPayload<T>>>

    /**
     * Update one User_Bank.
     * @param {User_BankUpdateArgs} args - Arguments to update one User_Bank.
     * @example
     * // Update one User_Bank
     * const user_Bank = await prisma.user_Bank.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends User_BankUpdateArgs>(
      args: SelectSubset<T, User_BankUpdateArgs>
    ): CheckSelect<T, Prisma__User_BankClient<User_Bank>, Prisma__User_BankClient<User_BankGetPayload<T>>>

    /**
     * Delete zero or more User_Banks.
     * @param {User_BankDeleteManyArgs} args - Arguments to filter User_Banks to delete.
     * @example
     * // Delete a few User_Banks
     * const { count } = await prisma.user_Bank.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends User_BankDeleteManyArgs>(
      args?: SelectSubset<T, User_BankDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_BankUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_Banks
     * const user_Bank = await prisma.user_Bank.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends User_BankUpdateManyArgs>(
      args: SelectSubset<T, User_BankUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User_Bank.
     * @param {User_BankUpsertArgs} args - Arguments to update or create a User_Bank.
     * @example
     * // Update or create a User_Bank
     * const user_Bank = await prisma.user_Bank.upsert({
     *   create: {
     *     // ... data to create a User_Bank
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_Bank we want to update
     *   }
     * })
    **/
    upsert<T extends User_BankUpsertArgs>(
      args: SelectSubset<T, User_BankUpsertArgs>
    ): CheckSelect<T, Prisma__User_BankClient<User_Bank>, Prisma__User_BankClient<User_BankGetPayload<T>>>

    /**
     * Count the number of User_Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_BankCountArgs} args - Arguments to filter User_Banks to count.
     * @example
     * // Count the number of User_Banks
     * const count = await prisma.user_Bank.count({
     *   where: {
     *     // ... the filter for the User_Banks we want to count
     *   }
     * })
    **/
    count<T extends User_BankCountArgs>(
      args?: Subset<T, User_BankCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_BankCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_Bank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_BankAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_BankAggregateArgs>(args: Subset<T, User_BankAggregateArgs>): PrismaPromise<GetUser_BankAggregateType<T>>

    /**
     * Group by User_Bank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_BankGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_BankGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_BankGroupByArgs['orderBy'] }
        : { orderBy?: User_BankGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_BankGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_BankGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User_Bank.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__User_BankClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User_Bank findUnique
   */
  export type User_BankFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User_Bank
     * 
    **/
    select?: User_BankSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_BankInclude | null
    /**
     * Throw an Error if a User_Bank can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User_Bank to fetch.
     * 
    **/
    where: User_BankWhereUniqueInput
  }


  /**
   * User_Bank findFirst
   */
  export type User_BankFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User_Bank
     * 
    **/
    select?: User_BankSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_BankInclude | null
    /**
     * Throw an Error if a User_Bank can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User_Bank to fetch.
     * 
    **/
    where?: User_BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Banks to fetch.
     * 
    **/
    orderBy?: Enumerable<User_BankOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for User_Banks.
     * 
    **/
    cursor?: User_BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Banks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Banks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of User_Banks.
     * 
    **/
    distinct?: Enumerable<User_BankScalarFieldEnum>
  }


  /**
   * User_Bank findMany
   */
  export type User_BankFindManyArgs = {
    /**
     * Select specific fields to fetch from the User_Bank
     * 
    **/
    select?: User_BankSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_BankInclude | null
    /**
     * Filter, which User_Banks to fetch.
     * 
    **/
    where?: User_BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_Banks to fetch.
     * 
    **/
    orderBy?: Enumerable<User_BankOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing User_Banks.
     * 
    **/
    cursor?: User_BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_Banks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_Banks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<User_BankScalarFieldEnum>
  }


  /**
   * User_Bank create
   */
  export type User_BankCreateArgs = {
    /**
     * Select specific fields to fetch from the User_Bank
     * 
    **/
    select?: User_BankSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_BankInclude | null
    /**
     * The data needed to create a User_Bank.
     * 
    **/
    data: XOR<User_BankCreateInput, User_BankUncheckedCreateInput>
  }


  /**
   * User_Bank createMany
   */
  export type User_BankCreateManyArgs = {
    data: Enumerable<User_BankCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User_Bank update
   */
  export type User_BankUpdateArgs = {
    /**
     * Select specific fields to fetch from the User_Bank
     * 
    **/
    select?: User_BankSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_BankInclude | null
    /**
     * The data needed to update a User_Bank.
     * 
    **/
    data: XOR<User_BankUpdateInput, User_BankUncheckedUpdateInput>
    /**
     * Choose, which User_Bank to update.
     * 
    **/
    where: User_BankWhereUniqueInput
  }


  /**
   * User_Bank updateMany
   */
  export type User_BankUpdateManyArgs = {
    data: XOR<User_BankUpdateManyMutationInput, User_BankUncheckedUpdateManyInput>
    where?: User_BankWhereInput
  }


  /**
   * User_Bank upsert
   */
  export type User_BankUpsertArgs = {
    /**
     * Select specific fields to fetch from the User_Bank
     * 
    **/
    select?: User_BankSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_BankInclude | null
    /**
     * The filter to search for the User_Bank to update in case it exists.
     * 
    **/
    where: User_BankWhereUniqueInput
    /**
     * In case the User_Bank found by the `where` argument doesn't exist, create a new User_Bank with this data.
     * 
    **/
    create: XOR<User_BankCreateInput, User_BankUncheckedCreateInput>
    /**
     * In case the User_Bank was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<User_BankUpdateInput, User_BankUncheckedUpdateInput>
  }


  /**
   * User_Bank delete
   */
  export type User_BankDeleteArgs = {
    /**
     * Select specific fields to fetch from the User_Bank
     * 
    **/
    select?: User_BankSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_BankInclude | null
    /**
     * Filter which User_Bank to delete.
     * 
    **/
    where: User_BankWhereUniqueInput
  }


  /**
   * User_Bank deleteMany
   */
  export type User_BankDeleteManyArgs = {
    where?: User_BankWhereInput
  }


  /**
   * User_Bank without action
   */
  export type User_BankArgs = {
    /**
     * Select specific fields to fetch from the User_Bank
     * 
    **/
    select?: User_BankSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: User_BankInclude | null
  }



  /**
   * Model Vendor_Bank
   */


  export type AggregateVendor_Bank = {
    _count: Vendor_BankCountAggregateOutputType | null
    count: Vendor_BankCountAggregateOutputType | null
    _avg: Vendor_BankAvgAggregateOutputType | null
    avg: Vendor_BankAvgAggregateOutputType | null
    _sum: Vendor_BankSumAggregateOutputType | null
    sum: Vendor_BankSumAggregateOutputType | null
    _min: Vendor_BankMinAggregateOutputType | null
    min: Vendor_BankMinAggregateOutputType | null
    _max: Vendor_BankMaxAggregateOutputType | null
    max: Vendor_BankMaxAggregateOutputType | null
  }

  export type Vendor_BankAvgAggregateOutputType = {
    id: number | null
  }

  export type Vendor_BankSumAggregateOutputType = {
    id: number | null
  }

  export type Vendor_BankMinAggregateOutputType = {
    id: number | null
    uid: string | null
    alias: string | null
    bank_name: string | null
    account_number: string | null
    bank_username: string | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Vendor_BankMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    alias: string | null
    bank_name: string | null
    account_number: string | null
    bank_username: string | null
    is_default: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Vendor_BankCountAggregateOutputType = {
    id: number
    uid: number
    alias: number
    bank_name: number
    account_number: number
    bank_username: number
    is_default: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Vendor_BankAvgAggregateInputType = {
    id?: true
  }

  export type Vendor_BankSumAggregateInputType = {
    id?: true
  }

  export type Vendor_BankMinAggregateInputType = {
    id?: true
    uid?: true
    alias?: true
    bank_name?: true
    account_number?: true
    bank_username?: true
    is_default?: true
    created_at?: true
    updated_at?: true
  }

  export type Vendor_BankMaxAggregateInputType = {
    id?: true
    uid?: true
    alias?: true
    bank_name?: true
    account_number?: true
    bank_username?: true
    is_default?: true
    created_at?: true
    updated_at?: true
  }

  export type Vendor_BankCountAggregateInputType = {
    id?: true
    uid?: true
    alias?: true
    bank_name?: true
    account_number?: true
    bank_username?: true
    is_default?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Vendor_BankAggregateArgs = {
    /**
     * Filter which Vendor_Bank to aggregate.
     * 
    **/
    where?: Vendor_BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendor_Banks to fetch.
     * 
    **/
    orderBy?: Enumerable<Vendor_BankOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: Vendor_BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendor_Banks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendor_Banks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendor_Banks
    **/
    _count?: true | Vendor_BankCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | Vendor_BankCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Vendor_BankAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: Vendor_BankAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Vendor_BankSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: Vendor_BankSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vendor_BankMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: Vendor_BankMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vendor_BankMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: Vendor_BankMaxAggregateInputType
  }

  export type GetVendor_BankAggregateType<T extends Vendor_BankAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor_Bank]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor_Bank[P]>
      : GetScalarType<T[P], AggregateVendor_Bank[P]>
  }


    
    
  export type Vendor_BankGroupByArgs = {
    where?: Vendor_BankWhereInput
    orderBy?: Enumerable<Vendor_BankOrderByInput>
    by: Array<Vendor_BankScalarFieldEnum>
    having?: Vendor_BankScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vendor_BankCountAggregateInputType | true
    _avg?: Vendor_BankAvgAggregateInputType
    _sum?: Vendor_BankSumAggregateInputType
    _min?: Vendor_BankMinAggregateInputType
    _max?: Vendor_BankMaxAggregateInputType
  }


  export type Vendor_BankGroupByOutputType = {
    id: number
    uid: string
    alias: string
    bank_name: string
    account_number: string
    bank_username: string
    is_default: boolean
    created_at: Date
    updated_at: Date
    _count: Vendor_BankCountAggregateOutputType | null
    _avg: Vendor_BankAvgAggregateOutputType | null
    _sum: Vendor_BankSumAggregateOutputType | null
    _min: Vendor_BankMinAggregateOutputType | null
    _max: Vendor_BankMaxAggregateOutputType | null
  }

  type GetVendor_BankGroupByPayload<T extends Vendor_BankGroupByArgs> = Promise<
    Array<
      PickArray<Vendor_BankGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof Vendor_BankGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], Vendor_BankGroupByOutputType[P]> 
            : GetScalarType<T[P], Vendor_BankGroupByOutputType[P]>
        }
      > 
    >


  export type Vendor_BankSelect = {
    id?: boolean
    uid?: boolean
    alias?: boolean
    bank_name?: boolean
    account_number?: boolean
    bank_username?: boolean
    is_default?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type Vendor_BankGetPayload<
    S extends boolean | null | undefined | Vendor_BankArgs,
    U = keyof S
      > = S extends true
        ? Vendor_Bank
    : S extends undefined
    ? never
    : S extends Vendor_BankArgs | Vendor_BankFindManyArgs
    ?'include' extends U
    ? Vendor_Bank 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Vendor_Bank ?Vendor_Bank [P]
  : 
     never
  } 
    : Vendor_Bank
  : Vendor_Bank


  type Vendor_BankCountArgs = Merge<
    Omit<Vendor_BankFindManyArgs, 'select' | 'include'> & {
      select?: Vendor_BankCountAggregateInputType | true
    }
  >

  export interface Vendor_BankDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Vendor_Bank that matches the filter.
     * @param {Vendor_BankFindUniqueArgs} args - Arguments to find a Vendor_Bank
     * @example
     * // Get one Vendor_Bank
     * const vendor_Bank = await prisma.vendor_Bank.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Vendor_BankFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Vendor_BankFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Vendor_Bank'> extends True ? CheckSelect<T, Prisma__Vendor_BankClient<Vendor_Bank>, Prisma__Vendor_BankClient<Vendor_BankGetPayload<T>>> : CheckSelect<T, Prisma__Vendor_BankClient<Vendor_Bank | null >, Prisma__Vendor_BankClient<Vendor_BankGetPayload<T> | null >>

    /**
     * Find the first Vendor_Bank that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vendor_BankFindFirstArgs} args - Arguments to find a Vendor_Bank
     * @example
     * // Get one Vendor_Bank
     * const vendor_Bank = await prisma.vendor_Bank.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Vendor_BankFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Vendor_BankFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Vendor_Bank'> extends True ? CheckSelect<T, Prisma__Vendor_BankClient<Vendor_Bank>, Prisma__Vendor_BankClient<Vendor_BankGetPayload<T>>> : CheckSelect<T, Prisma__Vendor_BankClient<Vendor_Bank | null >, Prisma__Vendor_BankClient<Vendor_BankGetPayload<T> | null >>

    /**
     * Find zero or more Vendor_Banks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vendor_BankFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendor_Banks
     * const vendor_Banks = await prisma.vendor_Bank.findMany()
     * 
     * // Get first 10 Vendor_Banks
     * const vendor_Banks = await prisma.vendor_Bank.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendor_BankWithIdOnly = await prisma.vendor_Bank.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Vendor_BankFindManyArgs>(
      args?: SelectSubset<T, Vendor_BankFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Vendor_Bank>>, PrismaPromise<Array<Vendor_BankGetPayload<T>>>>

    /**
     * Create a Vendor_Bank.
     * @param {Vendor_BankCreateArgs} args - Arguments to create a Vendor_Bank.
     * @example
     * // Create one Vendor_Bank
     * const Vendor_Bank = await prisma.vendor_Bank.create({
     *   data: {
     *     // ... data to create a Vendor_Bank
     *   }
     * })
     * 
    **/
    create<T extends Vendor_BankCreateArgs>(
      args: SelectSubset<T, Vendor_BankCreateArgs>
    ): CheckSelect<T, Prisma__Vendor_BankClient<Vendor_Bank>, Prisma__Vendor_BankClient<Vendor_BankGetPayload<T>>>

    /**
     * Create many Vendor_Banks.
     *     @param {Vendor_BankCreateManyArgs} args - Arguments to create many Vendor_Banks.
     *     @example
     *     // Create many Vendor_Banks
     *     const vendor_Bank = await prisma.vendor_Bank.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Vendor_BankCreateManyArgs>(
      args?: SelectSubset<T, Vendor_BankCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Vendor_Bank.
     * @param {Vendor_BankDeleteArgs} args - Arguments to delete one Vendor_Bank.
     * @example
     * // Delete one Vendor_Bank
     * const Vendor_Bank = await prisma.vendor_Bank.delete({
     *   where: {
     *     // ... filter to delete one Vendor_Bank
     *   }
     * })
     * 
    **/
    delete<T extends Vendor_BankDeleteArgs>(
      args: SelectSubset<T, Vendor_BankDeleteArgs>
    ): CheckSelect<T, Prisma__Vendor_BankClient<Vendor_Bank>, Prisma__Vendor_BankClient<Vendor_BankGetPayload<T>>>

    /**
     * Update one Vendor_Bank.
     * @param {Vendor_BankUpdateArgs} args - Arguments to update one Vendor_Bank.
     * @example
     * // Update one Vendor_Bank
     * const vendor_Bank = await prisma.vendor_Bank.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Vendor_BankUpdateArgs>(
      args: SelectSubset<T, Vendor_BankUpdateArgs>
    ): CheckSelect<T, Prisma__Vendor_BankClient<Vendor_Bank>, Prisma__Vendor_BankClient<Vendor_BankGetPayload<T>>>

    /**
     * Delete zero or more Vendor_Banks.
     * @param {Vendor_BankDeleteManyArgs} args - Arguments to filter Vendor_Banks to delete.
     * @example
     * // Delete a few Vendor_Banks
     * const { count } = await prisma.vendor_Bank.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Vendor_BankDeleteManyArgs>(
      args?: SelectSubset<T, Vendor_BankDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendor_Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vendor_BankUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendor_Banks
     * const vendor_Bank = await prisma.vendor_Bank.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Vendor_BankUpdateManyArgs>(
      args: SelectSubset<T, Vendor_BankUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendor_Bank.
     * @param {Vendor_BankUpsertArgs} args - Arguments to update or create a Vendor_Bank.
     * @example
     * // Update or create a Vendor_Bank
     * const vendor_Bank = await prisma.vendor_Bank.upsert({
     *   create: {
     *     // ... data to create a Vendor_Bank
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor_Bank we want to update
     *   }
     * })
    **/
    upsert<T extends Vendor_BankUpsertArgs>(
      args: SelectSubset<T, Vendor_BankUpsertArgs>
    ): CheckSelect<T, Prisma__Vendor_BankClient<Vendor_Bank>, Prisma__Vendor_BankClient<Vendor_BankGetPayload<T>>>

    /**
     * Count the number of Vendor_Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vendor_BankCountArgs} args - Arguments to filter Vendor_Banks to count.
     * @example
     * // Count the number of Vendor_Banks
     * const count = await prisma.vendor_Bank.count({
     *   where: {
     *     // ... the filter for the Vendor_Banks we want to count
     *   }
     * })
    **/
    count<T extends Vendor_BankCountArgs>(
      args?: Subset<T, Vendor_BankCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vendor_BankCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor_Bank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vendor_BankAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vendor_BankAggregateArgs>(args: Subset<T, Vendor_BankAggregateArgs>): PrismaPromise<GetVendor_BankAggregateType<T>>

    /**
     * Group by Vendor_Bank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vendor_BankGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Vendor_BankGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Vendor_BankGroupByArgs['orderBy'] }
        : { orderBy?: Vendor_BankGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Vendor_BankGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendor_BankGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor_Bank.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Vendor_BankClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Vendor_Bank findUnique
   */
  export type Vendor_BankFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Bank
     * 
    **/
    select?: Vendor_BankSelect | null
    /**
     * Throw an Error if a Vendor_Bank can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Vendor_Bank to fetch.
     * 
    **/
    where: Vendor_BankWhereUniqueInput
  }


  /**
   * Vendor_Bank findFirst
   */
  export type Vendor_BankFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Bank
     * 
    **/
    select?: Vendor_BankSelect | null
    /**
     * Throw an Error if a Vendor_Bank can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Vendor_Bank to fetch.
     * 
    **/
    where?: Vendor_BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendor_Banks to fetch.
     * 
    **/
    orderBy?: Enumerable<Vendor_BankOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendor_Banks.
     * 
    **/
    cursor?: Vendor_BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendor_Banks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendor_Banks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendor_Banks.
     * 
    **/
    distinct?: Enumerable<Vendor_BankScalarFieldEnum>
  }


  /**
   * Vendor_Bank findMany
   */
  export type Vendor_BankFindManyArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Bank
     * 
    **/
    select?: Vendor_BankSelect | null
    /**
     * Filter, which Vendor_Banks to fetch.
     * 
    **/
    where?: Vendor_BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendor_Banks to fetch.
     * 
    **/
    orderBy?: Enumerable<Vendor_BankOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendor_Banks.
     * 
    **/
    cursor?: Vendor_BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendor_Banks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendor_Banks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Vendor_BankScalarFieldEnum>
  }


  /**
   * Vendor_Bank create
   */
  export type Vendor_BankCreateArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Bank
     * 
    **/
    select?: Vendor_BankSelect | null
    /**
     * The data needed to create a Vendor_Bank.
     * 
    **/
    data: XOR<Vendor_BankCreateInput, Vendor_BankUncheckedCreateInput>
  }


  /**
   * Vendor_Bank createMany
   */
  export type Vendor_BankCreateManyArgs = {
    data: Enumerable<Vendor_BankCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Vendor_Bank update
   */
  export type Vendor_BankUpdateArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Bank
     * 
    **/
    select?: Vendor_BankSelect | null
    /**
     * The data needed to update a Vendor_Bank.
     * 
    **/
    data: XOR<Vendor_BankUpdateInput, Vendor_BankUncheckedUpdateInput>
    /**
     * Choose, which Vendor_Bank to update.
     * 
    **/
    where: Vendor_BankWhereUniqueInput
  }


  /**
   * Vendor_Bank updateMany
   */
  export type Vendor_BankUpdateManyArgs = {
    data: XOR<Vendor_BankUpdateManyMutationInput, Vendor_BankUncheckedUpdateManyInput>
    where?: Vendor_BankWhereInput
  }


  /**
   * Vendor_Bank upsert
   */
  export type Vendor_BankUpsertArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Bank
     * 
    **/
    select?: Vendor_BankSelect | null
    /**
     * The filter to search for the Vendor_Bank to update in case it exists.
     * 
    **/
    where: Vendor_BankWhereUniqueInput
    /**
     * In case the Vendor_Bank found by the `where` argument doesn't exist, create a new Vendor_Bank with this data.
     * 
    **/
    create: XOR<Vendor_BankCreateInput, Vendor_BankUncheckedCreateInput>
    /**
     * In case the Vendor_Bank was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<Vendor_BankUpdateInput, Vendor_BankUncheckedUpdateInput>
  }


  /**
   * Vendor_Bank delete
   */
  export type Vendor_BankDeleteArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Bank
     * 
    **/
    select?: Vendor_BankSelect | null
    /**
     * Filter which Vendor_Bank to delete.
     * 
    **/
    where: Vendor_BankWhereUniqueInput
  }


  /**
   * Vendor_Bank deleteMany
   */
  export type Vendor_BankDeleteManyArgs = {
    where?: Vendor_BankWhereInput
  }


  /**
   * Vendor_Bank without action
   */
  export type Vendor_BankArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Bank
     * 
    **/
    select?: Vendor_BankSelect | null
  }



  /**
   * Model VaccineType
   */


  export type AggregateVaccineType = {
    _count: VaccineTypeCountAggregateOutputType | null
    count: VaccineTypeCountAggregateOutputType | null
    _avg: VaccineTypeAvgAggregateOutputType | null
    avg: VaccineTypeAvgAggregateOutputType | null
    _sum: VaccineTypeSumAggregateOutputType | null
    sum: VaccineTypeSumAggregateOutputType | null
    _min: VaccineTypeMinAggregateOutputType | null
    min: VaccineTypeMinAggregateOutputType | null
    _max: VaccineTypeMaxAggregateOutputType | null
    max: VaccineTypeMaxAggregateOutputType | null
  }

  export type VaccineTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type VaccineTypeSumAggregateOutputType = {
    id: number | null
  }

  export type VaccineTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VaccineTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VaccineTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VaccineTypeAvgAggregateInputType = {
    id?: true
  }

  export type VaccineTypeSumAggregateInputType = {
    id?: true
  }

  export type VaccineTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type VaccineTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type VaccineTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VaccineTypeAggregateArgs = {
    /**
     * Filter which VaccineType to aggregate.
     * 
    **/
    where?: VaccineTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccineTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<VaccineTypeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VaccineTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccineTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccineTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VaccineTypes
    **/
    _count?: true | VaccineTypeCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | VaccineTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VaccineTypeAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: VaccineTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VaccineTypeSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: VaccineTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VaccineTypeMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: VaccineTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VaccineTypeMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: VaccineTypeMaxAggregateInputType
  }

  export type GetVaccineTypeAggregateType<T extends VaccineTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateVaccineType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVaccineType[P]>
      : GetScalarType<T[P], AggregateVaccineType[P]>
  }


    
    
  export type VaccineTypeGroupByArgs = {
    where?: VaccineTypeWhereInput
    orderBy?: Enumerable<VaccineTypeOrderByInput>
    by: Array<VaccineTypeScalarFieldEnum>
    having?: VaccineTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VaccineTypeCountAggregateInputType | true
    _avg?: VaccineTypeAvgAggregateInputType
    _sum?: VaccineTypeSumAggregateInputType
    _min?: VaccineTypeMinAggregateInputType
    _max?: VaccineTypeMaxAggregateInputType
  }


  export type VaccineTypeGroupByOutputType = {
    id: number
    name: string
    description: string
    created_at: Date
    updated_at: Date
    _count: VaccineTypeCountAggregateOutputType | null
    _avg: VaccineTypeAvgAggregateOutputType | null
    _sum: VaccineTypeSumAggregateOutputType | null
    _min: VaccineTypeMinAggregateOutputType | null
    _max: VaccineTypeMaxAggregateOutputType | null
  }

  type GetVaccineTypeGroupByPayload<T extends VaccineTypeGroupByArgs> = Promise<
    Array<
      PickArray<VaccineTypeGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof VaccineTypeGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], VaccineTypeGroupByOutputType[P]> 
            : GetScalarType<T[P], VaccineTypeGroupByOutputType[P]>
        }
      > 
    >


  export type VaccineTypeSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    VaccineHistory?: boolean | VaccineHistoryFindManyArgs
  }

  export type VaccineTypeInclude = {
    VaccineHistory?: boolean | VaccineHistoryFindManyArgs
  }

  export type VaccineTypeGetPayload<
    S extends boolean | null | undefined | VaccineTypeArgs,
    U = keyof S
      > = S extends true
        ? VaccineType
    : S extends undefined
    ? never
    : S extends VaccineTypeArgs | VaccineTypeFindManyArgs
    ?'include' extends U
    ? VaccineType  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'VaccineHistory'
        ? Array < VaccineHistoryGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof VaccineType ?VaccineType [P]
  : 
          P extends 'VaccineHistory'
        ? Array < VaccineHistoryGetPayload<S['select'][P]>>  : never
  } 
    : VaccineType
  : VaccineType


  type VaccineTypeCountArgs = Merge<
    Omit<VaccineTypeFindManyArgs, 'select' | 'include'> & {
      select?: VaccineTypeCountAggregateInputType | true
    }
  >

  export interface VaccineTypeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one VaccineType that matches the filter.
     * @param {VaccineTypeFindUniqueArgs} args - Arguments to find a VaccineType
     * @example
     * // Get one VaccineType
     * const vaccineType = await prisma.vaccineType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VaccineTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VaccineTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VaccineType'> extends True ? CheckSelect<T, Prisma__VaccineTypeClient<VaccineType>, Prisma__VaccineTypeClient<VaccineTypeGetPayload<T>>> : CheckSelect<T, Prisma__VaccineTypeClient<VaccineType | null >, Prisma__VaccineTypeClient<VaccineTypeGetPayload<T> | null >>

    /**
     * Find the first VaccineType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineTypeFindFirstArgs} args - Arguments to find a VaccineType
     * @example
     * // Get one VaccineType
     * const vaccineType = await prisma.vaccineType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VaccineTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VaccineTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VaccineType'> extends True ? CheckSelect<T, Prisma__VaccineTypeClient<VaccineType>, Prisma__VaccineTypeClient<VaccineTypeGetPayload<T>>> : CheckSelect<T, Prisma__VaccineTypeClient<VaccineType | null >, Prisma__VaccineTypeClient<VaccineTypeGetPayload<T> | null >>

    /**
     * Find zero or more VaccineTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VaccineTypes
     * const vaccineTypes = await prisma.vaccineType.findMany()
     * 
     * // Get first 10 VaccineTypes
     * const vaccineTypes = await prisma.vaccineType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vaccineTypeWithIdOnly = await prisma.vaccineType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VaccineTypeFindManyArgs>(
      args?: SelectSubset<T, VaccineTypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<VaccineType>>, PrismaPromise<Array<VaccineTypeGetPayload<T>>>>

    /**
     * Create a VaccineType.
     * @param {VaccineTypeCreateArgs} args - Arguments to create a VaccineType.
     * @example
     * // Create one VaccineType
     * const VaccineType = await prisma.vaccineType.create({
     *   data: {
     *     // ... data to create a VaccineType
     *   }
     * })
     * 
    **/
    create<T extends VaccineTypeCreateArgs>(
      args: SelectSubset<T, VaccineTypeCreateArgs>
    ): CheckSelect<T, Prisma__VaccineTypeClient<VaccineType>, Prisma__VaccineTypeClient<VaccineTypeGetPayload<T>>>

    /**
     * Create many VaccineTypes.
     *     @param {VaccineTypeCreateManyArgs} args - Arguments to create many VaccineTypes.
     *     @example
     *     // Create many VaccineTypes
     *     const vaccineType = await prisma.vaccineType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VaccineTypeCreateManyArgs>(
      args?: SelectSubset<T, VaccineTypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VaccineType.
     * @param {VaccineTypeDeleteArgs} args - Arguments to delete one VaccineType.
     * @example
     * // Delete one VaccineType
     * const VaccineType = await prisma.vaccineType.delete({
     *   where: {
     *     // ... filter to delete one VaccineType
     *   }
     * })
     * 
    **/
    delete<T extends VaccineTypeDeleteArgs>(
      args: SelectSubset<T, VaccineTypeDeleteArgs>
    ): CheckSelect<T, Prisma__VaccineTypeClient<VaccineType>, Prisma__VaccineTypeClient<VaccineTypeGetPayload<T>>>

    /**
     * Update one VaccineType.
     * @param {VaccineTypeUpdateArgs} args - Arguments to update one VaccineType.
     * @example
     * // Update one VaccineType
     * const vaccineType = await prisma.vaccineType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VaccineTypeUpdateArgs>(
      args: SelectSubset<T, VaccineTypeUpdateArgs>
    ): CheckSelect<T, Prisma__VaccineTypeClient<VaccineType>, Prisma__VaccineTypeClient<VaccineTypeGetPayload<T>>>

    /**
     * Delete zero or more VaccineTypes.
     * @param {VaccineTypeDeleteManyArgs} args - Arguments to filter VaccineTypes to delete.
     * @example
     * // Delete a few VaccineTypes
     * const { count } = await prisma.vaccineType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VaccineTypeDeleteManyArgs>(
      args?: SelectSubset<T, VaccineTypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VaccineTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VaccineTypes
     * const vaccineType = await prisma.vaccineType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VaccineTypeUpdateManyArgs>(
      args: SelectSubset<T, VaccineTypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VaccineType.
     * @param {VaccineTypeUpsertArgs} args - Arguments to update or create a VaccineType.
     * @example
     * // Update or create a VaccineType
     * const vaccineType = await prisma.vaccineType.upsert({
     *   create: {
     *     // ... data to create a VaccineType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VaccineType we want to update
     *   }
     * })
    **/
    upsert<T extends VaccineTypeUpsertArgs>(
      args: SelectSubset<T, VaccineTypeUpsertArgs>
    ): CheckSelect<T, Prisma__VaccineTypeClient<VaccineType>, Prisma__VaccineTypeClient<VaccineTypeGetPayload<T>>>

    /**
     * Count the number of VaccineTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineTypeCountArgs} args - Arguments to filter VaccineTypes to count.
     * @example
     * // Count the number of VaccineTypes
     * const count = await prisma.vaccineType.count({
     *   where: {
     *     // ... the filter for the VaccineTypes we want to count
     *   }
     * })
    **/
    count<T extends VaccineTypeCountArgs>(
      args?: Subset<T, VaccineTypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VaccineTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VaccineType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VaccineTypeAggregateArgs>(args: Subset<T, VaccineTypeAggregateArgs>): PrismaPromise<GetVaccineTypeAggregateType<T>>

    /**
     * Group by VaccineType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VaccineTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VaccineTypeGroupByArgs['orderBy'] }
        : { orderBy?: VaccineTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VaccineTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVaccineTypeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for VaccineType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VaccineTypeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    VaccineHistory<T extends VaccineHistoryFindManyArgs = {}>(args?: Subset<T, VaccineHistoryFindManyArgs>): CheckSelect<T, PrismaPromise<Array<VaccineHistory>>, PrismaPromise<Array<VaccineHistoryGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * VaccineType findUnique
   */
  export type VaccineTypeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the VaccineType
     * 
    **/
    select?: VaccineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineTypeInclude | null
    /**
     * Throw an Error if a VaccineType can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VaccineType to fetch.
     * 
    **/
    where: VaccineTypeWhereUniqueInput
  }


  /**
   * VaccineType findFirst
   */
  export type VaccineTypeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the VaccineType
     * 
    **/
    select?: VaccineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineTypeInclude | null
    /**
     * Throw an Error if a VaccineType can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VaccineType to fetch.
     * 
    **/
    where?: VaccineTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccineTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<VaccineTypeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VaccineTypes.
     * 
    **/
    cursor?: VaccineTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccineTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccineTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VaccineTypes.
     * 
    **/
    distinct?: Enumerable<VaccineTypeScalarFieldEnum>
  }


  /**
   * VaccineType findMany
   */
  export type VaccineTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the VaccineType
     * 
    **/
    select?: VaccineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineTypeInclude | null
    /**
     * Filter, which VaccineTypes to fetch.
     * 
    **/
    where?: VaccineTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccineTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<VaccineTypeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VaccineTypes.
     * 
    **/
    cursor?: VaccineTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccineTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccineTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VaccineTypeScalarFieldEnum>
  }


  /**
   * VaccineType create
   */
  export type VaccineTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the VaccineType
     * 
    **/
    select?: VaccineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineTypeInclude | null
    /**
     * The data needed to create a VaccineType.
     * 
    **/
    data: XOR<VaccineTypeCreateInput, VaccineTypeUncheckedCreateInput>
  }


  /**
   * VaccineType createMany
   */
  export type VaccineTypeCreateManyArgs = {
    data: Enumerable<VaccineTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VaccineType update
   */
  export type VaccineTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the VaccineType
     * 
    **/
    select?: VaccineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineTypeInclude | null
    /**
     * The data needed to update a VaccineType.
     * 
    **/
    data: XOR<VaccineTypeUpdateInput, VaccineTypeUncheckedUpdateInput>
    /**
     * Choose, which VaccineType to update.
     * 
    **/
    where: VaccineTypeWhereUniqueInput
  }


  /**
   * VaccineType updateMany
   */
  export type VaccineTypeUpdateManyArgs = {
    data: XOR<VaccineTypeUpdateManyMutationInput, VaccineTypeUncheckedUpdateManyInput>
    where?: VaccineTypeWhereInput
  }


  /**
   * VaccineType upsert
   */
  export type VaccineTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the VaccineType
     * 
    **/
    select?: VaccineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineTypeInclude | null
    /**
     * The filter to search for the VaccineType to update in case it exists.
     * 
    **/
    where: VaccineTypeWhereUniqueInput
    /**
     * In case the VaccineType found by the `where` argument doesn't exist, create a new VaccineType with this data.
     * 
    **/
    create: XOR<VaccineTypeCreateInput, VaccineTypeUncheckedCreateInput>
    /**
     * In case the VaccineType was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VaccineTypeUpdateInput, VaccineTypeUncheckedUpdateInput>
  }


  /**
   * VaccineType delete
   */
  export type VaccineTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the VaccineType
     * 
    **/
    select?: VaccineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineTypeInclude | null
    /**
     * Filter which VaccineType to delete.
     * 
    **/
    where: VaccineTypeWhereUniqueInput
  }


  /**
   * VaccineType deleteMany
   */
  export type VaccineTypeDeleteManyArgs = {
    where?: VaccineTypeWhereInput
  }


  /**
   * VaccineType without action
   */
  export type VaccineTypeArgs = {
    /**
     * Select specific fields to fetch from the VaccineType
     * 
    **/
    select?: VaccineTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineTypeInclude | null
  }



  /**
   * Model VaccineHistory
   */


  export type AggregateVaccineHistory = {
    _count: VaccineHistoryCountAggregateOutputType | null
    count: VaccineHistoryCountAggregateOutputType | null
    _avg: VaccineHistoryAvgAggregateOutputType | null
    avg: VaccineHistoryAvgAggregateOutputType | null
    _sum: VaccineHistorySumAggregateOutputType | null
    sum: VaccineHistorySumAggregateOutputType | null
    _min: VaccineHistoryMinAggregateOutputType | null
    min: VaccineHistoryMinAggregateOutputType | null
    _max: VaccineHistoryMaxAggregateOutputType | null
    max: VaccineHistoryMaxAggregateOutputType | null
  }

  export type VaccineHistoryAvgAggregateOutputType = {
    id: number | null
    vaccine_type_id: number | null
  }

  export type VaccineHistorySumAggregateOutputType = {
    id: number | null
    vaccine_type_id: number | null
  }

  export type VaccineHistoryMinAggregateOutputType = {
    id: number | null
    uid: string | null
    pet_id: string | null
    veterinary: string | null
    vaccine_photo: string | null
    date_administered: Date | null
    is_manual: boolean | null
    date_valid_until: Date | null
    vaccine_type_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VaccineHistoryMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    pet_id: string | null
    veterinary: string | null
    vaccine_photo: string | null
    date_administered: Date | null
    is_manual: boolean | null
    date_valid_until: Date | null
    vaccine_type_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VaccineHistoryCountAggregateOutputType = {
    id: number
    uid: number
    pet_id: number
    veterinary: number
    vaccine_photo: number
    date_administered: number
    is_manual: number
    date_valid_until: number
    vaccine_type_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VaccineHistoryAvgAggregateInputType = {
    id?: true
    vaccine_type_id?: true
  }

  export type VaccineHistorySumAggregateInputType = {
    id?: true
    vaccine_type_id?: true
  }

  export type VaccineHistoryMinAggregateInputType = {
    id?: true
    uid?: true
    pet_id?: true
    veterinary?: true
    vaccine_photo?: true
    date_administered?: true
    is_manual?: true
    date_valid_until?: true
    vaccine_type_id?: true
    created_at?: true
    updated_at?: true
  }

  export type VaccineHistoryMaxAggregateInputType = {
    id?: true
    uid?: true
    pet_id?: true
    veterinary?: true
    vaccine_photo?: true
    date_administered?: true
    is_manual?: true
    date_valid_until?: true
    vaccine_type_id?: true
    created_at?: true
    updated_at?: true
  }

  export type VaccineHistoryCountAggregateInputType = {
    id?: true
    uid?: true
    pet_id?: true
    veterinary?: true
    vaccine_photo?: true
    date_administered?: true
    is_manual?: true
    date_valid_until?: true
    vaccine_type_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VaccineHistoryAggregateArgs = {
    /**
     * Filter which VaccineHistory to aggregate.
     * 
    **/
    where?: VaccineHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccineHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<VaccineHistoryOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VaccineHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccineHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccineHistories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VaccineHistories
    **/
    _count?: true | VaccineHistoryCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | VaccineHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VaccineHistoryAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: VaccineHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VaccineHistorySumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: VaccineHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VaccineHistoryMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: VaccineHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VaccineHistoryMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: VaccineHistoryMaxAggregateInputType
  }

  export type GetVaccineHistoryAggregateType<T extends VaccineHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateVaccineHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVaccineHistory[P]>
      : GetScalarType<T[P], AggregateVaccineHistory[P]>
  }


    
    
  export type VaccineHistoryGroupByArgs = {
    where?: VaccineHistoryWhereInput
    orderBy?: Enumerable<VaccineHistoryOrderByInput>
    by: Array<VaccineHistoryScalarFieldEnum>
    having?: VaccineHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VaccineHistoryCountAggregateInputType | true
    _avg?: VaccineHistoryAvgAggregateInputType
    _sum?: VaccineHistorySumAggregateInputType
    _min?: VaccineHistoryMinAggregateInputType
    _max?: VaccineHistoryMaxAggregateInputType
  }


  export type VaccineHistoryGroupByOutputType = {
    id: number
    uid: string
    pet_id: string
    veterinary: string
    vaccine_photo: string
    date_administered: Date
    is_manual: boolean
    date_valid_until: Date
    vaccine_type_id: number | null
    created_at: Date
    updated_at: Date
    _count: VaccineHistoryCountAggregateOutputType | null
    _avg: VaccineHistoryAvgAggregateOutputType | null
    _sum: VaccineHistorySumAggregateOutputType | null
    _min: VaccineHistoryMinAggregateOutputType | null
    _max: VaccineHistoryMaxAggregateOutputType | null
  }

  type GetVaccineHistoryGroupByPayload<T extends VaccineHistoryGroupByArgs> = Promise<
    Array<
      PickArray<VaccineHistoryGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof VaccineHistoryGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], VaccineHistoryGroupByOutputType[P]> 
            : GetScalarType<T[P], VaccineHistoryGroupByOutputType[P]>
        }
      > 
    >


  export type VaccineHistorySelect = {
    id?: boolean
    uid?: boolean
    pet?: boolean | UserPetsArgs
    pet_id?: boolean
    veterinary?: boolean
    vaccine_photo?: boolean
    date_administered?: boolean
    is_manual?: boolean
    date_valid_until?: boolean
    vaccine_type?: boolean | VaccineTypeArgs
    vaccine_type_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    VaccineHistoryPhoto?: boolean | VaccineHistoryPhotoFindManyArgs
  }

  export type VaccineHistoryInclude = {
    pet?: boolean | UserPetsArgs
    vaccine_type?: boolean | VaccineTypeArgs
    VaccineHistoryPhoto?: boolean | VaccineHistoryPhotoFindManyArgs
  }

  export type VaccineHistoryGetPayload<
    S extends boolean | null | undefined | VaccineHistoryArgs,
    U = keyof S
      > = S extends true
        ? VaccineHistory
    : S extends undefined
    ? never
    : S extends VaccineHistoryArgs | VaccineHistoryFindManyArgs
    ?'include' extends U
    ? VaccineHistory  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'pet'
        ? UserPetsGetPayload<S['include'][P]> | null :
        P extends 'vaccine_type'
        ? VaccineTypeGetPayload<S['include'][P]> | null :
        P extends 'VaccineHistoryPhoto'
        ? Array < VaccineHistoryPhotoGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof VaccineHistory ?VaccineHistory [P]
  : 
          P extends 'pet'
        ? UserPetsGetPayload<S['select'][P]> | null :
        P extends 'vaccine_type'
        ? VaccineTypeGetPayload<S['select'][P]> | null :
        P extends 'VaccineHistoryPhoto'
        ? Array < VaccineHistoryPhotoGetPayload<S['select'][P]>>  : never
  } 
    : VaccineHistory
  : VaccineHistory


  type VaccineHistoryCountArgs = Merge<
    Omit<VaccineHistoryFindManyArgs, 'select' | 'include'> & {
      select?: VaccineHistoryCountAggregateInputType | true
    }
  >

  export interface VaccineHistoryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one VaccineHistory that matches the filter.
     * @param {VaccineHistoryFindUniqueArgs} args - Arguments to find a VaccineHistory
     * @example
     * // Get one VaccineHistory
     * const vaccineHistory = await prisma.vaccineHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VaccineHistoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VaccineHistoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VaccineHistory'> extends True ? CheckSelect<T, Prisma__VaccineHistoryClient<VaccineHistory>, Prisma__VaccineHistoryClient<VaccineHistoryGetPayload<T>>> : CheckSelect<T, Prisma__VaccineHistoryClient<VaccineHistory | null >, Prisma__VaccineHistoryClient<VaccineHistoryGetPayload<T> | null >>

    /**
     * Find the first VaccineHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineHistoryFindFirstArgs} args - Arguments to find a VaccineHistory
     * @example
     * // Get one VaccineHistory
     * const vaccineHistory = await prisma.vaccineHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VaccineHistoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VaccineHistoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VaccineHistory'> extends True ? CheckSelect<T, Prisma__VaccineHistoryClient<VaccineHistory>, Prisma__VaccineHistoryClient<VaccineHistoryGetPayload<T>>> : CheckSelect<T, Prisma__VaccineHistoryClient<VaccineHistory | null >, Prisma__VaccineHistoryClient<VaccineHistoryGetPayload<T> | null >>

    /**
     * Find zero or more VaccineHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VaccineHistories
     * const vaccineHistories = await prisma.vaccineHistory.findMany()
     * 
     * // Get first 10 VaccineHistories
     * const vaccineHistories = await prisma.vaccineHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vaccineHistoryWithIdOnly = await prisma.vaccineHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VaccineHistoryFindManyArgs>(
      args?: SelectSubset<T, VaccineHistoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<VaccineHistory>>, PrismaPromise<Array<VaccineHistoryGetPayload<T>>>>

    /**
     * Create a VaccineHistory.
     * @param {VaccineHistoryCreateArgs} args - Arguments to create a VaccineHistory.
     * @example
     * // Create one VaccineHistory
     * const VaccineHistory = await prisma.vaccineHistory.create({
     *   data: {
     *     // ... data to create a VaccineHistory
     *   }
     * })
     * 
    **/
    create<T extends VaccineHistoryCreateArgs>(
      args: SelectSubset<T, VaccineHistoryCreateArgs>
    ): CheckSelect<T, Prisma__VaccineHistoryClient<VaccineHistory>, Prisma__VaccineHistoryClient<VaccineHistoryGetPayload<T>>>

    /**
     * Create many VaccineHistories.
     *     @param {VaccineHistoryCreateManyArgs} args - Arguments to create many VaccineHistories.
     *     @example
     *     // Create many VaccineHistories
     *     const vaccineHistory = await prisma.vaccineHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VaccineHistoryCreateManyArgs>(
      args?: SelectSubset<T, VaccineHistoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VaccineHistory.
     * @param {VaccineHistoryDeleteArgs} args - Arguments to delete one VaccineHistory.
     * @example
     * // Delete one VaccineHistory
     * const VaccineHistory = await prisma.vaccineHistory.delete({
     *   where: {
     *     // ... filter to delete one VaccineHistory
     *   }
     * })
     * 
    **/
    delete<T extends VaccineHistoryDeleteArgs>(
      args: SelectSubset<T, VaccineHistoryDeleteArgs>
    ): CheckSelect<T, Prisma__VaccineHistoryClient<VaccineHistory>, Prisma__VaccineHistoryClient<VaccineHistoryGetPayload<T>>>

    /**
     * Update one VaccineHistory.
     * @param {VaccineHistoryUpdateArgs} args - Arguments to update one VaccineHistory.
     * @example
     * // Update one VaccineHistory
     * const vaccineHistory = await prisma.vaccineHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VaccineHistoryUpdateArgs>(
      args: SelectSubset<T, VaccineHistoryUpdateArgs>
    ): CheckSelect<T, Prisma__VaccineHistoryClient<VaccineHistory>, Prisma__VaccineHistoryClient<VaccineHistoryGetPayload<T>>>

    /**
     * Delete zero or more VaccineHistories.
     * @param {VaccineHistoryDeleteManyArgs} args - Arguments to filter VaccineHistories to delete.
     * @example
     * // Delete a few VaccineHistories
     * const { count } = await prisma.vaccineHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VaccineHistoryDeleteManyArgs>(
      args?: SelectSubset<T, VaccineHistoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VaccineHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VaccineHistories
     * const vaccineHistory = await prisma.vaccineHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VaccineHistoryUpdateManyArgs>(
      args: SelectSubset<T, VaccineHistoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VaccineHistory.
     * @param {VaccineHistoryUpsertArgs} args - Arguments to update or create a VaccineHistory.
     * @example
     * // Update or create a VaccineHistory
     * const vaccineHistory = await prisma.vaccineHistory.upsert({
     *   create: {
     *     // ... data to create a VaccineHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VaccineHistory we want to update
     *   }
     * })
    **/
    upsert<T extends VaccineHistoryUpsertArgs>(
      args: SelectSubset<T, VaccineHistoryUpsertArgs>
    ): CheckSelect<T, Prisma__VaccineHistoryClient<VaccineHistory>, Prisma__VaccineHistoryClient<VaccineHistoryGetPayload<T>>>

    /**
     * Count the number of VaccineHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineHistoryCountArgs} args - Arguments to filter VaccineHistories to count.
     * @example
     * // Count the number of VaccineHistories
     * const count = await prisma.vaccineHistory.count({
     *   where: {
     *     // ... the filter for the VaccineHistories we want to count
     *   }
     * })
    **/
    count<T extends VaccineHistoryCountArgs>(
      args?: Subset<T, VaccineHistoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VaccineHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VaccineHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VaccineHistoryAggregateArgs>(args: Subset<T, VaccineHistoryAggregateArgs>): PrismaPromise<GetVaccineHistoryAggregateType<T>>

    /**
     * Group by VaccineHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VaccineHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VaccineHistoryGroupByArgs['orderBy'] }
        : { orderBy?: VaccineHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VaccineHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVaccineHistoryGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for VaccineHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VaccineHistoryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    pet<T extends UserPetsArgs = {}>(args?: Subset<T, UserPetsArgs>): CheckSelect<T, Prisma__UserPetsClient<UserPets | null >, Prisma__UserPetsClient<UserPetsGetPayload<T> | null >>;

    vaccine_type<T extends VaccineTypeArgs = {}>(args?: Subset<T, VaccineTypeArgs>): CheckSelect<T, Prisma__VaccineTypeClient<VaccineType | null >, Prisma__VaccineTypeClient<VaccineTypeGetPayload<T> | null >>;

    VaccineHistoryPhoto<T extends VaccineHistoryPhotoFindManyArgs = {}>(args?: Subset<T, VaccineHistoryPhotoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<VaccineHistoryPhoto>>, PrismaPromise<Array<VaccineHistoryPhotoGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * VaccineHistory findUnique
   */
  export type VaccineHistoryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the VaccineHistory
     * 
    **/
    select?: VaccineHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineHistoryInclude | null
    /**
     * Throw an Error if a VaccineHistory can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VaccineHistory to fetch.
     * 
    **/
    where: VaccineHistoryWhereUniqueInput
  }


  /**
   * VaccineHistory findFirst
   */
  export type VaccineHistoryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the VaccineHistory
     * 
    **/
    select?: VaccineHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineHistoryInclude | null
    /**
     * Throw an Error if a VaccineHistory can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VaccineHistory to fetch.
     * 
    **/
    where?: VaccineHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccineHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<VaccineHistoryOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VaccineHistories.
     * 
    **/
    cursor?: VaccineHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccineHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccineHistories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VaccineHistories.
     * 
    **/
    distinct?: Enumerable<VaccineHistoryScalarFieldEnum>
  }


  /**
   * VaccineHistory findMany
   */
  export type VaccineHistoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the VaccineHistory
     * 
    **/
    select?: VaccineHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineHistoryInclude | null
    /**
     * Filter, which VaccineHistories to fetch.
     * 
    **/
    where?: VaccineHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccineHistories to fetch.
     * 
    **/
    orderBy?: Enumerable<VaccineHistoryOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VaccineHistories.
     * 
    **/
    cursor?: VaccineHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccineHistories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccineHistories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VaccineHistoryScalarFieldEnum>
  }


  /**
   * VaccineHistory create
   */
  export type VaccineHistoryCreateArgs = {
    /**
     * Select specific fields to fetch from the VaccineHistory
     * 
    **/
    select?: VaccineHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineHistoryInclude | null
    /**
     * The data needed to create a VaccineHistory.
     * 
    **/
    data: XOR<VaccineHistoryCreateInput, VaccineHistoryUncheckedCreateInput>
  }


  /**
   * VaccineHistory createMany
   */
  export type VaccineHistoryCreateManyArgs = {
    data: Enumerable<VaccineHistoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VaccineHistory update
   */
  export type VaccineHistoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the VaccineHistory
     * 
    **/
    select?: VaccineHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineHistoryInclude | null
    /**
     * The data needed to update a VaccineHistory.
     * 
    **/
    data: XOR<VaccineHistoryUpdateInput, VaccineHistoryUncheckedUpdateInput>
    /**
     * Choose, which VaccineHistory to update.
     * 
    **/
    where: VaccineHistoryWhereUniqueInput
  }


  /**
   * VaccineHistory updateMany
   */
  export type VaccineHistoryUpdateManyArgs = {
    data: XOR<VaccineHistoryUpdateManyMutationInput, VaccineHistoryUncheckedUpdateManyInput>
    where?: VaccineHistoryWhereInput
  }


  /**
   * VaccineHistory upsert
   */
  export type VaccineHistoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the VaccineHistory
     * 
    **/
    select?: VaccineHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineHistoryInclude | null
    /**
     * The filter to search for the VaccineHistory to update in case it exists.
     * 
    **/
    where: VaccineHistoryWhereUniqueInput
    /**
     * In case the VaccineHistory found by the `where` argument doesn't exist, create a new VaccineHistory with this data.
     * 
    **/
    create: XOR<VaccineHistoryCreateInput, VaccineHistoryUncheckedCreateInput>
    /**
     * In case the VaccineHistory was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VaccineHistoryUpdateInput, VaccineHistoryUncheckedUpdateInput>
  }


  /**
   * VaccineHistory delete
   */
  export type VaccineHistoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the VaccineHistory
     * 
    **/
    select?: VaccineHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineHistoryInclude | null
    /**
     * Filter which VaccineHistory to delete.
     * 
    **/
    where: VaccineHistoryWhereUniqueInput
  }


  /**
   * VaccineHistory deleteMany
   */
  export type VaccineHistoryDeleteManyArgs = {
    where?: VaccineHistoryWhereInput
  }


  /**
   * VaccineHistory without action
   */
  export type VaccineHistoryArgs = {
    /**
     * Select specific fields to fetch from the VaccineHistory
     * 
    **/
    select?: VaccineHistorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineHistoryInclude | null
  }



  /**
   * Model VaccineHistoryPhoto
   */


  export type AggregateVaccineHistoryPhoto = {
    _count: VaccineHistoryPhotoCountAggregateOutputType | null
    count: VaccineHistoryPhotoCountAggregateOutputType | null
    _avg: VaccineHistoryPhotoAvgAggregateOutputType | null
    avg: VaccineHistoryPhotoAvgAggregateOutputType | null
    _sum: VaccineHistoryPhotoSumAggregateOutputType | null
    sum: VaccineHistoryPhotoSumAggregateOutputType | null
    _min: VaccineHistoryPhotoMinAggregateOutputType | null
    min: VaccineHistoryPhotoMinAggregateOutputType | null
    _max: VaccineHistoryPhotoMaxAggregateOutputType | null
    max: VaccineHistoryPhotoMaxAggregateOutputType | null
  }

  export type VaccineHistoryPhotoAvgAggregateOutputType = {
    id: number | null
    vaccine_history_id: number | null
  }

  export type VaccineHistoryPhotoSumAggregateOutputType = {
    id: number | null
    vaccine_history_id: number | null
  }

  export type VaccineHistoryPhotoMinAggregateOutputType = {
    id: number | null
    uid: string | null
    vaccine_history_id: number | null
    path: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VaccineHistoryPhotoMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    vaccine_history_id: number | null
    path: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VaccineHistoryPhotoCountAggregateOutputType = {
    id: number
    uid: number
    vaccine_history_id: number
    path: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VaccineHistoryPhotoAvgAggregateInputType = {
    id?: true
    vaccine_history_id?: true
  }

  export type VaccineHistoryPhotoSumAggregateInputType = {
    id?: true
    vaccine_history_id?: true
  }

  export type VaccineHistoryPhotoMinAggregateInputType = {
    id?: true
    uid?: true
    vaccine_history_id?: true
    path?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type VaccineHistoryPhotoMaxAggregateInputType = {
    id?: true
    uid?: true
    vaccine_history_id?: true
    path?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type VaccineHistoryPhotoCountAggregateInputType = {
    id?: true
    uid?: true
    vaccine_history_id?: true
    path?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VaccineHistoryPhotoAggregateArgs = {
    /**
     * Filter which VaccineHistoryPhoto to aggregate.
     * 
    **/
    where?: VaccineHistoryPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccineHistoryPhotos to fetch.
     * 
    **/
    orderBy?: Enumerable<VaccineHistoryPhotoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VaccineHistoryPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccineHistoryPhotos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccineHistoryPhotos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VaccineHistoryPhotos
    **/
    _count?: true | VaccineHistoryPhotoCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | VaccineHistoryPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VaccineHistoryPhotoAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: VaccineHistoryPhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VaccineHistoryPhotoSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: VaccineHistoryPhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VaccineHistoryPhotoMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: VaccineHistoryPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VaccineHistoryPhotoMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: VaccineHistoryPhotoMaxAggregateInputType
  }

  export type GetVaccineHistoryPhotoAggregateType<T extends VaccineHistoryPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateVaccineHistoryPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVaccineHistoryPhoto[P]>
      : GetScalarType<T[P], AggregateVaccineHistoryPhoto[P]>
  }


    
    
  export type VaccineHistoryPhotoGroupByArgs = {
    where?: VaccineHistoryPhotoWhereInput
    orderBy?: Enumerable<VaccineHistoryPhotoOrderByInput>
    by: Array<VaccineHistoryPhotoScalarFieldEnum>
    having?: VaccineHistoryPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VaccineHistoryPhotoCountAggregateInputType | true
    _avg?: VaccineHistoryPhotoAvgAggregateInputType
    _sum?: VaccineHistoryPhotoSumAggregateInputType
    _min?: VaccineHistoryPhotoMinAggregateInputType
    _max?: VaccineHistoryPhotoMaxAggregateInputType
  }


  export type VaccineHistoryPhotoGroupByOutputType = {
    id: number
    uid: string
    vaccine_history_id: number
    path: string
    description: string
    created_at: Date
    updated_at: Date
    _count: VaccineHistoryPhotoCountAggregateOutputType | null
    _avg: VaccineHistoryPhotoAvgAggregateOutputType | null
    _sum: VaccineHistoryPhotoSumAggregateOutputType | null
    _min: VaccineHistoryPhotoMinAggregateOutputType | null
    _max: VaccineHistoryPhotoMaxAggregateOutputType | null
  }

  type GetVaccineHistoryPhotoGroupByPayload<T extends VaccineHistoryPhotoGroupByArgs> = Promise<
    Array<
      PickArray<VaccineHistoryPhotoGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof VaccineHistoryPhotoGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], VaccineHistoryPhotoGroupByOutputType[P]> 
            : GetScalarType<T[P], VaccineHistoryPhotoGroupByOutputType[P]>
        }
      > 
    >


  export type VaccineHistoryPhotoSelect = {
    id?: boolean
    uid?: boolean
    vaccine_history?: boolean | VaccineHistoryArgs
    vaccine_history_id?: boolean
    path?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type VaccineHistoryPhotoInclude = {
    vaccine_history?: boolean | VaccineHistoryArgs
  }

  export type VaccineHistoryPhotoGetPayload<
    S extends boolean | null | undefined | VaccineHistoryPhotoArgs,
    U = keyof S
      > = S extends true
        ? VaccineHistoryPhoto
    : S extends undefined
    ? never
    : S extends VaccineHistoryPhotoArgs | VaccineHistoryPhotoFindManyArgs
    ?'include' extends U
    ? VaccineHistoryPhoto  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'vaccine_history'
        ? VaccineHistoryGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof VaccineHistoryPhoto ?VaccineHistoryPhoto [P]
  : 
          P extends 'vaccine_history'
        ? VaccineHistoryGetPayload<S['select'][P]> : never
  } 
    : VaccineHistoryPhoto
  : VaccineHistoryPhoto


  type VaccineHistoryPhotoCountArgs = Merge<
    Omit<VaccineHistoryPhotoFindManyArgs, 'select' | 'include'> & {
      select?: VaccineHistoryPhotoCountAggregateInputType | true
    }
  >

  export interface VaccineHistoryPhotoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one VaccineHistoryPhoto that matches the filter.
     * @param {VaccineHistoryPhotoFindUniqueArgs} args - Arguments to find a VaccineHistoryPhoto
     * @example
     * // Get one VaccineHistoryPhoto
     * const vaccineHistoryPhoto = await prisma.vaccineHistoryPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VaccineHistoryPhotoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VaccineHistoryPhotoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VaccineHistoryPhoto'> extends True ? CheckSelect<T, Prisma__VaccineHistoryPhotoClient<VaccineHistoryPhoto>, Prisma__VaccineHistoryPhotoClient<VaccineHistoryPhotoGetPayload<T>>> : CheckSelect<T, Prisma__VaccineHistoryPhotoClient<VaccineHistoryPhoto | null >, Prisma__VaccineHistoryPhotoClient<VaccineHistoryPhotoGetPayload<T> | null >>

    /**
     * Find the first VaccineHistoryPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineHistoryPhotoFindFirstArgs} args - Arguments to find a VaccineHistoryPhoto
     * @example
     * // Get one VaccineHistoryPhoto
     * const vaccineHistoryPhoto = await prisma.vaccineHistoryPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VaccineHistoryPhotoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VaccineHistoryPhotoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VaccineHistoryPhoto'> extends True ? CheckSelect<T, Prisma__VaccineHistoryPhotoClient<VaccineHistoryPhoto>, Prisma__VaccineHistoryPhotoClient<VaccineHistoryPhotoGetPayload<T>>> : CheckSelect<T, Prisma__VaccineHistoryPhotoClient<VaccineHistoryPhoto | null >, Prisma__VaccineHistoryPhotoClient<VaccineHistoryPhotoGetPayload<T> | null >>

    /**
     * Find zero or more VaccineHistoryPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineHistoryPhotoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VaccineHistoryPhotos
     * const vaccineHistoryPhotos = await prisma.vaccineHistoryPhoto.findMany()
     * 
     * // Get first 10 VaccineHistoryPhotos
     * const vaccineHistoryPhotos = await prisma.vaccineHistoryPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vaccineHistoryPhotoWithIdOnly = await prisma.vaccineHistoryPhoto.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VaccineHistoryPhotoFindManyArgs>(
      args?: SelectSubset<T, VaccineHistoryPhotoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<VaccineHistoryPhoto>>, PrismaPromise<Array<VaccineHistoryPhotoGetPayload<T>>>>

    /**
     * Create a VaccineHistoryPhoto.
     * @param {VaccineHistoryPhotoCreateArgs} args - Arguments to create a VaccineHistoryPhoto.
     * @example
     * // Create one VaccineHistoryPhoto
     * const VaccineHistoryPhoto = await prisma.vaccineHistoryPhoto.create({
     *   data: {
     *     // ... data to create a VaccineHistoryPhoto
     *   }
     * })
     * 
    **/
    create<T extends VaccineHistoryPhotoCreateArgs>(
      args: SelectSubset<T, VaccineHistoryPhotoCreateArgs>
    ): CheckSelect<T, Prisma__VaccineHistoryPhotoClient<VaccineHistoryPhoto>, Prisma__VaccineHistoryPhotoClient<VaccineHistoryPhotoGetPayload<T>>>

    /**
     * Create many VaccineHistoryPhotos.
     *     @param {VaccineHistoryPhotoCreateManyArgs} args - Arguments to create many VaccineHistoryPhotos.
     *     @example
     *     // Create many VaccineHistoryPhotos
     *     const vaccineHistoryPhoto = await prisma.vaccineHistoryPhoto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VaccineHistoryPhotoCreateManyArgs>(
      args?: SelectSubset<T, VaccineHistoryPhotoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VaccineHistoryPhoto.
     * @param {VaccineHistoryPhotoDeleteArgs} args - Arguments to delete one VaccineHistoryPhoto.
     * @example
     * // Delete one VaccineHistoryPhoto
     * const VaccineHistoryPhoto = await prisma.vaccineHistoryPhoto.delete({
     *   where: {
     *     // ... filter to delete one VaccineHistoryPhoto
     *   }
     * })
     * 
    **/
    delete<T extends VaccineHistoryPhotoDeleteArgs>(
      args: SelectSubset<T, VaccineHistoryPhotoDeleteArgs>
    ): CheckSelect<T, Prisma__VaccineHistoryPhotoClient<VaccineHistoryPhoto>, Prisma__VaccineHistoryPhotoClient<VaccineHistoryPhotoGetPayload<T>>>

    /**
     * Update one VaccineHistoryPhoto.
     * @param {VaccineHistoryPhotoUpdateArgs} args - Arguments to update one VaccineHistoryPhoto.
     * @example
     * // Update one VaccineHistoryPhoto
     * const vaccineHistoryPhoto = await prisma.vaccineHistoryPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VaccineHistoryPhotoUpdateArgs>(
      args: SelectSubset<T, VaccineHistoryPhotoUpdateArgs>
    ): CheckSelect<T, Prisma__VaccineHistoryPhotoClient<VaccineHistoryPhoto>, Prisma__VaccineHistoryPhotoClient<VaccineHistoryPhotoGetPayload<T>>>

    /**
     * Delete zero or more VaccineHistoryPhotos.
     * @param {VaccineHistoryPhotoDeleteManyArgs} args - Arguments to filter VaccineHistoryPhotos to delete.
     * @example
     * // Delete a few VaccineHistoryPhotos
     * const { count } = await prisma.vaccineHistoryPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VaccineHistoryPhotoDeleteManyArgs>(
      args?: SelectSubset<T, VaccineHistoryPhotoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VaccineHistoryPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineHistoryPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VaccineHistoryPhotos
     * const vaccineHistoryPhoto = await prisma.vaccineHistoryPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VaccineHistoryPhotoUpdateManyArgs>(
      args: SelectSubset<T, VaccineHistoryPhotoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VaccineHistoryPhoto.
     * @param {VaccineHistoryPhotoUpsertArgs} args - Arguments to update or create a VaccineHistoryPhoto.
     * @example
     * // Update or create a VaccineHistoryPhoto
     * const vaccineHistoryPhoto = await prisma.vaccineHistoryPhoto.upsert({
     *   create: {
     *     // ... data to create a VaccineHistoryPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VaccineHistoryPhoto we want to update
     *   }
     * })
    **/
    upsert<T extends VaccineHistoryPhotoUpsertArgs>(
      args: SelectSubset<T, VaccineHistoryPhotoUpsertArgs>
    ): CheckSelect<T, Prisma__VaccineHistoryPhotoClient<VaccineHistoryPhoto>, Prisma__VaccineHistoryPhotoClient<VaccineHistoryPhotoGetPayload<T>>>

    /**
     * Count the number of VaccineHistoryPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineHistoryPhotoCountArgs} args - Arguments to filter VaccineHistoryPhotos to count.
     * @example
     * // Count the number of VaccineHistoryPhotos
     * const count = await prisma.vaccineHistoryPhoto.count({
     *   where: {
     *     // ... the filter for the VaccineHistoryPhotos we want to count
     *   }
     * })
    **/
    count<T extends VaccineHistoryPhotoCountArgs>(
      args?: Subset<T, VaccineHistoryPhotoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VaccineHistoryPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VaccineHistoryPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineHistoryPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VaccineHistoryPhotoAggregateArgs>(args: Subset<T, VaccineHistoryPhotoAggregateArgs>): PrismaPromise<GetVaccineHistoryPhotoAggregateType<T>>

    /**
     * Group by VaccineHistoryPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineHistoryPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VaccineHistoryPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VaccineHistoryPhotoGroupByArgs['orderBy'] }
        : { orderBy?: VaccineHistoryPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VaccineHistoryPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVaccineHistoryPhotoGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for VaccineHistoryPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VaccineHistoryPhotoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    vaccine_history<T extends VaccineHistoryArgs = {}>(args?: Subset<T, VaccineHistoryArgs>): CheckSelect<T, Prisma__VaccineHistoryClient<VaccineHistory | null >, Prisma__VaccineHistoryClient<VaccineHistoryGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * VaccineHistoryPhoto findUnique
   */
  export type VaccineHistoryPhotoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the VaccineHistoryPhoto
     * 
    **/
    select?: VaccineHistoryPhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineHistoryPhotoInclude | null
    /**
     * Throw an Error if a VaccineHistoryPhoto can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VaccineHistoryPhoto to fetch.
     * 
    **/
    where: VaccineHistoryPhotoWhereUniqueInput
  }


  /**
   * VaccineHistoryPhoto findFirst
   */
  export type VaccineHistoryPhotoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the VaccineHistoryPhoto
     * 
    **/
    select?: VaccineHistoryPhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineHistoryPhotoInclude | null
    /**
     * Throw an Error if a VaccineHistoryPhoto can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VaccineHistoryPhoto to fetch.
     * 
    **/
    where?: VaccineHistoryPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccineHistoryPhotos to fetch.
     * 
    **/
    orderBy?: Enumerable<VaccineHistoryPhotoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VaccineHistoryPhotos.
     * 
    **/
    cursor?: VaccineHistoryPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccineHistoryPhotos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccineHistoryPhotos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VaccineHistoryPhotos.
     * 
    **/
    distinct?: Enumerable<VaccineHistoryPhotoScalarFieldEnum>
  }


  /**
   * VaccineHistoryPhoto findMany
   */
  export type VaccineHistoryPhotoFindManyArgs = {
    /**
     * Select specific fields to fetch from the VaccineHistoryPhoto
     * 
    **/
    select?: VaccineHistoryPhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineHistoryPhotoInclude | null
    /**
     * Filter, which VaccineHistoryPhotos to fetch.
     * 
    **/
    where?: VaccineHistoryPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccineHistoryPhotos to fetch.
     * 
    **/
    orderBy?: Enumerable<VaccineHistoryPhotoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VaccineHistoryPhotos.
     * 
    **/
    cursor?: VaccineHistoryPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccineHistoryPhotos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccineHistoryPhotos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VaccineHistoryPhotoScalarFieldEnum>
  }


  /**
   * VaccineHistoryPhoto create
   */
  export type VaccineHistoryPhotoCreateArgs = {
    /**
     * Select specific fields to fetch from the VaccineHistoryPhoto
     * 
    **/
    select?: VaccineHistoryPhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineHistoryPhotoInclude | null
    /**
     * The data needed to create a VaccineHistoryPhoto.
     * 
    **/
    data: XOR<VaccineHistoryPhotoCreateInput, VaccineHistoryPhotoUncheckedCreateInput>
  }


  /**
   * VaccineHistoryPhoto createMany
   */
  export type VaccineHistoryPhotoCreateManyArgs = {
    data: Enumerable<VaccineHistoryPhotoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VaccineHistoryPhoto update
   */
  export type VaccineHistoryPhotoUpdateArgs = {
    /**
     * Select specific fields to fetch from the VaccineHistoryPhoto
     * 
    **/
    select?: VaccineHistoryPhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineHistoryPhotoInclude | null
    /**
     * The data needed to update a VaccineHistoryPhoto.
     * 
    **/
    data: XOR<VaccineHistoryPhotoUpdateInput, VaccineHistoryPhotoUncheckedUpdateInput>
    /**
     * Choose, which VaccineHistoryPhoto to update.
     * 
    **/
    where: VaccineHistoryPhotoWhereUniqueInput
  }


  /**
   * VaccineHistoryPhoto updateMany
   */
  export type VaccineHistoryPhotoUpdateManyArgs = {
    data: XOR<VaccineHistoryPhotoUpdateManyMutationInput, VaccineHistoryPhotoUncheckedUpdateManyInput>
    where?: VaccineHistoryPhotoWhereInput
  }


  /**
   * VaccineHistoryPhoto upsert
   */
  export type VaccineHistoryPhotoUpsertArgs = {
    /**
     * Select specific fields to fetch from the VaccineHistoryPhoto
     * 
    **/
    select?: VaccineHistoryPhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineHistoryPhotoInclude | null
    /**
     * The filter to search for the VaccineHistoryPhoto to update in case it exists.
     * 
    **/
    where: VaccineHistoryPhotoWhereUniqueInput
    /**
     * In case the VaccineHistoryPhoto found by the `where` argument doesn't exist, create a new VaccineHistoryPhoto with this data.
     * 
    **/
    create: XOR<VaccineHistoryPhotoCreateInput, VaccineHistoryPhotoUncheckedCreateInput>
    /**
     * In case the VaccineHistoryPhoto was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VaccineHistoryPhotoUpdateInput, VaccineHistoryPhotoUncheckedUpdateInput>
  }


  /**
   * VaccineHistoryPhoto delete
   */
  export type VaccineHistoryPhotoDeleteArgs = {
    /**
     * Select specific fields to fetch from the VaccineHistoryPhoto
     * 
    **/
    select?: VaccineHistoryPhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineHistoryPhotoInclude | null
    /**
     * Filter which VaccineHistoryPhoto to delete.
     * 
    **/
    where: VaccineHistoryPhotoWhereUniqueInput
  }


  /**
   * VaccineHistoryPhoto deleteMany
   */
  export type VaccineHistoryPhotoDeleteManyArgs = {
    where?: VaccineHistoryPhotoWhereInput
  }


  /**
   * VaccineHistoryPhoto without action
   */
  export type VaccineHistoryPhotoArgs = {
    /**
     * Select specific fields to fetch from the VaccineHistoryPhoto
     * 
    **/
    select?: VaccineHistoryPhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VaccineHistoryPhotoInclude | null
  }



  /**
   * Model Vendors
   */


  export type AggregateVendors = {
    _count: VendorsCountAggregateOutputType | null
    count: VendorsCountAggregateOutputType | null
    _avg: VendorsAvgAggregateOutputType | null
    avg: VendorsAvgAggregateOutputType | null
    _sum: VendorsSumAggregateOutputType | null
    sum: VendorsSumAggregateOutputType | null
    _min: VendorsMinAggregateOutputType | null
    min: VendorsMinAggregateOutputType | null
    _max: VendorsMaxAggregateOutputType | null
    max: VendorsMaxAggregateOutputType | null
  }

  export type VendorsAvgAggregateOutputType = {
    id: number | null
    price: number | null
    total_patient: number | null
    rating: number | null
    city_id: number | null
    province_id: number | null
    duration: number | null
    rest: number | null
    total_poli: number | null
  }

  export type VendorsSumAggregateOutputType = {
    id: number | null
    price: number | null
    total_patient: number | null
    rating: number | null
    city_id: number | null
    province_id: number | null
    duration: number | null
    rest: number | null
    total_poli: number | null
  }

  export type VendorsMinAggregateOutputType = {
    id: number | null
    uid: string | null
    email: string | null
    is_verified: boolean | null
    vendor_role: Type | null
    price: number | null
    total_patient: number | null
    rating: number | null
    name: string | null
    username: string | null
    address: string | null
    phone_number: string | null
    profile_picture_url: string | null
    gender: Gender | null
    speciality: string | null
    birthdate: string | null
    google_maps_url: string | null
    str_number: string | null
    str_issued_date: string | null
    alumni: string | null
    city_id: number | null
    province_id: number | null
    lat: string | null
    long: string | null
    days: string | null
    ops_start_time: string | null
    ops_end_time: string | null
    duration: number | null
    rest: number | null
    total_poli: number | null
    image_url: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorsMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    email: string | null
    is_verified: boolean | null
    vendor_role: Type | null
    price: number | null
    total_patient: number | null
    rating: number | null
    name: string | null
    username: string | null
    address: string | null
    phone_number: string | null
    profile_picture_url: string | null
    gender: Gender | null
    speciality: string | null
    birthdate: string | null
    google_maps_url: string | null
    str_number: string | null
    str_issued_date: string | null
    alumni: string | null
    city_id: number | null
    province_id: number | null
    lat: string | null
    long: string | null
    days: string | null
    ops_start_time: string | null
    ops_end_time: string | null
    duration: number | null
    rest: number | null
    total_poli: number | null
    image_url: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorsCountAggregateOutputType = {
    id: number
    uid: number
    email: number
    is_verified: number
    vendor_role: number
    price: number
    total_patient: number
    rating: number
    name: number
    username: number
    address: number
    phone_number: number
    profile_picture_url: number
    gender: number
    speciality: number
    birthdate: number
    google_maps_url: number
    str_number: number
    str_issued_date: number
    alumni: number
    city_id: number
    province_id: number
    lat: number
    long: number
    days: number
    ops_start_time: number
    ops_end_time: number
    duration: number
    rest: number
    total_poli: number
    image_url: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VendorsAvgAggregateInputType = {
    id?: true
    price?: true
    total_patient?: true
    rating?: true
    city_id?: true
    province_id?: true
    duration?: true
    rest?: true
    total_poli?: true
  }

  export type VendorsSumAggregateInputType = {
    id?: true
    price?: true
    total_patient?: true
    rating?: true
    city_id?: true
    province_id?: true
    duration?: true
    rest?: true
    total_poli?: true
  }

  export type VendorsMinAggregateInputType = {
    id?: true
    uid?: true
    email?: true
    is_verified?: true
    vendor_role?: true
    price?: true
    total_patient?: true
    rating?: true
    name?: true
    username?: true
    address?: true
    phone_number?: true
    profile_picture_url?: true
    gender?: true
    speciality?: true
    birthdate?: true
    google_maps_url?: true
    str_number?: true
    str_issued_date?: true
    alumni?: true
    city_id?: true
    province_id?: true
    lat?: true
    long?: true
    days?: true
    ops_start_time?: true
    ops_end_time?: true
    duration?: true
    rest?: true
    total_poli?: true
    image_url?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorsMaxAggregateInputType = {
    id?: true
    uid?: true
    email?: true
    is_verified?: true
    vendor_role?: true
    price?: true
    total_patient?: true
    rating?: true
    name?: true
    username?: true
    address?: true
    phone_number?: true
    profile_picture_url?: true
    gender?: true
    speciality?: true
    birthdate?: true
    google_maps_url?: true
    str_number?: true
    str_issued_date?: true
    alumni?: true
    city_id?: true
    province_id?: true
    lat?: true
    long?: true
    days?: true
    ops_start_time?: true
    ops_end_time?: true
    duration?: true
    rest?: true
    total_poli?: true
    image_url?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorsCountAggregateInputType = {
    id?: true
    uid?: true
    email?: true
    is_verified?: true
    vendor_role?: true
    price?: true
    total_patient?: true
    rating?: true
    name?: true
    username?: true
    address?: true
    phone_number?: true
    profile_picture_url?: true
    gender?: true
    speciality?: true
    birthdate?: true
    google_maps_url?: true
    str_number?: true
    str_issued_date?: true
    alumni?: true
    city_id?: true
    province_id?: true
    lat?: true
    long?: true
    days?: true
    ops_start_time?: true
    ops_end_time?: true
    duration?: true
    rest?: true
    total_poli?: true
    image_url?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VendorsAggregateArgs = {
    /**
     * Filter which Vendors to aggregate.
     * 
    **/
    where?: VendorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     * 
    **/
    orderBy?: Enumerable<VendorsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VendorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorsCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | VendorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorsAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: VendorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorsSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: VendorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorsMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: VendorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorsMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: VendorsMaxAggregateInputType
  }

  export type GetVendorsAggregateType<T extends VendorsAggregateArgs> = {
        [P in keyof T & keyof AggregateVendors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendors[P]>
      : GetScalarType<T[P], AggregateVendors[P]>
  }


    
    
  export type VendorsGroupByArgs = {
    where?: VendorsWhereInput
    orderBy?: Enumerable<VendorsOrderByInput>
    by: Array<VendorsScalarFieldEnum>
    having?: VendorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorsCountAggregateInputType | true
    _avg?: VendorsAvgAggregateInputType
    _sum?: VendorsSumAggregateInputType
    _min?: VendorsMinAggregateInputType
    _max?: VendorsMaxAggregateInputType
  }


  export type VendorsGroupByOutputType = {
    id: number
    uid: string
    email: string
    is_verified: boolean
    vendor_role: Type | null
    price: number
    total_patient: number | null
    rating: number | null
    name: string
    username: string
    address: string
    phone_number: string
    profile_picture_url: string
    gender: Gender | null
    speciality: string
    birthdate: string
    google_maps_url: string
    str_number: string
    str_issued_date: string
    alumni: string
    city_id: number
    province_id: number
    lat: string
    long: string
    days: string
    ops_start_time: string
    ops_end_time: string
    duration: number
    rest: number
    total_poli: number
    image_url: string
    created_at: Date
    updated_at: Date
    _count: VendorsCountAggregateOutputType | null
    _avg: VendorsAvgAggregateOutputType | null
    _sum: VendorsSumAggregateOutputType | null
    _min: VendorsMinAggregateOutputType | null
    _max: VendorsMaxAggregateOutputType | null
  }

  type GetVendorsGroupByPayload<T extends VendorsGroupByArgs> = Promise<
    Array<
      PickArray<VendorsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof VendorsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], VendorsGroupByOutputType[P]> 
            : GetScalarType<T[P], VendorsGroupByOutputType[P]>
        }
      > 
    >


  export type VendorsSelect = {
    id?: boolean
    uid?: boolean
    email?: boolean
    is_verified?: boolean
    vendor_role?: boolean
    price?: boolean
    total_patient?: boolean
    rating?: boolean
    name?: boolean
    username?: boolean
    address?: boolean
    phone_number?: boolean
    profile_picture_url?: boolean
    gender?: boolean
    speciality?: boolean
    birthdate?: boolean
    google_maps_url?: boolean
    str_number?: boolean
    str_issued_date?: boolean
    alumni?: boolean
    city_id?: boolean
    province_id?: boolean
    lat?: boolean
    long?: boolean
    days?: boolean
    ops_start_time?: boolean
    ops_end_time?: boolean
    duration?: boolean
    rest?: boolean
    total_poli?: boolean
    image_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    vendor_documents?: boolean | Vendor_DocumentsFindManyArgs
    vendor_medtreats?: boolean | Vendor_MedtreatsFindManyArgs
    Feedbacks?: boolean | FeedbacksFindManyArgs
  }

  export type VendorsInclude = {
    vendor_documents?: boolean | Vendor_DocumentsFindManyArgs
    vendor_medtreats?: boolean | Vendor_MedtreatsFindManyArgs
    Feedbacks?: boolean | FeedbacksFindManyArgs
  }

  export type VendorsGetPayload<
    S extends boolean | null | undefined | VendorsArgs,
    U = keyof S
      > = S extends true
        ? Vendors
    : S extends undefined
    ? never
    : S extends VendorsArgs | VendorsFindManyArgs
    ?'include' extends U
    ? Vendors  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'vendor_documents'
        ? Array < Vendor_DocumentsGetPayload<S['include'][P]>>  :
        P extends 'vendor_medtreats'
        ? Array < Vendor_MedtreatsGetPayload<S['include'][P]>>  :
        P extends 'Feedbacks'
        ? Array < FeedbacksGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Vendors ?Vendors [P]
  : 
          P extends 'vendor_documents'
        ? Array < Vendor_DocumentsGetPayload<S['select'][P]>>  :
        P extends 'vendor_medtreats'
        ? Array < Vendor_MedtreatsGetPayload<S['select'][P]>>  :
        P extends 'Feedbacks'
        ? Array < FeedbacksGetPayload<S['select'][P]>>  : never
  } 
    : Vendors
  : Vendors


  type VendorsCountArgs = Merge<
    Omit<VendorsFindManyArgs, 'select' | 'include'> & {
      select?: VendorsCountAggregateInputType | true
    }
  >

  export interface VendorsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Vendors that matches the filter.
     * @param {VendorsFindUniqueArgs} args - Arguments to find a Vendors
     * @example
     * // Get one Vendors
     * const vendors = await prisma.vendors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VendorsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VendorsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Vendors'> extends True ? CheckSelect<T, Prisma__VendorsClient<Vendors>, Prisma__VendorsClient<VendorsGetPayload<T>>> : CheckSelect<T, Prisma__VendorsClient<Vendors | null >, Prisma__VendorsClient<VendorsGetPayload<T> | null >>

    /**
     * Find the first Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorsFindFirstArgs} args - Arguments to find a Vendors
     * @example
     * // Get one Vendors
     * const vendors = await prisma.vendors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VendorsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VendorsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Vendors'> extends True ? CheckSelect<T, Prisma__VendorsClient<Vendors>, Prisma__VendorsClient<VendorsGetPayload<T>>> : CheckSelect<T, Prisma__VendorsClient<Vendors | null >, Prisma__VendorsClient<VendorsGetPayload<T> | null >>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendors.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorsWithIdOnly = await prisma.vendors.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VendorsFindManyArgs>(
      args?: SelectSubset<T, VendorsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Vendors>>, PrismaPromise<Array<VendorsGetPayload<T>>>>

    /**
     * Create a Vendors.
     * @param {VendorsCreateArgs} args - Arguments to create a Vendors.
     * @example
     * // Create one Vendors
     * const Vendors = await prisma.vendors.create({
     *   data: {
     *     // ... data to create a Vendors
     *   }
     * })
     * 
    **/
    create<T extends VendorsCreateArgs>(
      args: SelectSubset<T, VendorsCreateArgs>
    ): CheckSelect<T, Prisma__VendorsClient<Vendors>, Prisma__VendorsClient<VendorsGetPayload<T>>>

    /**
     * Create many Vendors.
     *     @param {VendorsCreateManyArgs} args - Arguments to create many Vendors.
     *     @example
     *     // Create many Vendors
     *     const vendors = await prisma.vendors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VendorsCreateManyArgs>(
      args?: SelectSubset<T, VendorsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Vendors.
     * @param {VendorsDeleteArgs} args - Arguments to delete one Vendors.
     * @example
     * // Delete one Vendors
     * const Vendors = await prisma.vendors.delete({
     *   where: {
     *     // ... filter to delete one Vendors
     *   }
     * })
     * 
    **/
    delete<T extends VendorsDeleteArgs>(
      args: SelectSubset<T, VendorsDeleteArgs>
    ): CheckSelect<T, Prisma__VendorsClient<Vendors>, Prisma__VendorsClient<VendorsGetPayload<T>>>

    /**
     * Update one Vendors.
     * @param {VendorsUpdateArgs} args - Arguments to update one Vendors.
     * @example
     * // Update one Vendors
     * const vendors = await prisma.vendors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VendorsUpdateArgs>(
      args: SelectSubset<T, VendorsUpdateArgs>
    ): CheckSelect<T, Prisma__VendorsClient<Vendors>, Prisma__VendorsClient<VendorsGetPayload<T>>>

    /**
     * Delete zero or more Vendors.
     * @param {VendorsDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VendorsDeleteManyArgs>(
      args?: SelectSubset<T, VendorsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendors = await prisma.vendors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VendorsUpdateManyArgs>(
      args: SelectSubset<T, VendorsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendors.
     * @param {VendorsUpsertArgs} args - Arguments to update or create a Vendors.
     * @example
     * // Update or create a Vendors
     * const vendors = await prisma.vendors.upsert({
     *   create: {
     *     // ... data to create a Vendors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendors we want to update
     *   }
     * })
    **/
    upsert<T extends VendorsUpsertArgs>(
      args: SelectSubset<T, VendorsUpsertArgs>
    ): CheckSelect<T, Prisma__VendorsClient<Vendors>, Prisma__VendorsClient<VendorsGetPayload<T>>>

    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorsCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendors.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorsCountArgs>(
      args?: Subset<T, VendorsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorsAggregateArgs>(args: Subset<T, VendorsAggregateArgs>): PrismaPromise<GetVendorsAggregateType<T>>

    /**
     * Group by Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorsGroupByArgs['orderBy'] }
        : { orderBy?: VendorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VendorsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    vendor_documents<T extends Vendor_DocumentsFindManyArgs = {}>(args?: Subset<T, Vendor_DocumentsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Vendor_Documents>>, PrismaPromise<Array<Vendor_DocumentsGetPayload<T>>>>;

    vendor_medtreats<T extends Vendor_MedtreatsFindManyArgs = {}>(args?: Subset<T, Vendor_MedtreatsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Vendor_Medtreats>>, PrismaPromise<Array<Vendor_MedtreatsGetPayload<T>>>>;

    Feedbacks<T extends FeedbacksFindManyArgs = {}>(args?: Subset<T, FeedbacksFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Feedbacks>>, PrismaPromise<Array<FeedbacksGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Vendors findUnique
   */
  export type VendorsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Vendors
     * 
    **/
    select?: VendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorsInclude | null
    /**
     * Throw an Error if a Vendors can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Vendors to fetch.
     * 
    **/
    where: VendorsWhereUniqueInput
  }


  /**
   * Vendors findFirst
   */
  export type VendorsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Vendors
     * 
    **/
    select?: VendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorsInclude | null
    /**
     * Throw an Error if a Vendors can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Vendors to fetch.
     * 
    **/
    where?: VendorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     * 
    **/
    orderBy?: Enumerable<VendorsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     * 
    **/
    cursor?: VendorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     * 
    **/
    distinct?: Enumerable<VendorsScalarFieldEnum>
  }


  /**
   * Vendors findMany
   */
  export type VendorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Vendors
     * 
    **/
    select?: VendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorsInclude | null
    /**
     * Filter, which Vendors to fetch.
     * 
    **/
    where?: VendorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     * 
    **/
    orderBy?: Enumerable<VendorsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     * 
    **/
    cursor?: VendorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VendorsScalarFieldEnum>
  }


  /**
   * Vendors create
   */
  export type VendorsCreateArgs = {
    /**
     * Select specific fields to fetch from the Vendors
     * 
    **/
    select?: VendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorsInclude | null
    /**
     * The data needed to create a Vendors.
     * 
    **/
    data: XOR<VendorsCreateInput, VendorsUncheckedCreateInput>
  }


  /**
   * Vendors createMany
   */
  export type VendorsCreateManyArgs = {
    data: Enumerable<VendorsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Vendors update
   */
  export type VendorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Vendors
     * 
    **/
    select?: VendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorsInclude | null
    /**
     * The data needed to update a Vendors.
     * 
    **/
    data: XOR<VendorsUpdateInput, VendorsUncheckedUpdateInput>
    /**
     * Choose, which Vendors to update.
     * 
    **/
    where: VendorsWhereUniqueInput
  }


  /**
   * Vendors updateMany
   */
  export type VendorsUpdateManyArgs = {
    data: XOR<VendorsUpdateManyMutationInput, VendorsUncheckedUpdateManyInput>
    where?: VendorsWhereInput
  }


  /**
   * Vendors upsert
   */
  export type VendorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Vendors
     * 
    **/
    select?: VendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorsInclude | null
    /**
     * The filter to search for the Vendors to update in case it exists.
     * 
    **/
    where: VendorsWhereUniqueInput
    /**
     * In case the Vendors found by the `where` argument doesn't exist, create a new Vendors with this data.
     * 
    **/
    create: XOR<VendorsCreateInput, VendorsUncheckedCreateInput>
    /**
     * In case the Vendors was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VendorsUpdateInput, VendorsUncheckedUpdateInput>
  }


  /**
   * Vendors delete
   */
  export type VendorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Vendors
     * 
    **/
    select?: VendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorsInclude | null
    /**
     * Filter which Vendors to delete.
     * 
    **/
    where: VendorsWhereUniqueInput
  }


  /**
   * Vendors deleteMany
   */
  export type VendorsDeleteManyArgs = {
    where?: VendorsWhereInput
  }


  /**
   * Vendors without action
   */
  export type VendorsArgs = {
    /**
     * Select specific fields to fetch from the Vendors
     * 
    **/
    select?: VendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VendorsInclude | null
  }



  /**
   * Model Schedule
   */


  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
    max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleAvgAggregateOutputType = {
    id: number | null
    homecare_customer_limit: number | null
    price: number | null
  }

  export type ScheduleSumAggregateOutputType = {
    id: number | null
    homecare_customer_limit: number | null
    price: number | null
  }

  export type ScheduleMinAggregateOutputType = {
    id: number | null
    uid: string | null
    time_start: string | null
    time_end: string | null
    day_start: string | null
    day_end: string | null
    homecare_customer_limit: number | null
    price: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ScheduleMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    time_start: string | null
    time_end: string | null
    day_start: string | null
    day_end: string | null
    homecare_customer_limit: number | null
    price: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ScheduleCountAggregateOutputType = {
    id: number
    uid: number
    time_start: number
    time_end: number
    day_start: number
    day_end: number
    homecare_customer_limit: number
    price: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ScheduleAvgAggregateInputType = {
    id?: true
    homecare_customer_limit?: true
    price?: true
  }

  export type ScheduleSumAggregateInputType = {
    id?: true
    homecare_customer_limit?: true
    price?: true
  }

  export type ScheduleMinAggregateInputType = {
    id?: true
    uid?: true
    time_start?: true
    time_end?: true
    day_start?: true
    day_end?: true
    homecare_customer_limit?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type ScheduleMaxAggregateInputType = {
    id?: true
    uid?: true
    time_start?: true
    time_end?: true
    day_start?: true
    day_end?: true
    homecare_customer_limit?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type ScheduleCountAggregateInputType = {
    id?: true
    uid?: true
    time_start?: true
    time_end?: true
    day_start?: true
    day_end?: true
    homecare_customer_limit?: true
    price?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ScheduleAggregateArgs = {
    /**
     * Filter which Schedule to aggregate.
     * 
    **/
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     * 
    **/
    orderBy?: Enumerable<ScheduleOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }


    
    
  export type ScheduleGroupByArgs = {
    where?: ScheduleWhereInput
    orderBy?: Enumerable<ScheduleOrderByInput>
    by: Array<ScheduleScalarFieldEnum>
    having?: ScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _avg?: ScheduleAvgAggregateInputType
    _sum?: ScheduleSumAggregateInputType
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }


  export type ScheduleGroupByOutputType = {
    id: number
    uid: string
    time_start: string
    time_end: string
    day_start: string
    day_end: string
    homecare_customer_limit: number
    price: number
    created_at: Date
    updated_at: Date
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Promise<
    Array<
      PickArray<ScheduleGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]> 
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      > 
    >


  export type ScheduleSelect = {
    id?: boolean
    uid?: boolean
    time_start?: boolean
    time_end?: boolean
    day_start?: boolean
    day_end?: boolean
    homecare_customer_limit?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ScheduleGetPayload<
    S extends boolean | null | undefined | ScheduleArgs,
    U = keyof S
      > = S extends true
        ? Schedule
    : S extends undefined
    ? never
    : S extends ScheduleArgs | ScheduleFindManyArgs
    ?'include' extends U
    ? Schedule 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Schedule ?Schedule [P]
  : 
     never
  } 
    : Schedule
  : Schedule


  type ScheduleCountArgs = Merge<
    Omit<ScheduleFindManyArgs, 'select' | 'include'> & {
      select?: ScheduleCountAggregateInputType | true
    }
  >

  export interface ScheduleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ScheduleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ScheduleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Schedule'> extends True ? CheckSelect<T, Prisma__ScheduleClient<Schedule>, Prisma__ScheduleClient<ScheduleGetPayload<T>>> : CheckSelect<T, Prisma__ScheduleClient<Schedule | null >, Prisma__ScheduleClient<ScheduleGetPayload<T> | null >>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ScheduleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ScheduleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Schedule'> extends True ? CheckSelect<T, Prisma__ScheduleClient<Schedule>, Prisma__ScheduleClient<ScheduleGetPayload<T>>> : CheckSelect<T, Prisma__ScheduleClient<Schedule | null >, Prisma__ScheduleClient<ScheduleGetPayload<T> | null >>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ScheduleFindManyArgs>(
      args?: SelectSubset<T, ScheduleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Schedule>>, PrismaPromise<Array<ScheduleGetPayload<T>>>>

    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
    **/
    create<T extends ScheduleCreateArgs>(
      args: SelectSubset<T, ScheduleCreateArgs>
    ): CheckSelect<T, Prisma__ScheduleClient<Schedule>, Prisma__ScheduleClient<ScheduleGetPayload<T>>>

    /**
     * Create many Schedules.
     *     @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     *     @example
     *     // Create many Schedules
     *     const schedule = await prisma.schedule.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ScheduleCreateManyArgs>(
      args?: SelectSubset<T, ScheduleCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
    **/
    delete<T extends ScheduleDeleteArgs>(
      args: SelectSubset<T, ScheduleDeleteArgs>
    ): CheckSelect<T, Prisma__ScheduleClient<Schedule>, Prisma__ScheduleClient<ScheduleGetPayload<T>>>

    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ScheduleUpdateArgs>(
      args: SelectSubset<T, ScheduleUpdateArgs>
    ): CheckSelect<T, Prisma__ScheduleClient<Schedule>, Prisma__ScheduleClient<ScheduleGetPayload<T>>>

    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ScheduleDeleteManyArgs>(
      args?: SelectSubset<T, ScheduleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ScheduleUpdateManyArgs>(
      args: SelectSubset<T, ScheduleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
    **/
    upsert<T extends ScheduleUpsertArgs>(
      args: SelectSubset<T, ScheduleUpsertArgs>
    ): CheckSelect<T, Prisma__ScheduleClient<Schedule>, Prisma__ScheduleClient<ScheduleGetPayload<T>>>

    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(
      args?: Subset<T, ScheduleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ScheduleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Schedule findUnique
   */
  export type ScheduleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Schedule
     * 
    **/
    select?: ScheduleSelect | null
    /**
     * Throw an Error if a Schedule can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Schedule to fetch.
     * 
    **/
    where: ScheduleWhereUniqueInput
  }


  /**
   * Schedule findFirst
   */
  export type ScheduleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Schedule
     * 
    **/
    select?: ScheduleSelect | null
    /**
     * Throw an Error if a Schedule can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Schedule to fetch.
     * 
    **/
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     * 
    **/
    orderBy?: Enumerable<ScheduleOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     * 
    **/
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     * 
    **/
    distinct?: Enumerable<ScheduleScalarFieldEnum>
  }


  /**
   * Schedule findMany
   */
  export type ScheduleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Schedule
     * 
    **/
    select?: ScheduleSelect | null
    /**
     * Filter, which Schedules to fetch.
     * 
    **/
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     * 
    **/
    orderBy?: Enumerable<ScheduleOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     * 
    **/
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ScheduleScalarFieldEnum>
  }


  /**
   * Schedule create
   */
  export type ScheduleCreateArgs = {
    /**
     * Select specific fields to fetch from the Schedule
     * 
    **/
    select?: ScheduleSelect | null
    /**
     * The data needed to create a Schedule.
     * 
    **/
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
  }


  /**
   * Schedule createMany
   */
  export type ScheduleCreateManyArgs = {
    data: Enumerable<ScheduleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Schedule update
   */
  export type ScheduleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Schedule
     * 
    **/
    select?: ScheduleSelect | null
    /**
     * The data needed to update a Schedule.
     * 
    **/
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    /**
     * Choose, which Schedule to update.
     * 
    **/
    where: ScheduleWhereUniqueInput
  }


  /**
   * Schedule updateMany
   */
  export type ScheduleUpdateManyArgs = {
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    where?: ScheduleWhereInput
  }


  /**
   * Schedule upsert
   */
  export type ScheduleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Schedule
     * 
    **/
    select?: ScheduleSelect | null
    /**
     * The filter to search for the Schedule to update in case it exists.
     * 
    **/
    where: ScheduleWhereUniqueInput
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     * 
    **/
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
  }


  /**
   * Schedule delete
   */
  export type ScheduleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Schedule
     * 
    **/
    select?: ScheduleSelect | null
    /**
     * Filter which Schedule to delete.
     * 
    **/
    where: ScheduleWhereUniqueInput
  }


  /**
   * Schedule deleteMany
   */
  export type ScheduleDeleteManyArgs = {
    where?: ScheduleWhereInput
  }


  /**
   * Schedule without action
   */
  export type ScheduleArgs = {
    /**
     * Select specific fields to fetch from the Schedule
     * 
    **/
    select?: ScheduleSelect | null
  }



  /**
   * Model Vendor_Documents
   */


  export type AggregateVendor_Documents = {
    _count: Vendor_DocumentsCountAggregateOutputType | null
    count: Vendor_DocumentsCountAggregateOutputType | null
    _avg: Vendor_DocumentsAvgAggregateOutputType | null
    avg: Vendor_DocumentsAvgAggregateOutputType | null
    _sum: Vendor_DocumentsSumAggregateOutputType | null
    sum: Vendor_DocumentsSumAggregateOutputType | null
    _min: Vendor_DocumentsMinAggregateOutputType | null
    min: Vendor_DocumentsMinAggregateOutputType | null
    _max: Vendor_DocumentsMaxAggregateOutputType | null
    max: Vendor_DocumentsMaxAggregateOutputType | null
  }

  export type Vendor_DocumentsAvgAggregateOutputType = {
    id: number | null
    VendorsId: number | null
  }

  export type Vendor_DocumentsSumAggregateOutputType = {
    id: number | null
    VendorsId: number | null
  }

  export type Vendor_DocumentsMinAggregateOutputType = {
    id: number | null
    uid: string | null
    document_type: string | null
    document_path: string | null
    created_at: Date | null
    updated_at: Date | null
    VendorsId: number | null
  }

  export type Vendor_DocumentsMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    document_type: string | null
    document_path: string | null
    created_at: Date | null
    updated_at: Date | null
    VendorsId: number | null
  }

  export type Vendor_DocumentsCountAggregateOutputType = {
    id: number
    uid: number
    document_type: number
    document_path: number
    created_at: number
    updated_at: number
    VendorsId: number
    _all: number
  }


  export type Vendor_DocumentsAvgAggregateInputType = {
    id?: true
    VendorsId?: true
  }

  export type Vendor_DocumentsSumAggregateInputType = {
    id?: true
    VendorsId?: true
  }

  export type Vendor_DocumentsMinAggregateInputType = {
    id?: true
    uid?: true
    document_type?: true
    document_path?: true
    created_at?: true
    updated_at?: true
    VendorsId?: true
  }

  export type Vendor_DocumentsMaxAggregateInputType = {
    id?: true
    uid?: true
    document_type?: true
    document_path?: true
    created_at?: true
    updated_at?: true
    VendorsId?: true
  }

  export type Vendor_DocumentsCountAggregateInputType = {
    id?: true
    uid?: true
    document_type?: true
    document_path?: true
    created_at?: true
    updated_at?: true
    VendorsId?: true
    _all?: true
  }

  export type Vendor_DocumentsAggregateArgs = {
    /**
     * Filter which Vendor_Documents to aggregate.
     * 
    **/
    where?: Vendor_DocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendor_Documents to fetch.
     * 
    **/
    orderBy?: Enumerable<Vendor_DocumentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: Vendor_DocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendor_Documents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendor_Documents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendor_Documents
    **/
    _count?: true | Vendor_DocumentsCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | Vendor_DocumentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Vendor_DocumentsAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: Vendor_DocumentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Vendor_DocumentsSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: Vendor_DocumentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vendor_DocumentsMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: Vendor_DocumentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vendor_DocumentsMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: Vendor_DocumentsMaxAggregateInputType
  }

  export type GetVendor_DocumentsAggregateType<T extends Vendor_DocumentsAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor_Documents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor_Documents[P]>
      : GetScalarType<T[P], AggregateVendor_Documents[P]>
  }


    
    
  export type Vendor_DocumentsGroupByArgs = {
    where?: Vendor_DocumentsWhereInput
    orderBy?: Enumerable<Vendor_DocumentsOrderByInput>
    by: Array<Vendor_DocumentsScalarFieldEnum>
    having?: Vendor_DocumentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vendor_DocumentsCountAggregateInputType | true
    _avg?: Vendor_DocumentsAvgAggregateInputType
    _sum?: Vendor_DocumentsSumAggregateInputType
    _min?: Vendor_DocumentsMinAggregateInputType
    _max?: Vendor_DocumentsMaxAggregateInputType
  }


  export type Vendor_DocumentsGroupByOutputType = {
    id: number
    uid: string
    document_type: string
    document_path: string
    created_at: Date
    updated_at: Date
    VendorsId: number
    _count: Vendor_DocumentsCountAggregateOutputType | null
    _avg: Vendor_DocumentsAvgAggregateOutputType | null
    _sum: Vendor_DocumentsSumAggregateOutputType | null
    _min: Vendor_DocumentsMinAggregateOutputType | null
    _max: Vendor_DocumentsMaxAggregateOutputType | null
  }

  type GetVendor_DocumentsGroupByPayload<T extends Vendor_DocumentsGroupByArgs> = Promise<
    Array<
      PickArray<Vendor_DocumentsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof Vendor_DocumentsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], Vendor_DocumentsGroupByOutputType[P]> 
            : GetScalarType<T[P], Vendor_DocumentsGroupByOutputType[P]>
        }
      > 
    >


  export type Vendor_DocumentsSelect = {
    id?: boolean
    uid?: boolean
    document_type?: boolean
    document_path?: boolean
    created_at?: boolean
    updated_at?: boolean
    Vendors?: boolean | VendorsArgs
    VendorsId?: boolean
  }

  export type Vendor_DocumentsInclude = {
    Vendors?: boolean | VendorsArgs
  }

  export type Vendor_DocumentsGetPayload<
    S extends boolean | null | undefined | Vendor_DocumentsArgs,
    U = keyof S
      > = S extends true
        ? Vendor_Documents
    : S extends undefined
    ? never
    : S extends Vendor_DocumentsArgs | Vendor_DocumentsFindManyArgs
    ?'include' extends U
    ? Vendor_Documents  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Vendors'
        ? VendorsGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Vendor_Documents ?Vendor_Documents [P]
  : 
          P extends 'Vendors'
        ? VendorsGetPayload<S['select'][P]> : never
  } 
    : Vendor_Documents
  : Vendor_Documents


  type Vendor_DocumentsCountArgs = Merge<
    Omit<Vendor_DocumentsFindManyArgs, 'select' | 'include'> & {
      select?: Vendor_DocumentsCountAggregateInputType | true
    }
  >

  export interface Vendor_DocumentsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Vendor_Documents that matches the filter.
     * @param {Vendor_DocumentsFindUniqueArgs} args - Arguments to find a Vendor_Documents
     * @example
     * // Get one Vendor_Documents
     * const vendor_Documents = await prisma.vendor_Documents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Vendor_DocumentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Vendor_DocumentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Vendor_Documents'> extends True ? CheckSelect<T, Prisma__Vendor_DocumentsClient<Vendor_Documents>, Prisma__Vendor_DocumentsClient<Vendor_DocumentsGetPayload<T>>> : CheckSelect<T, Prisma__Vendor_DocumentsClient<Vendor_Documents | null >, Prisma__Vendor_DocumentsClient<Vendor_DocumentsGetPayload<T> | null >>

    /**
     * Find the first Vendor_Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vendor_DocumentsFindFirstArgs} args - Arguments to find a Vendor_Documents
     * @example
     * // Get one Vendor_Documents
     * const vendor_Documents = await prisma.vendor_Documents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Vendor_DocumentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Vendor_DocumentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Vendor_Documents'> extends True ? CheckSelect<T, Prisma__Vendor_DocumentsClient<Vendor_Documents>, Prisma__Vendor_DocumentsClient<Vendor_DocumentsGetPayload<T>>> : CheckSelect<T, Prisma__Vendor_DocumentsClient<Vendor_Documents | null >, Prisma__Vendor_DocumentsClient<Vendor_DocumentsGetPayload<T> | null >>

    /**
     * Find zero or more Vendor_Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vendor_DocumentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendor_Documents
     * const vendor_Documents = await prisma.vendor_Documents.findMany()
     * 
     * // Get first 10 Vendor_Documents
     * const vendor_Documents = await prisma.vendor_Documents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendor_DocumentsWithIdOnly = await prisma.vendor_Documents.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Vendor_DocumentsFindManyArgs>(
      args?: SelectSubset<T, Vendor_DocumentsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Vendor_Documents>>, PrismaPromise<Array<Vendor_DocumentsGetPayload<T>>>>

    /**
     * Create a Vendor_Documents.
     * @param {Vendor_DocumentsCreateArgs} args - Arguments to create a Vendor_Documents.
     * @example
     * // Create one Vendor_Documents
     * const Vendor_Documents = await prisma.vendor_Documents.create({
     *   data: {
     *     // ... data to create a Vendor_Documents
     *   }
     * })
     * 
    **/
    create<T extends Vendor_DocumentsCreateArgs>(
      args: SelectSubset<T, Vendor_DocumentsCreateArgs>
    ): CheckSelect<T, Prisma__Vendor_DocumentsClient<Vendor_Documents>, Prisma__Vendor_DocumentsClient<Vendor_DocumentsGetPayload<T>>>

    /**
     * Create many Vendor_Documents.
     *     @param {Vendor_DocumentsCreateManyArgs} args - Arguments to create many Vendor_Documents.
     *     @example
     *     // Create many Vendor_Documents
     *     const vendor_Documents = await prisma.vendor_Documents.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Vendor_DocumentsCreateManyArgs>(
      args?: SelectSubset<T, Vendor_DocumentsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Vendor_Documents.
     * @param {Vendor_DocumentsDeleteArgs} args - Arguments to delete one Vendor_Documents.
     * @example
     * // Delete one Vendor_Documents
     * const Vendor_Documents = await prisma.vendor_Documents.delete({
     *   where: {
     *     // ... filter to delete one Vendor_Documents
     *   }
     * })
     * 
    **/
    delete<T extends Vendor_DocumentsDeleteArgs>(
      args: SelectSubset<T, Vendor_DocumentsDeleteArgs>
    ): CheckSelect<T, Prisma__Vendor_DocumentsClient<Vendor_Documents>, Prisma__Vendor_DocumentsClient<Vendor_DocumentsGetPayload<T>>>

    /**
     * Update one Vendor_Documents.
     * @param {Vendor_DocumentsUpdateArgs} args - Arguments to update one Vendor_Documents.
     * @example
     * // Update one Vendor_Documents
     * const vendor_Documents = await prisma.vendor_Documents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Vendor_DocumentsUpdateArgs>(
      args: SelectSubset<T, Vendor_DocumentsUpdateArgs>
    ): CheckSelect<T, Prisma__Vendor_DocumentsClient<Vendor_Documents>, Prisma__Vendor_DocumentsClient<Vendor_DocumentsGetPayload<T>>>

    /**
     * Delete zero or more Vendor_Documents.
     * @param {Vendor_DocumentsDeleteManyArgs} args - Arguments to filter Vendor_Documents to delete.
     * @example
     * // Delete a few Vendor_Documents
     * const { count } = await prisma.vendor_Documents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Vendor_DocumentsDeleteManyArgs>(
      args?: SelectSubset<T, Vendor_DocumentsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendor_Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vendor_DocumentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendor_Documents
     * const vendor_Documents = await prisma.vendor_Documents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Vendor_DocumentsUpdateManyArgs>(
      args: SelectSubset<T, Vendor_DocumentsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendor_Documents.
     * @param {Vendor_DocumentsUpsertArgs} args - Arguments to update or create a Vendor_Documents.
     * @example
     * // Update or create a Vendor_Documents
     * const vendor_Documents = await prisma.vendor_Documents.upsert({
     *   create: {
     *     // ... data to create a Vendor_Documents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor_Documents we want to update
     *   }
     * })
    **/
    upsert<T extends Vendor_DocumentsUpsertArgs>(
      args: SelectSubset<T, Vendor_DocumentsUpsertArgs>
    ): CheckSelect<T, Prisma__Vendor_DocumentsClient<Vendor_Documents>, Prisma__Vendor_DocumentsClient<Vendor_DocumentsGetPayload<T>>>

    /**
     * Count the number of Vendor_Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vendor_DocumentsCountArgs} args - Arguments to filter Vendor_Documents to count.
     * @example
     * // Count the number of Vendor_Documents
     * const count = await prisma.vendor_Documents.count({
     *   where: {
     *     // ... the filter for the Vendor_Documents we want to count
     *   }
     * })
    **/
    count<T extends Vendor_DocumentsCountArgs>(
      args?: Subset<T, Vendor_DocumentsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vendor_DocumentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor_Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vendor_DocumentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vendor_DocumentsAggregateArgs>(args: Subset<T, Vendor_DocumentsAggregateArgs>): PrismaPromise<GetVendor_DocumentsAggregateType<T>>

    /**
     * Group by Vendor_Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vendor_DocumentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Vendor_DocumentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Vendor_DocumentsGroupByArgs['orderBy'] }
        : { orderBy?: Vendor_DocumentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Vendor_DocumentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendor_DocumentsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor_Documents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Vendor_DocumentsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Vendors<T extends VendorsArgs = {}>(args?: Subset<T, VendorsArgs>): CheckSelect<T, Prisma__VendorsClient<Vendors | null >, Prisma__VendorsClient<VendorsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Vendor_Documents findUnique
   */
  export type Vendor_DocumentsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Documents
     * 
    **/
    select?: Vendor_DocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Vendor_DocumentsInclude | null
    /**
     * Throw an Error if a Vendor_Documents can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Vendor_Documents to fetch.
     * 
    **/
    where: Vendor_DocumentsWhereUniqueInput
  }


  /**
   * Vendor_Documents findFirst
   */
  export type Vendor_DocumentsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Documents
     * 
    **/
    select?: Vendor_DocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Vendor_DocumentsInclude | null
    /**
     * Throw an Error if a Vendor_Documents can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Vendor_Documents to fetch.
     * 
    **/
    where?: Vendor_DocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendor_Documents to fetch.
     * 
    **/
    orderBy?: Enumerable<Vendor_DocumentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendor_Documents.
     * 
    **/
    cursor?: Vendor_DocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendor_Documents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendor_Documents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendor_Documents.
     * 
    **/
    distinct?: Enumerable<Vendor_DocumentsScalarFieldEnum>
  }


  /**
   * Vendor_Documents findMany
   */
  export type Vendor_DocumentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Documents
     * 
    **/
    select?: Vendor_DocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Vendor_DocumentsInclude | null
    /**
     * Filter, which Vendor_Documents to fetch.
     * 
    **/
    where?: Vendor_DocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendor_Documents to fetch.
     * 
    **/
    orderBy?: Enumerable<Vendor_DocumentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendor_Documents.
     * 
    **/
    cursor?: Vendor_DocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendor_Documents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendor_Documents.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Vendor_DocumentsScalarFieldEnum>
  }


  /**
   * Vendor_Documents create
   */
  export type Vendor_DocumentsCreateArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Documents
     * 
    **/
    select?: Vendor_DocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Vendor_DocumentsInclude | null
    /**
     * The data needed to create a Vendor_Documents.
     * 
    **/
    data: XOR<Vendor_DocumentsCreateInput, Vendor_DocumentsUncheckedCreateInput>
  }


  /**
   * Vendor_Documents createMany
   */
  export type Vendor_DocumentsCreateManyArgs = {
    data: Enumerable<Vendor_DocumentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Vendor_Documents update
   */
  export type Vendor_DocumentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Documents
     * 
    **/
    select?: Vendor_DocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Vendor_DocumentsInclude | null
    /**
     * The data needed to update a Vendor_Documents.
     * 
    **/
    data: XOR<Vendor_DocumentsUpdateInput, Vendor_DocumentsUncheckedUpdateInput>
    /**
     * Choose, which Vendor_Documents to update.
     * 
    **/
    where: Vendor_DocumentsWhereUniqueInput
  }


  /**
   * Vendor_Documents updateMany
   */
  export type Vendor_DocumentsUpdateManyArgs = {
    data: XOR<Vendor_DocumentsUpdateManyMutationInput, Vendor_DocumentsUncheckedUpdateManyInput>
    where?: Vendor_DocumentsWhereInput
  }


  /**
   * Vendor_Documents upsert
   */
  export type Vendor_DocumentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Documents
     * 
    **/
    select?: Vendor_DocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Vendor_DocumentsInclude | null
    /**
     * The filter to search for the Vendor_Documents to update in case it exists.
     * 
    **/
    where: Vendor_DocumentsWhereUniqueInput
    /**
     * In case the Vendor_Documents found by the `where` argument doesn't exist, create a new Vendor_Documents with this data.
     * 
    **/
    create: XOR<Vendor_DocumentsCreateInput, Vendor_DocumentsUncheckedCreateInput>
    /**
     * In case the Vendor_Documents was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<Vendor_DocumentsUpdateInput, Vendor_DocumentsUncheckedUpdateInput>
  }


  /**
   * Vendor_Documents delete
   */
  export type Vendor_DocumentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Documents
     * 
    **/
    select?: Vendor_DocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Vendor_DocumentsInclude | null
    /**
     * Filter which Vendor_Documents to delete.
     * 
    **/
    where: Vendor_DocumentsWhereUniqueInput
  }


  /**
   * Vendor_Documents deleteMany
   */
  export type Vendor_DocumentsDeleteManyArgs = {
    where?: Vendor_DocumentsWhereInput
  }


  /**
   * Vendor_Documents without action
   */
  export type Vendor_DocumentsArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Documents
     * 
    **/
    select?: Vendor_DocumentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Vendor_DocumentsInclude | null
  }



  /**
   * Model Vendor_Medtreats
   */


  export type AggregateVendor_Medtreats = {
    _count: Vendor_MedtreatsCountAggregateOutputType | null
    count: Vendor_MedtreatsCountAggregateOutputType | null
    _avg: Vendor_MedtreatsAvgAggregateOutputType | null
    avg: Vendor_MedtreatsAvgAggregateOutputType | null
    _sum: Vendor_MedtreatsSumAggregateOutputType | null
    sum: Vendor_MedtreatsSumAggregateOutputType | null
    _min: Vendor_MedtreatsMinAggregateOutputType | null
    min: Vendor_MedtreatsMinAggregateOutputType | null
    _max: Vendor_MedtreatsMaxAggregateOutputType | null
    max: Vendor_MedtreatsMaxAggregateOutputType | null
  }

  export type Vendor_MedtreatsAvgAggregateOutputType = {
    id: number | null
    VendorsId: number | null
  }

  export type Vendor_MedtreatsSumAggregateOutputType = {
    id: number | null
    VendorsId: number | null
  }

  export type Vendor_MedtreatsMinAggregateOutputType = {
    id: number | null
    uid: string | null
    medical_treatment_id: string | null
    is_homecare: boolean | null
    created_at: Date | null
    updated_at: Date | null
    VendorsId: number | null
  }

  export type Vendor_MedtreatsMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    medical_treatment_id: string | null
    is_homecare: boolean | null
    created_at: Date | null
    updated_at: Date | null
    VendorsId: number | null
  }

  export type Vendor_MedtreatsCountAggregateOutputType = {
    id: number
    uid: number
    medical_treatment_id: number
    is_homecare: number
    created_at: number
    updated_at: number
    VendorsId: number
    _all: number
  }


  export type Vendor_MedtreatsAvgAggregateInputType = {
    id?: true
    VendorsId?: true
  }

  export type Vendor_MedtreatsSumAggregateInputType = {
    id?: true
    VendorsId?: true
  }

  export type Vendor_MedtreatsMinAggregateInputType = {
    id?: true
    uid?: true
    medical_treatment_id?: true
    is_homecare?: true
    created_at?: true
    updated_at?: true
    VendorsId?: true
  }

  export type Vendor_MedtreatsMaxAggregateInputType = {
    id?: true
    uid?: true
    medical_treatment_id?: true
    is_homecare?: true
    created_at?: true
    updated_at?: true
    VendorsId?: true
  }

  export type Vendor_MedtreatsCountAggregateInputType = {
    id?: true
    uid?: true
    medical_treatment_id?: true
    is_homecare?: true
    created_at?: true
    updated_at?: true
    VendorsId?: true
    _all?: true
  }

  export type Vendor_MedtreatsAggregateArgs = {
    /**
     * Filter which Vendor_Medtreats to aggregate.
     * 
    **/
    where?: Vendor_MedtreatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendor_Medtreats to fetch.
     * 
    **/
    orderBy?: Enumerable<Vendor_MedtreatsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: Vendor_MedtreatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendor_Medtreats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendor_Medtreats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendor_Medtreats
    **/
    _count?: true | Vendor_MedtreatsCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | Vendor_MedtreatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Vendor_MedtreatsAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: Vendor_MedtreatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Vendor_MedtreatsSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: Vendor_MedtreatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vendor_MedtreatsMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: Vendor_MedtreatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vendor_MedtreatsMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: Vendor_MedtreatsMaxAggregateInputType
  }

  export type GetVendor_MedtreatsAggregateType<T extends Vendor_MedtreatsAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor_Medtreats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor_Medtreats[P]>
      : GetScalarType<T[P], AggregateVendor_Medtreats[P]>
  }


    
    
  export type Vendor_MedtreatsGroupByArgs = {
    where?: Vendor_MedtreatsWhereInput
    orderBy?: Enumerable<Vendor_MedtreatsOrderByInput>
    by: Array<Vendor_MedtreatsScalarFieldEnum>
    having?: Vendor_MedtreatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vendor_MedtreatsCountAggregateInputType | true
    _avg?: Vendor_MedtreatsAvgAggregateInputType
    _sum?: Vendor_MedtreatsSumAggregateInputType
    _min?: Vendor_MedtreatsMinAggregateInputType
    _max?: Vendor_MedtreatsMaxAggregateInputType
  }


  export type Vendor_MedtreatsGroupByOutputType = {
    id: number
    uid: string
    medical_treatment_id: string
    is_homecare: boolean
    created_at: Date
    updated_at: Date
    VendorsId: number
    _count: Vendor_MedtreatsCountAggregateOutputType | null
    _avg: Vendor_MedtreatsAvgAggregateOutputType | null
    _sum: Vendor_MedtreatsSumAggregateOutputType | null
    _min: Vendor_MedtreatsMinAggregateOutputType | null
    _max: Vendor_MedtreatsMaxAggregateOutputType | null
  }

  type GetVendor_MedtreatsGroupByPayload<T extends Vendor_MedtreatsGroupByArgs> = Promise<
    Array<
      PickArray<Vendor_MedtreatsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof Vendor_MedtreatsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], Vendor_MedtreatsGroupByOutputType[P]> 
            : GetScalarType<T[P], Vendor_MedtreatsGroupByOutputType[P]>
        }
      > 
    >


  export type Vendor_MedtreatsSelect = {
    id?: boolean
    uid?: boolean
    medical_treatment_id?: boolean
    is_homecare?: boolean
    created_at?: boolean
    updated_at?: boolean
    Vendors?: boolean | VendorsArgs
    VendorsId?: boolean
  }

  export type Vendor_MedtreatsInclude = {
    Vendors?: boolean | VendorsArgs
  }

  export type Vendor_MedtreatsGetPayload<
    S extends boolean | null | undefined | Vendor_MedtreatsArgs,
    U = keyof S
      > = S extends true
        ? Vendor_Medtreats
    : S extends undefined
    ? never
    : S extends Vendor_MedtreatsArgs | Vendor_MedtreatsFindManyArgs
    ?'include' extends U
    ? Vendor_Medtreats  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Vendors'
        ? VendorsGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Vendor_Medtreats ?Vendor_Medtreats [P]
  : 
          P extends 'Vendors'
        ? VendorsGetPayload<S['select'][P]> : never
  } 
    : Vendor_Medtreats
  : Vendor_Medtreats


  type Vendor_MedtreatsCountArgs = Merge<
    Omit<Vendor_MedtreatsFindManyArgs, 'select' | 'include'> & {
      select?: Vendor_MedtreatsCountAggregateInputType | true
    }
  >

  export interface Vendor_MedtreatsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Vendor_Medtreats that matches the filter.
     * @param {Vendor_MedtreatsFindUniqueArgs} args - Arguments to find a Vendor_Medtreats
     * @example
     * // Get one Vendor_Medtreats
     * const vendor_Medtreats = await prisma.vendor_Medtreats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Vendor_MedtreatsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Vendor_MedtreatsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Vendor_Medtreats'> extends True ? CheckSelect<T, Prisma__Vendor_MedtreatsClient<Vendor_Medtreats>, Prisma__Vendor_MedtreatsClient<Vendor_MedtreatsGetPayload<T>>> : CheckSelect<T, Prisma__Vendor_MedtreatsClient<Vendor_Medtreats | null >, Prisma__Vendor_MedtreatsClient<Vendor_MedtreatsGetPayload<T> | null >>

    /**
     * Find the first Vendor_Medtreats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vendor_MedtreatsFindFirstArgs} args - Arguments to find a Vendor_Medtreats
     * @example
     * // Get one Vendor_Medtreats
     * const vendor_Medtreats = await prisma.vendor_Medtreats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Vendor_MedtreatsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Vendor_MedtreatsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Vendor_Medtreats'> extends True ? CheckSelect<T, Prisma__Vendor_MedtreatsClient<Vendor_Medtreats>, Prisma__Vendor_MedtreatsClient<Vendor_MedtreatsGetPayload<T>>> : CheckSelect<T, Prisma__Vendor_MedtreatsClient<Vendor_Medtreats | null >, Prisma__Vendor_MedtreatsClient<Vendor_MedtreatsGetPayload<T> | null >>

    /**
     * Find zero or more Vendor_Medtreats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vendor_MedtreatsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendor_Medtreats
     * const vendor_Medtreats = await prisma.vendor_Medtreats.findMany()
     * 
     * // Get first 10 Vendor_Medtreats
     * const vendor_Medtreats = await prisma.vendor_Medtreats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendor_MedtreatsWithIdOnly = await prisma.vendor_Medtreats.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Vendor_MedtreatsFindManyArgs>(
      args?: SelectSubset<T, Vendor_MedtreatsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Vendor_Medtreats>>, PrismaPromise<Array<Vendor_MedtreatsGetPayload<T>>>>

    /**
     * Create a Vendor_Medtreats.
     * @param {Vendor_MedtreatsCreateArgs} args - Arguments to create a Vendor_Medtreats.
     * @example
     * // Create one Vendor_Medtreats
     * const Vendor_Medtreats = await prisma.vendor_Medtreats.create({
     *   data: {
     *     // ... data to create a Vendor_Medtreats
     *   }
     * })
     * 
    **/
    create<T extends Vendor_MedtreatsCreateArgs>(
      args: SelectSubset<T, Vendor_MedtreatsCreateArgs>
    ): CheckSelect<T, Prisma__Vendor_MedtreatsClient<Vendor_Medtreats>, Prisma__Vendor_MedtreatsClient<Vendor_MedtreatsGetPayload<T>>>

    /**
     * Create many Vendor_Medtreats.
     *     @param {Vendor_MedtreatsCreateManyArgs} args - Arguments to create many Vendor_Medtreats.
     *     @example
     *     // Create many Vendor_Medtreats
     *     const vendor_Medtreats = await prisma.vendor_Medtreats.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Vendor_MedtreatsCreateManyArgs>(
      args?: SelectSubset<T, Vendor_MedtreatsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Vendor_Medtreats.
     * @param {Vendor_MedtreatsDeleteArgs} args - Arguments to delete one Vendor_Medtreats.
     * @example
     * // Delete one Vendor_Medtreats
     * const Vendor_Medtreats = await prisma.vendor_Medtreats.delete({
     *   where: {
     *     // ... filter to delete one Vendor_Medtreats
     *   }
     * })
     * 
    **/
    delete<T extends Vendor_MedtreatsDeleteArgs>(
      args: SelectSubset<T, Vendor_MedtreatsDeleteArgs>
    ): CheckSelect<T, Prisma__Vendor_MedtreatsClient<Vendor_Medtreats>, Prisma__Vendor_MedtreatsClient<Vendor_MedtreatsGetPayload<T>>>

    /**
     * Update one Vendor_Medtreats.
     * @param {Vendor_MedtreatsUpdateArgs} args - Arguments to update one Vendor_Medtreats.
     * @example
     * // Update one Vendor_Medtreats
     * const vendor_Medtreats = await prisma.vendor_Medtreats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Vendor_MedtreatsUpdateArgs>(
      args: SelectSubset<T, Vendor_MedtreatsUpdateArgs>
    ): CheckSelect<T, Prisma__Vendor_MedtreatsClient<Vendor_Medtreats>, Prisma__Vendor_MedtreatsClient<Vendor_MedtreatsGetPayload<T>>>

    /**
     * Delete zero or more Vendor_Medtreats.
     * @param {Vendor_MedtreatsDeleteManyArgs} args - Arguments to filter Vendor_Medtreats to delete.
     * @example
     * // Delete a few Vendor_Medtreats
     * const { count } = await prisma.vendor_Medtreats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Vendor_MedtreatsDeleteManyArgs>(
      args?: SelectSubset<T, Vendor_MedtreatsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendor_Medtreats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vendor_MedtreatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendor_Medtreats
     * const vendor_Medtreats = await prisma.vendor_Medtreats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Vendor_MedtreatsUpdateManyArgs>(
      args: SelectSubset<T, Vendor_MedtreatsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendor_Medtreats.
     * @param {Vendor_MedtreatsUpsertArgs} args - Arguments to update or create a Vendor_Medtreats.
     * @example
     * // Update or create a Vendor_Medtreats
     * const vendor_Medtreats = await prisma.vendor_Medtreats.upsert({
     *   create: {
     *     // ... data to create a Vendor_Medtreats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor_Medtreats we want to update
     *   }
     * })
    **/
    upsert<T extends Vendor_MedtreatsUpsertArgs>(
      args: SelectSubset<T, Vendor_MedtreatsUpsertArgs>
    ): CheckSelect<T, Prisma__Vendor_MedtreatsClient<Vendor_Medtreats>, Prisma__Vendor_MedtreatsClient<Vendor_MedtreatsGetPayload<T>>>

    /**
     * Count the number of Vendor_Medtreats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vendor_MedtreatsCountArgs} args - Arguments to filter Vendor_Medtreats to count.
     * @example
     * // Count the number of Vendor_Medtreats
     * const count = await prisma.vendor_Medtreats.count({
     *   where: {
     *     // ... the filter for the Vendor_Medtreats we want to count
     *   }
     * })
    **/
    count<T extends Vendor_MedtreatsCountArgs>(
      args?: Subset<T, Vendor_MedtreatsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vendor_MedtreatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor_Medtreats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vendor_MedtreatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vendor_MedtreatsAggregateArgs>(args: Subset<T, Vendor_MedtreatsAggregateArgs>): PrismaPromise<GetVendor_MedtreatsAggregateType<T>>

    /**
     * Group by Vendor_Medtreats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vendor_MedtreatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Vendor_MedtreatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Vendor_MedtreatsGroupByArgs['orderBy'] }
        : { orderBy?: Vendor_MedtreatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Vendor_MedtreatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendor_MedtreatsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor_Medtreats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Vendor_MedtreatsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Vendors<T extends VendorsArgs = {}>(args?: Subset<T, VendorsArgs>): CheckSelect<T, Prisma__VendorsClient<Vendors | null >, Prisma__VendorsClient<VendorsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Vendor_Medtreats findUnique
   */
  export type Vendor_MedtreatsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Medtreats
     * 
    **/
    select?: Vendor_MedtreatsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Vendor_MedtreatsInclude | null
    /**
     * Throw an Error if a Vendor_Medtreats can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Vendor_Medtreats to fetch.
     * 
    **/
    where: Vendor_MedtreatsWhereUniqueInput
  }


  /**
   * Vendor_Medtreats findFirst
   */
  export type Vendor_MedtreatsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Medtreats
     * 
    **/
    select?: Vendor_MedtreatsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Vendor_MedtreatsInclude | null
    /**
     * Throw an Error if a Vendor_Medtreats can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Vendor_Medtreats to fetch.
     * 
    **/
    where?: Vendor_MedtreatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendor_Medtreats to fetch.
     * 
    **/
    orderBy?: Enumerable<Vendor_MedtreatsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendor_Medtreats.
     * 
    **/
    cursor?: Vendor_MedtreatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendor_Medtreats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendor_Medtreats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendor_Medtreats.
     * 
    **/
    distinct?: Enumerable<Vendor_MedtreatsScalarFieldEnum>
  }


  /**
   * Vendor_Medtreats findMany
   */
  export type Vendor_MedtreatsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Medtreats
     * 
    **/
    select?: Vendor_MedtreatsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Vendor_MedtreatsInclude | null
    /**
     * Filter, which Vendor_Medtreats to fetch.
     * 
    **/
    where?: Vendor_MedtreatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendor_Medtreats to fetch.
     * 
    **/
    orderBy?: Enumerable<Vendor_MedtreatsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendor_Medtreats.
     * 
    **/
    cursor?: Vendor_MedtreatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendor_Medtreats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendor_Medtreats.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Vendor_MedtreatsScalarFieldEnum>
  }


  /**
   * Vendor_Medtreats create
   */
  export type Vendor_MedtreatsCreateArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Medtreats
     * 
    **/
    select?: Vendor_MedtreatsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Vendor_MedtreatsInclude | null
    /**
     * The data needed to create a Vendor_Medtreats.
     * 
    **/
    data: XOR<Vendor_MedtreatsCreateInput, Vendor_MedtreatsUncheckedCreateInput>
  }


  /**
   * Vendor_Medtreats createMany
   */
  export type Vendor_MedtreatsCreateManyArgs = {
    data: Enumerable<Vendor_MedtreatsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Vendor_Medtreats update
   */
  export type Vendor_MedtreatsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Medtreats
     * 
    **/
    select?: Vendor_MedtreatsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Vendor_MedtreatsInclude | null
    /**
     * The data needed to update a Vendor_Medtreats.
     * 
    **/
    data: XOR<Vendor_MedtreatsUpdateInput, Vendor_MedtreatsUncheckedUpdateInput>
    /**
     * Choose, which Vendor_Medtreats to update.
     * 
    **/
    where: Vendor_MedtreatsWhereUniqueInput
  }


  /**
   * Vendor_Medtreats updateMany
   */
  export type Vendor_MedtreatsUpdateManyArgs = {
    data: XOR<Vendor_MedtreatsUpdateManyMutationInput, Vendor_MedtreatsUncheckedUpdateManyInput>
    where?: Vendor_MedtreatsWhereInput
  }


  /**
   * Vendor_Medtreats upsert
   */
  export type Vendor_MedtreatsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Medtreats
     * 
    **/
    select?: Vendor_MedtreatsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Vendor_MedtreatsInclude | null
    /**
     * The filter to search for the Vendor_Medtreats to update in case it exists.
     * 
    **/
    where: Vendor_MedtreatsWhereUniqueInput
    /**
     * In case the Vendor_Medtreats found by the `where` argument doesn't exist, create a new Vendor_Medtreats with this data.
     * 
    **/
    create: XOR<Vendor_MedtreatsCreateInput, Vendor_MedtreatsUncheckedCreateInput>
    /**
     * In case the Vendor_Medtreats was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<Vendor_MedtreatsUpdateInput, Vendor_MedtreatsUncheckedUpdateInput>
  }


  /**
   * Vendor_Medtreats delete
   */
  export type Vendor_MedtreatsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Medtreats
     * 
    **/
    select?: Vendor_MedtreatsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Vendor_MedtreatsInclude | null
    /**
     * Filter which Vendor_Medtreats to delete.
     * 
    **/
    where: Vendor_MedtreatsWhereUniqueInput
  }


  /**
   * Vendor_Medtreats deleteMany
   */
  export type Vendor_MedtreatsDeleteManyArgs = {
    where?: Vendor_MedtreatsWhereInput
  }


  /**
   * Vendor_Medtreats without action
   */
  export type Vendor_MedtreatsArgs = {
    /**
     * Select specific fields to fetch from the Vendor_Medtreats
     * 
    **/
    select?: Vendor_MedtreatsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: Vendor_MedtreatsInclude | null
  }



  /**
   * Model Class
   */


  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
    max: ClassMaxAggregateOutputType | null
  }

  export type ClassAvgAggregateOutputType = {
    id: number | null
  }

  export type ClassSumAggregateOutputType = {
    id: number | null
  }

  export type ClassMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ClassMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type ClassAvgAggregateInputType = {
    id?: true
  }

  export type ClassSumAggregateInputType = {
    id?: true
  }

  export type ClassMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ClassAggregateArgs = {
    /**
     * Filter which Class to aggregate.
     * 
    **/
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     * 
    **/
    orderBy?: Enumerable<ClassOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }


    
    
  export type ClassGroupByArgs = {
    where?: ClassWhereInput
    orderBy?: Enumerable<ClassOrderByInput>
    by: Array<ClassScalarFieldEnum>
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _avg?: ClassAvgAggregateInputType
    _sum?: ClassSumAggregateInputType
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }


  export type ClassGroupByOutputType = {
    id: number
    name: string
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Promise<
    Array<
      PickArray<ClassGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ClassGroupByOutputType[P]> 
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      > 
    >


  export type ClassSelect = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    species?: boolean | SpeciesFindManyArgs
  }

  export type ClassInclude = {
    species?: boolean | SpeciesFindManyArgs
  }

  export type ClassGetPayload<
    S extends boolean | null | undefined | ClassArgs,
    U = keyof S
      > = S extends true
        ? Class
    : S extends undefined
    ? never
    : S extends ClassArgs | ClassFindManyArgs
    ?'include' extends U
    ? Class  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'species'
        ? Array < SpeciesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Class ?Class [P]
  : 
          P extends 'species'
        ? Array < SpeciesGetPayload<S['select'][P]>>  : never
  } 
    : Class
  : Class


  type ClassCountArgs = Merge<
    Omit<ClassFindManyArgs, 'select' | 'include'> & {
      select?: ClassCountAggregateInputType | true
    }
  >

  export interface ClassDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClassFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClassFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Class'> extends True ? CheckSelect<T, Prisma__ClassClient<Class>, Prisma__ClassClient<ClassGetPayload<T>>> : CheckSelect<T, Prisma__ClassClient<Class | null >, Prisma__ClassClient<ClassGetPayload<T> | null >>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClassFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClassFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Class'> extends True ? CheckSelect<T, Prisma__ClassClient<Class>, Prisma__ClassClient<ClassGetPayload<T>>> : CheckSelect<T, Prisma__ClassClient<Class | null >, Prisma__ClassClient<ClassGetPayload<T> | null >>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClassFindManyArgs>(
      args?: SelectSubset<T, ClassFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Class>>, PrismaPromise<Array<ClassGetPayload<T>>>>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
    **/
    create<T extends ClassCreateArgs>(
      args: SelectSubset<T, ClassCreateArgs>
    ): CheckSelect<T, Prisma__ClassClient<Class>, Prisma__ClassClient<ClassGetPayload<T>>>

    /**
     * Create many Classes.
     *     @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     *     @example
     *     // Create many Classes
     *     const class = await prisma.class.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClassCreateManyArgs>(
      args?: SelectSubset<T, ClassCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
    **/
    delete<T extends ClassDeleteArgs>(
      args: SelectSubset<T, ClassDeleteArgs>
    ): CheckSelect<T, Prisma__ClassClient<Class>, Prisma__ClassClient<ClassGetPayload<T>>>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClassUpdateArgs>(
      args: SelectSubset<T, ClassUpdateArgs>
    ): CheckSelect<T, Prisma__ClassClient<Class>, Prisma__ClassClient<ClassGetPayload<T>>>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClassDeleteManyArgs>(
      args?: SelectSubset<T, ClassDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClassUpdateManyArgs>(
      args: SelectSubset<T, ClassUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
    **/
    upsert<T extends ClassUpsertArgs>(
      args: SelectSubset<T, ClassUpsertArgs>
    ): CheckSelect<T, Prisma__ClassClient<Class>, Prisma__ClassClient<ClassGetPayload<T>>>

    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClassClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    species<T extends SpeciesFindManyArgs = {}>(args?: Subset<T, SpeciesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Species>>, PrismaPromise<Array<SpeciesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Class
     * 
    **/
    select?: ClassSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClassInclude | null
    /**
     * Throw an Error if a Class can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Class to fetch.
     * 
    **/
    where: ClassWhereUniqueInput
  }


  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Class
     * 
    **/
    select?: ClassSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClassInclude | null
    /**
     * Throw an Error if a Class can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Class to fetch.
     * 
    **/
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     * 
    **/
    orderBy?: Enumerable<ClassOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     * 
    **/
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     * 
    **/
    distinct?: Enumerable<ClassScalarFieldEnum>
  }


  /**
   * Class findMany
   */
  export type ClassFindManyArgs = {
    /**
     * Select specific fields to fetch from the Class
     * 
    **/
    select?: ClassSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClassInclude | null
    /**
     * Filter, which Classes to fetch.
     * 
    **/
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     * 
    **/
    orderBy?: Enumerable<ClassOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     * 
    **/
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClassScalarFieldEnum>
  }


  /**
   * Class create
   */
  export type ClassCreateArgs = {
    /**
     * Select specific fields to fetch from the Class
     * 
    **/
    select?: ClassSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClassInclude | null
    /**
     * The data needed to create a Class.
     * 
    **/
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }


  /**
   * Class createMany
   */
  export type ClassCreateManyArgs = {
    data: Enumerable<ClassCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Class update
   */
  export type ClassUpdateArgs = {
    /**
     * Select specific fields to fetch from the Class
     * 
    **/
    select?: ClassSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClassInclude | null
    /**
     * The data needed to update a Class.
     * 
    **/
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     * 
    **/
    where: ClassWhereUniqueInput
  }


  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs = {
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    where?: ClassWhereInput
  }


  /**
   * Class upsert
   */
  export type ClassUpsertArgs = {
    /**
     * Select specific fields to fetch from the Class
     * 
    **/
    select?: ClassSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClassInclude | null
    /**
     * The filter to search for the Class to update in case it exists.
     * 
    **/
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     * 
    **/
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }


  /**
   * Class delete
   */
  export type ClassDeleteArgs = {
    /**
     * Select specific fields to fetch from the Class
     * 
    **/
    select?: ClassSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClassInclude | null
    /**
     * Filter which Class to delete.
     * 
    **/
    where: ClassWhereUniqueInput
  }


  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs = {
    where?: ClassWhereInput
  }


  /**
   * Class without action
   */
  export type ClassArgs = {
    /**
     * Select specific fields to fetch from the Class
     * 
    **/
    select?: ClassSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClassInclude | null
  }



  /**
   * Model Species
   */


  export type AggregateSpecies = {
    _count: SpeciesCountAggregateOutputType | null
    count: SpeciesCountAggregateOutputType | null
    _avg: SpeciesAvgAggregateOutputType | null
    avg: SpeciesAvgAggregateOutputType | null
    _sum: SpeciesSumAggregateOutputType | null
    sum: SpeciesSumAggregateOutputType | null
    _min: SpeciesMinAggregateOutputType | null
    min: SpeciesMinAggregateOutputType | null
    _max: SpeciesMaxAggregateOutputType | null
    max: SpeciesMaxAggregateOutputType | null
  }

  export type SpeciesAvgAggregateOutputType = {
    id: number | null
    ClassId: number | null
  }

  export type SpeciesSumAggregateOutputType = {
    id: number | null
    ClassId: number | null
  }

  export type SpeciesMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    ClassId: number | null
  }

  export type SpeciesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    ClassId: number | null
  }

  export type SpeciesCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    deleted_at: number
    ClassId: number
    _all: number
  }


  export type SpeciesAvgAggregateInputType = {
    id?: true
    ClassId?: true
  }

  export type SpeciesSumAggregateInputType = {
    id?: true
    ClassId?: true
  }

  export type SpeciesMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    ClassId?: true
  }

  export type SpeciesMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    ClassId?: true
  }

  export type SpeciesCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    ClassId?: true
    _all?: true
  }

  export type SpeciesAggregateArgs = {
    /**
     * Filter which Species to aggregate.
     * 
    **/
    where?: SpeciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Species to fetch.
     * 
    **/
    orderBy?: Enumerable<SpeciesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SpeciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Species from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Species.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Species
    **/
    _count?: true | SpeciesCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | SpeciesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpeciesAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: SpeciesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpeciesSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: SpeciesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpeciesMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: SpeciesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpeciesMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: SpeciesMaxAggregateInputType
  }

  export type GetSpeciesAggregateType<T extends SpeciesAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecies[P]>
      : GetScalarType<T[P], AggregateSpecies[P]>
  }


    
    
  export type SpeciesGroupByArgs = {
    where?: SpeciesWhereInput
    orderBy?: Enumerable<SpeciesOrderByInput>
    by: Array<SpeciesScalarFieldEnum>
    having?: SpeciesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpeciesCountAggregateInputType | true
    _avg?: SpeciesAvgAggregateInputType
    _sum?: SpeciesSumAggregateInputType
    _min?: SpeciesMinAggregateInputType
    _max?: SpeciesMaxAggregateInputType
  }


  export type SpeciesGroupByOutputType = {
    id: number
    name: string
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    ClassId: number
    _count: SpeciesCountAggregateOutputType | null
    _avg: SpeciesAvgAggregateOutputType | null
    _sum: SpeciesSumAggregateOutputType | null
    _min: SpeciesMinAggregateOutputType | null
    _max: SpeciesMaxAggregateOutputType | null
  }

  type GetSpeciesGroupByPayload<T extends SpeciesGroupByArgs> = Promise<
    Array<
      PickArray<SpeciesGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof SpeciesGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], SpeciesGroupByOutputType[P]> 
            : GetScalarType<T[P], SpeciesGroupByOutputType[P]>
        }
      > 
    >


  export type SpeciesSelect = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    Articles?: boolean | ArticlesFindManyArgs
    Class?: boolean | ClassArgs
    ClassId?: boolean
  }

  export type SpeciesInclude = {
    Articles?: boolean | ArticlesFindManyArgs
    Class?: boolean | ClassArgs
  }

  export type SpeciesGetPayload<
    S extends boolean | null | undefined | SpeciesArgs,
    U = keyof S
      > = S extends true
        ? Species
    : S extends undefined
    ? never
    : S extends SpeciesArgs | SpeciesFindManyArgs
    ?'include' extends U
    ? Species  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Articles'
        ? Array < ArticlesGetPayload<S['include'][P]>>  :
        P extends 'Class'
        ? ClassGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Species ?Species [P]
  : 
          P extends 'Articles'
        ? Array < ArticlesGetPayload<S['select'][P]>>  :
        P extends 'Class'
        ? ClassGetPayload<S['select'][P]> : never
  } 
    : Species
  : Species


  type SpeciesCountArgs = Merge<
    Omit<SpeciesFindManyArgs, 'select' | 'include'> & {
      select?: SpeciesCountAggregateInputType | true
    }
  >

  export interface SpeciesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Species that matches the filter.
     * @param {SpeciesFindUniqueArgs} args - Arguments to find a Species
     * @example
     * // Get one Species
     * const species = await prisma.species.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpeciesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SpeciesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Species'> extends True ? CheckSelect<T, Prisma__SpeciesClient<Species>, Prisma__SpeciesClient<SpeciesGetPayload<T>>> : CheckSelect<T, Prisma__SpeciesClient<Species | null >, Prisma__SpeciesClient<SpeciesGetPayload<T> | null >>

    /**
     * Find the first Species that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesFindFirstArgs} args - Arguments to find a Species
     * @example
     * // Get one Species
     * const species = await prisma.species.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpeciesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SpeciesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Species'> extends True ? CheckSelect<T, Prisma__SpeciesClient<Species>, Prisma__SpeciesClient<SpeciesGetPayload<T>>> : CheckSelect<T, Prisma__SpeciesClient<Species | null >, Prisma__SpeciesClient<SpeciesGetPayload<T> | null >>

    /**
     * Find zero or more Species that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Species
     * const species = await prisma.species.findMany()
     * 
     * // Get first 10 Species
     * const species = await prisma.species.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const speciesWithIdOnly = await prisma.species.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpeciesFindManyArgs>(
      args?: SelectSubset<T, SpeciesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Species>>, PrismaPromise<Array<SpeciesGetPayload<T>>>>

    /**
     * Create a Species.
     * @param {SpeciesCreateArgs} args - Arguments to create a Species.
     * @example
     * // Create one Species
     * const Species = await prisma.species.create({
     *   data: {
     *     // ... data to create a Species
     *   }
     * })
     * 
    **/
    create<T extends SpeciesCreateArgs>(
      args: SelectSubset<T, SpeciesCreateArgs>
    ): CheckSelect<T, Prisma__SpeciesClient<Species>, Prisma__SpeciesClient<SpeciesGetPayload<T>>>

    /**
     * Create many Species.
     *     @param {SpeciesCreateManyArgs} args - Arguments to create many Species.
     *     @example
     *     // Create many Species
     *     const species = await prisma.species.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpeciesCreateManyArgs>(
      args?: SelectSubset<T, SpeciesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Species.
     * @param {SpeciesDeleteArgs} args - Arguments to delete one Species.
     * @example
     * // Delete one Species
     * const Species = await prisma.species.delete({
     *   where: {
     *     // ... filter to delete one Species
     *   }
     * })
     * 
    **/
    delete<T extends SpeciesDeleteArgs>(
      args: SelectSubset<T, SpeciesDeleteArgs>
    ): CheckSelect<T, Prisma__SpeciesClient<Species>, Prisma__SpeciesClient<SpeciesGetPayload<T>>>

    /**
     * Update one Species.
     * @param {SpeciesUpdateArgs} args - Arguments to update one Species.
     * @example
     * // Update one Species
     * const species = await prisma.species.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpeciesUpdateArgs>(
      args: SelectSubset<T, SpeciesUpdateArgs>
    ): CheckSelect<T, Prisma__SpeciesClient<Species>, Prisma__SpeciesClient<SpeciesGetPayload<T>>>

    /**
     * Delete zero or more Species.
     * @param {SpeciesDeleteManyArgs} args - Arguments to filter Species to delete.
     * @example
     * // Delete a few Species
     * const { count } = await prisma.species.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpeciesDeleteManyArgs>(
      args?: SelectSubset<T, SpeciesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Species.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Species
     * const species = await prisma.species.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpeciesUpdateManyArgs>(
      args: SelectSubset<T, SpeciesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Species.
     * @param {SpeciesUpsertArgs} args - Arguments to update or create a Species.
     * @example
     * // Update or create a Species
     * const species = await prisma.species.upsert({
     *   create: {
     *     // ... data to create a Species
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Species we want to update
     *   }
     * })
    **/
    upsert<T extends SpeciesUpsertArgs>(
      args: SelectSubset<T, SpeciesUpsertArgs>
    ): CheckSelect<T, Prisma__SpeciesClient<Species>, Prisma__SpeciesClient<SpeciesGetPayload<T>>>

    /**
     * Count the number of Species.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesCountArgs} args - Arguments to filter Species to count.
     * @example
     * // Count the number of Species
     * const count = await prisma.species.count({
     *   where: {
     *     // ... the filter for the Species we want to count
     *   }
     * })
    **/
    count<T extends SpeciesCountArgs>(
      args?: Subset<T, SpeciesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpeciesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Species.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpeciesAggregateArgs>(args: Subset<T, SpeciesAggregateArgs>): PrismaPromise<GetSpeciesAggregateType<T>>

    /**
     * Group by Species.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeciesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpeciesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpeciesGroupByArgs['orderBy'] }
        : { orderBy?: SpeciesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpeciesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpeciesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Species.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SpeciesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Articles<T extends ArticlesFindManyArgs = {}>(args?: Subset<T, ArticlesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Articles>>, PrismaPromise<Array<ArticlesGetPayload<T>>>>;

    Class<T extends ClassArgs = {}>(args?: Subset<T, ClassArgs>): CheckSelect<T, Prisma__ClassClient<Class | null >, Prisma__ClassClient<ClassGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Species findUnique
   */
  export type SpeciesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Species
     * 
    **/
    select?: SpeciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpeciesInclude | null
    /**
     * Throw an Error if a Species can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Species to fetch.
     * 
    **/
    where: SpeciesWhereUniqueInput
  }


  /**
   * Species findFirst
   */
  export type SpeciesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Species
     * 
    **/
    select?: SpeciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpeciesInclude | null
    /**
     * Throw an Error if a Species can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Species to fetch.
     * 
    **/
    where?: SpeciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Species to fetch.
     * 
    **/
    orderBy?: Enumerable<SpeciesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Species.
     * 
    **/
    cursor?: SpeciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Species from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Species.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Species.
     * 
    **/
    distinct?: Enumerable<SpeciesScalarFieldEnum>
  }


  /**
   * Species findMany
   */
  export type SpeciesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Species
     * 
    **/
    select?: SpeciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpeciesInclude | null
    /**
     * Filter, which Species to fetch.
     * 
    **/
    where?: SpeciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Species to fetch.
     * 
    **/
    orderBy?: Enumerable<SpeciesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Species.
     * 
    **/
    cursor?: SpeciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Species from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Species.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SpeciesScalarFieldEnum>
  }


  /**
   * Species create
   */
  export type SpeciesCreateArgs = {
    /**
     * Select specific fields to fetch from the Species
     * 
    **/
    select?: SpeciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpeciesInclude | null
    /**
     * The data needed to create a Species.
     * 
    **/
    data: XOR<SpeciesCreateInput, SpeciesUncheckedCreateInput>
  }


  /**
   * Species createMany
   */
  export type SpeciesCreateManyArgs = {
    data: Enumerable<SpeciesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Species update
   */
  export type SpeciesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Species
     * 
    **/
    select?: SpeciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpeciesInclude | null
    /**
     * The data needed to update a Species.
     * 
    **/
    data: XOR<SpeciesUpdateInput, SpeciesUncheckedUpdateInput>
    /**
     * Choose, which Species to update.
     * 
    **/
    where: SpeciesWhereUniqueInput
  }


  /**
   * Species updateMany
   */
  export type SpeciesUpdateManyArgs = {
    data: XOR<SpeciesUpdateManyMutationInput, SpeciesUncheckedUpdateManyInput>
    where?: SpeciesWhereInput
  }


  /**
   * Species upsert
   */
  export type SpeciesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Species
     * 
    **/
    select?: SpeciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpeciesInclude | null
    /**
     * The filter to search for the Species to update in case it exists.
     * 
    **/
    where: SpeciesWhereUniqueInput
    /**
     * In case the Species found by the `where` argument doesn't exist, create a new Species with this data.
     * 
    **/
    create: XOR<SpeciesCreateInput, SpeciesUncheckedCreateInput>
    /**
     * In case the Species was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SpeciesUpdateInput, SpeciesUncheckedUpdateInput>
  }


  /**
   * Species delete
   */
  export type SpeciesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Species
     * 
    **/
    select?: SpeciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpeciesInclude | null
    /**
     * Filter which Species to delete.
     * 
    **/
    where: SpeciesWhereUniqueInput
  }


  /**
   * Species deleteMany
   */
  export type SpeciesDeleteManyArgs = {
    where?: SpeciesWhereInput
  }


  /**
   * Species without action
   */
  export type SpeciesArgs = {
    /**
     * Select specific fields to fetch from the Species
     * 
    **/
    select?: SpeciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SpeciesInclude | null
  }



  /**
   * Model Medical_Treatment
   */


  export type AggregateMedical_Treatment = {
    _count: Medical_TreatmentCountAggregateOutputType | null
    count: Medical_TreatmentCountAggregateOutputType | null
    _avg: Medical_TreatmentAvgAggregateOutputType | null
    avg: Medical_TreatmentAvgAggregateOutputType | null
    _sum: Medical_TreatmentSumAggregateOutputType | null
    sum: Medical_TreatmentSumAggregateOutputType | null
    _min: Medical_TreatmentMinAggregateOutputType | null
    min: Medical_TreatmentMinAggregateOutputType | null
    _max: Medical_TreatmentMaxAggregateOutputType | null
    max: Medical_TreatmentMaxAggregateOutputType | null
  }

  export type Medical_TreatmentAvgAggregateOutputType = {
    id: number | null
  }

  export type Medical_TreatmentSumAggregateOutputType = {
    id: number | null
  }

  export type Medical_TreatmentMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Medical_TreatmentMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Medical_TreatmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Medical_TreatmentAvgAggregateInputType = {
    id?: true
  }

  export type Medical_TreatmentSumAggregateInputType = {
    id?: true
  }

  export type Medical_TreatmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type Medical_TreatmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type Medical_TreatmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Medical_TreatmentAggregateArgs = {
    /**
     * Filter which Medical_Treatment to aggregate.
     * 
    **/
    where?: Medical_TreatmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medical_Treatments to fetch.
     * 
    **/
    orderBy?: Enumerable<Medical_TreatmentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: Medical_TreatmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medical_Treatments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medical_Treatments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Medical_Treatments
    **/
    _count?: true | Medical_TreatmentCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | Medical_TreatmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Medical_TreatmentAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: Medical_TreatmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Medical_TreatmentSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: Medical_TreatmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Medical_TreatmentMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: Medical_TreatmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Medical_TreatmentMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: Medical_TreatmentMaxAggregateInputType
  }

  export type GetMedical_TreatmentAggregateType<T extends Medical_TreatmentAggregateArgs> = {
        [P in keyof T & keyof AggregateMedical_Treatment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedical_Treatment[P]>
      : GetScalarType<T[P], AggregateMedical_Treatment[P]>
  }


    
    
  export type Medical_TreatmentGroupByArgs = {
    where?: Medical_TreatmentWhereInput
    orderBy?: Enumerable<Medical_TreatmentOrderByInput>
    by: Array<Medical_TreatmentScalarFieldEnum>
    having?: Medical_TreatmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Medical_TreatmentCountAggregateInputType | true
    _avg?: Medical_TreatmentAvgAggregateInputType
    _sum?: Medical_TreatmentSumAggregateInputType
    _min?: Medical_TreatmentMinAggregateInputType
    _max?: Medical_TreatmentMaxAggregateInputType
  }


  export type Medical_TreatmentGroupByOutputType = {
    id: number
    name: string
    description: string
    created_at: Date
    updated_at: Date
    _count: Medical_TreatmentCountAggregateOutputType | null
    _avg: Medical_TreatmentAvgAggregateOutputType | null
    _sum: Medical_TreatmentSumAggregateOutputType | null
    _min: Medical_TreatmentMinAggregateOutputType | null
    _max: Medical_TreatmentMaxAggregateOutputType | null
  }

  type GetMedical_TreatmentGroupByPayload<T extends Medical_TreatmentGroupByArgs> = Promise<
    Array<
      PickArray<Medical_TreatmentGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof Medical_TreatmentGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], Medical_TreatmentGroupByOutputType[P]> 
            : GetScalarType<T[P], Medical_TreatmentGroupByOutputType[P]>
        }
      > 
    >


  export type Medical_TreatmentSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type Medical_TreatmentGetPayload<
    S extends boolean | null | undefined | Medical_TreatmentArgs,
    U = keyof S
      > = S extends true
        ? Medical_Treatment
    : S extends undefined
    ? never
    : S extends Medical_TreatmentArgs | Medical_TreatmentFindManyArgs
    ?'include' extends U
    ? Medical_Treatment 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Medical_Treatment ?Medical_Treatment [P]
  : 
     never
  } 
    : Medical_Treatment
  : Medical_Treatment


  type Medical_TreatmentCountArgs = Merge<
    Omit<Medical_TreatmentFindManyArgs, 'select' | 'include'> & {
      select?: Medical_TreatmentCountAggregateInputType | true
    }
  >

  export interface Medical_TreatmentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Medical_Treatment that matches the filter.
     * @param {Medical_TreatmentFindUniqueArgs} args - Arguments to find a Medical_Treatment
     * @example
     * // Get one Medical_Treatment
     * const medical_Treatment = await prisma.medical_Treatment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Medical_TreatmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Medical_TreatmentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Medical_Treatment'> extends True ? CheckSelect<T, Prisma__Medical_TreatmentClient<Medical_Treatment>, Prisma__Medical_TreatmentClient<Medical_TreatmentGetPayload<T>>> : CheckSelect<T, Prisma__Medical_TreatmentClient<Medical_Treatment | null >, Prisma__Medical_TreatmentClient<Medical_TreatmentGetPayload<T> | null >>

    /**
     * Find the first Medical_Treatment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Medical_TreatmentFindFirstArgs} args - Arguments to find a Medical_Treatment
     * @example
     * // Get one Medical_Treatment
     * const medical_Treatment = await prisma.medical_Treatment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Medical_TreatmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Medical_TreatmentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Medical_Treatment'> extends True ? CheckSelect<T, Prisma__Medical_TreatmentClient<Medical_Treatment>, Prisma__Medical_TreatmentClient<Medical_TreatmentGetPayload<T>>> : CheckSelect<T, Prisma__Medical_TreatmentClient<Medical_Treatment | null >, Prisma__Medical_TreatmentClient<Medical_TreatmentGetPayload<T> | null >>

    /**
     * Find zero or more Medical_Treatments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Medical_TreatmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medical_Treatments
     * const medical_Treatments = await prisma.medical_Treatment.findMany()
     * 
     * // Get first 10 Medical_Treatments
     * const medical_Treatments = await prisma.medical_Treatment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medical_TreatmentWithIdOnly = await prisma.medical_Treatment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Medical_TreatmentFindManyArgs>(
      args?: SelectSubset<T, Medical_TreatmentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Medical_Treatment>>, PrismaPromise<Array<Medical_TreatmentGetPayload<T>>>>

    /**
     * Create a Medical_Treatment.
     * @param {Medical_TreatmentCreateArgs} args - Arguments to create a Medical_Treatment.
     * @example
     * // Create one Medical_Treatment
     * const Medical_Treatment = await prisma.medical_Treatment.create({
     *   data: {
     *     // ... data to create a Medical_Treatment
     *   }
     * })
     * 
    **/
    create<T extends Medical_TreatmentCreateArgs>(
      args: SelectSubset<T, Medical_TreatmentCreateArgs>
    ): CheckSelect<T, Prisma__Medical_TreatmentClient<Medical_Treatment>, Prisma__Medical_TreatmentClient<Medical_TreatmentGetPayload<T>>>

    /**
     * Create many Medical_Treatments.
     *     @param {Medical_TreatmentCreateManyArgs} args - Arguments to create many Medical_Treatments.
     *     @example
     *     // Create many Medical_Treatments
     *     const medical_Treatment = await prisma.medical_Treatment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Medical_TreatmentCreateManyArgs>(
      args?: SelectSubset<T, Medical_TreatmentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Medical_Treatment.
     * @param {Medical_TreatmentDeleteArgs} args - Arguments to delete one Medical_Treatment.
     * @example
     * // Delete one Medical_Treatment
     * const Medical_Treatment = await prisma.medical_Treatment.delete({
     *   where: {
     *     // ... filter to delete one Medical_Treatment
     *   }
     * })
     * 
    **/
    delete<T extends Medical_TreatmentDeleteArgs>(
      args: SelectSubset<T, Medical_TreatmentDeleteArgs>
    ): CheckSelect<T, Prisma__Medical_TreatmentClient<Medical_Treatment>, Prisma__Medical_TreatmentClient<Medical_TreatmentGetPayload<T>>>

    /**
     * Update one Medical_Treatment.
     * @param {Medical_TreatmentUpdateArgs} args - Arguments to update one Medical_Treatment.
     * @example
     * // Update one Medical_Treatment
     * const medical_Treatment = await prisma.medical_Treatment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Medical_TreatmentUpdateArgs>(
      args: SelectSubset<T, Medical_TreatmentUpdateArgs>
    ): CheckSelect<T, Prisma__Medical_TreatmentClient<Medical_Treatment>, Prisma__Medical_TreatmentClient<Medical_TreatmentGetPayload<T>>>

    /**
     * Delete zero or more Medical_Treatments.
     * @param {Medical_TreatmentDeleteManyArgs} args - Arguments to filter Medical_Treatments to delete.
     * @example
     * // Delete a few Medical_Treatments
     * const { count } = await prisma.medical_Treatment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Medical_TreatmentDeleteManyArgs>(
      args?: SelectSubset<T, Medical_TreatmentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medical_Treatments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Medical_TreatmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medical_Treatments
     * const medical_Treatment = await prisma.medical_Treatment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Medical_TreatmentUpdateManyArgs>(
      args: SelectSubset<T, Medical_TreatmentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Medical_Treatment.
     * @param {Medical_TreatmentUpsertArgs} args - Arguments to update or create a Medical_Treatment.
     * @example
     * // Update or create a Medical_Treatment
     * const medical_Treatment = await prisma.medical_Treatment.upsert({
     *   create: {
     *     // ... data to create a Medical_Treatment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medical_Treatment we want to update
     *   }
     * })
    **/
    upsert<T extends Medical_TreatmentUpsertArgs>(
      args: SelectSubset<T, Medical_TreatmentUpsertArgs>
    ): CheckSelect<T, Prisma__Medical_TreatmentClient<Medical_Treatment>, Prisma__Medical_TreatmentClient<Medical_TreatmentGetPayload<T>>>

    /**
     * Count the number of Medical_Treatments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Medical_TreatmentCountArgs} args - Arguments to filter Medical_Treatments to count.
     * @example
     * // Count the number of Medical_Treatments
     * const count = await prisma.medical_Treatment.count({
     *   where: {
     *     // ... the filter for the Medical_Treatments we want to count
     *   }
     * })
    **/
    count<T extends Medical_TreatmentCountArgs>(
      args?: Subset<T, Medical_TreatmentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Medical_TreatmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medical_Treatment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Medical_TreatmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Medical_TreatmentAggregateArgs>(args: Subset<T, Medical_TreatmentAggregateArgs>): PrismaPromise<GetMedical_TreatmentAggregateType<T>>

    /**
     * Group by Medical_Treatment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Medical_TreatmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Medical_TreatmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Medical_TreatmentGroupByArgs['orderBy'] }
        : { orderBy?: Medical_TreatmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Medical_TreatmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedical_TreatmentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Medical_Treatment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Medical_TreatmentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Medical_Treatment findUnique
   */
  export type Medical_TreatmentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Medical_Treatment
     * 
    **/
    select?: Medical_TreatmentSelect | null
    /**
     * Throw an Error if a Medical_Treatment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Medical_Treatment to fetch.
     * 
    **/
    where: Medical_TreatmentWhereUniqueInput
  }


  /**
   * Medical_Treatment findFirst
   */
  export type Medical_TreatmentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Medical_Treatment
     * 
    **/
    select?: Medical_TreatmentSelect | null
    /**
     * Throw an Error if a Medical_Treatment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Medical_Treatment to fetch.
     * 
    **/
    where?: Medical_TreatmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medical_Treatments to fetch.
     * 
    **/
    orderBy?: Enumerable<Medical_TreatmentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medical_Treatments.
     * 
    **/
    cursor?: Medical_TreatmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medical_Treatments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medical_Treatments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medical_Treatments.
     * 
    **/
    distinct?: Enumerable<Medical_TreatmentScalarFieldEnum>
  }


  /**
   * Medical_Treatment findMany
   */
  export type Medical_TreatmentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Medical_Treatment
     * 
    **/
    select?: Medical_TreatmentSelect | null
    /**
     * Filter, which Medical_Treatments to fetch.
     * 
    **/
    where?: Medical_TreatmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medical_Treatments to fetch.
     * 
    **/
    orderBy?: Enumerable<Medical_TreatmentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Medical_Treatments.
     * 
    **/
    cursor?: Medical_TreatmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medical_Treatments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medical_Treatments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Medical_TreatmentScalarFieldEnum>
  }


  /**
   * Medical_Treatment create
   */
  export type Medical_TreatmentCreateArgs = {
    /**
     * Select specific fields to fetch from the Medical_Treatment
     * 
    **/
    select?: Medical_TreatmentSelect | null
    /**
     * The data needed to create a Medical_Treatment.
     * 
    **/
    data: XOR<Medical_TreatmentCreateInput, Medical_TreatmentUncheckedCreateInput>
  }


  /**
   * Medical_Treatment createMany
   */
  export type Medical_TreatmentCreateManyArgs = {
    data: Enumerable<Medical_TreatmentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Medical_Treatment update
   */
  export type Medical_TreatmentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Medical_Treatment
     * 
    **/
    select?: Medical_TreatmentSelect | null
    /**
     * The data needed to update a Medical_Treatment.
     * 
    **/
    data: XOR<Medical_TreatmentUpdateInput, Medical_TreatmentUncheckedUpdateInput>
    /**
     * Choose, which Medical_Treatment to update.
     * 
    **/
    where: Medical_TreatmentWhereUniqueInput
  }


  /**
   * Medical_Treatment updateMany
   */
  export type Medical_TreatmentUpdateManyArgs = {
    data: XOR<Medical_TreatmentUpdateManyMutationInput, Medical_TreatmentUncheckedUpdateManyInput>
    where?: Medical_TreatmentWhereInput
  }


  /**
   * Medical_Treatment upsert
   */
  export type Medical_TreatmentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Medical_Treatment
     * 
    **/
    select?: Medical_TreatmentSelect | null
    /**
     * The filter to search for the Medical_Treatment to update in case it exists.
     * 
    **/
    where: Medical_TreatmentWhereUniqueInput
    /**
     * In case the Medical_Treatment found by the `where` argument doesn't exist, create a new Medical_Treatment with this data.
     * 
    **/
    create: XOR<Medical_TreatmentCreateInput, Medical_TreatmentUncheckedCreateInput>
    /**
     * In case the Medical_Treatment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<Medical_TreatmentUpdateInput, Medical_TreatmentUncheckedUpdateInput>
  }


  /**
   * Medical_Treatment delete
   */
  export type Medical_TreatmentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Medical_Treatment
     * 
    **/
    select?: Medical_TreatmentSelect | null
    /**
     * Filter which Medical_Treatment to delete.
     * 
    **/
    where: Medical_TreatmentWhereUniqueInput
  }


  /**
   * Medical_Treatment deleteMany
   */
  export type Medical_TreatmentDeleteManyArgs = {
    where?: Medical_TreatmentWhereInput
  }


  /**
   * Medical_Treatment without action
   */
  export type Medical_TreatmentArgs = {
    /**
     * Select specific fields to fetch from the Medical_Treatment
     * 
    **/
    select?: Medical_TreatmentSelect | null
  }



  /**
   * Model Consultations
   */


  export type AggregateConsultations = {
    _count: ConsultationsCountAggregateOutputType | null
    count: ConsultationsCountAggregateOutputType | null
    _avg: ConsultationsAvgAggregateOutputType | null
    avg: ConsultationsAvgAggregateOutputType | null
    _sum: ConsultationsSumAggregateOutputType | null
    sum: ConsultationsSumAggregateOutputType | null
    _min: ConsultationsMinAggregateOutputType | null
    min: ConsultationsMinAggregateOutputType | null
    _max: ConsultationsMaxAggregateOutputType | null
    max: ConsultationsMaxAggregateOutputType | null
  }

  export type ConsultationsAvgAggregateOutputType = {
    id: number | null
    total_payment: number | null
    rating: number | null
    user_bank_id: number | null
    vendor_bank_id: number | null
    user_address_id: number | null
  }

  export type ConsultationsSumAggregateOutputType = {
    id: number | null
    total_payment: number | null
    rating: number | null
    user_bank_id: number | null
    vendor_bank_id: number | null
    user_address_id: number | null
  }

  export type ConsultationsMinAggregateOutputType = {
    id: number | null
    uid: string | null
    user_id: string | null
    pet_id: string | null
    vendor_id: string | null
    chat_room_id: string | null
    vendor_role: Type | null
    diagnose: string | null
    prerequisite: string | null
    date: string | null
    time_start: string | null
    time_end: string | null
    order_status: string | null
    reject_reason: string | null
    total_payment: number | null
    payment_image_url: string | null
    rating: number | null
    comment: string | null
    user_bank_id: number | null
    vendor_bank_id: number | null
    user_address_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ConsultationsMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    user_id: string | null
    pet_id: string | null
    vendor_id: string | null
    chat_room_id: string | null
    vendor_role: Type | null
    diagnose: string | null
    prerequisite: string | null
    date: string | null
    time_start: string | null
    time_end: string | null
    order_status: string | null
    reject_reason: string | null
    total_payment: number | null
    payment_image_url: string | null
    rating: number | null
    comment: string | null
    user_bank_id: number | null
    vendor_bank_id: number | null
    user_address_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ConsultationsCountAggregateOutputType = {
    id: number
    uid: number
    user_id: number
    pet_id: number
    vendor_id: number
    chat_room_id: number
    vendor_role: number
    diagnose: number
    prerequisite: number
    date: number
    time_start: number
    time_end: number
    order_status: number
    reject_reason: number
    total_payment: number
    payment_image_url: number
    rating: number
    comment: number
    user_bank_id: number
    vendor_bank_id: number
    user_address_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ConsultationsAvgAggregateInputType = {
    id?: true
    total_payment?: true
    rating?: true
    user_bank_id?: true
    vendor_bank_id?: true
    user_address_id?: true
  }

  export type ConsultationsSumAggregateInputType = {
    id?: true
    total_payment?: true
    rating?: true
    user_bank_id?: true
    vendor_bank_id?: true
    user_address_id?: true
  }

  export type ConsultationsMinAggregateInputType = {
    id?: true
    uid?: true
    user_id?: true
    pet_id?: true
    vendor_id?: true
    chat_room_id?: true
    vendor_role?: true
    diagnose?: true
    prerequisite?: true
    date?: true
    time_start?: true
    time_end?: true
    order_status?: true
    reject_reason?: true
    total_payment?: true
    payment_image_url?: true
    rating?: true
    comment?: true
    user_bank_id?: true
    vendor_bank_id?: true
    user_address_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ConsultationsMaxAggregateInputType = {
    id?: true
    uid?: true
    user_id?: true
    pet_id?: true
    vendor_id?: true
    chat_room_id?: true
    vendor_role?: true
    diagnose?: true
    prerequisite?: true
    date?: true
    time_start?: true
    time_end?: true
    order_status?: true
    reject_reason?: true
    total_payment?: true
    payment_image_url?: true
    rating?: true
    comment?: true
    user_bank_id?: true
    vendor_bank_id?: true
    user_address_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ConsultationsCountAggregateInputType = {
    id?: true
    uid?: true
    user_id?: true
    pet_id?: true
    vendor_id?: true
    chat_room_id?: true
    vendor_role?: true
    diagnose?: true
    prerequisite?: true
    date?: true
    time_start?: true
    time_end?: true
    order_status?: true
    reject_reason?: true
    total_payment?: true
    payment_image_url?: true
    rating?: true
    comment?: true
    user_bank_id?: true
    vendor_bank_id?: true
    user_address_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ConsultationsAggregateArgs = {
    /**
     * Filter which Consultations to aggregate.
     * 
    **/
    where?: ConsultationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     * 
    **/
    orderBy?: Enumerable<ConsultationsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ConsultationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Consultations
    **/
    _count?: true | ConsultationsCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ConsultationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsultationsAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ConsultationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsultationsSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ConsultationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultationsMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ConsultationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultationsMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ConsultationsMaxAggregateInputType
  }

  export type GetConsultationsAggregateType<T extends ConsultationsAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultations[P]>
      : GetScalarType<T[P], AggregateConsultations[P]>
  }


    
    
  export type ConsultationsGroupByArgs = {
    where?: ConsultationsWhereInput
    orderBy?: Enumerable<ConsultationsOrderByInput>
    by: Array<ConsultationsScalarFieldEnum>
    having?: ConsultationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultationsCountAggregateInputType | true
    _avg?: ConsultationsAvgAggregateInputType
    _sum?: ConsultationsSumAggregateInputType
    _min?: ConsultationsMinAggregateInputType
    _max?: ConsultationsMaxAggregateInputType
  }


  export type ConsultationsGroupByOutputType = {
    id: number
    uid: string
    user_id: string
    pet_id: string
    vendor_id: string
    chat_room_id: string
    vendor_role: Type | null
    diagnose: string
    prerequisite: string
    date: string
    time_start: string
    time_end: string
    order_status: string
    reject_reason: string
    total_payment: number
    payment_image_url: string
    rating: number
    comment: string
    user_bank_id: number
    vendor_bank_id: number
    user_address_id: number
    created_at: Date
    updated_at: Date
    _count: ConsultationsCountAggregateOutputType | null
    _avg: ConsultationsAvgAggregateOutputType | null
    _sum: ConsultationsSumAggregateOutputType | null
    _min: ConsultationsMinAggregateOutputType | null
    _max: ConsultationsMaxAggregateOutputType | null
  }

  type GetConsultationsGroupByPayload<T extends ConsultationsGroupByArgs> = Promise<
    Array<
      PickArray<ConsultationsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ConsultationsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ConsultationsGroupByOutputType[P]> 
            : GetScalarType<T[P], ConsultationsGroupByOutputType[P]>
        }
      > 
    >


  export type ConsultationsSelect = {
    id?: boolean
    uid?: boolean
    User?: boolean | UserArgs
    user_id?: boolean
    Pet?: boolean | UserPetsArgs
    pet_id?: boolean
    vendor_id?: boolean
    chat_room_id?: boolean
    vendor_role?: boolean
    diagnose?: boolean
    prerequisite?: boolean
    date?: boolean
    time_start?: boolean
    time_end?: boolean
    order_status?: boolean
    reject_reason?: boolean
    total_payment?: boolean
    payment_image_url?: boolean
    rating?: boolean
    comment?: boolean
    user_bank_id?: boolean
    vendor_bank_id?: boolean
    user_address_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ConsultationsInclude = {
    User?: boolean | UserArgs
    Pet?: boolean | UserPetsArgs
  }

  export type ConsultationsGetPayload<
    S extends boolean | null | undefined | ConsultationsArgs,
    U = keyof S
      > = S extends true
        ? Consultations
    : S extends undefined
    ? never
    : S extends ConsultationsArgs | ConsultationsFindManyArgs
    ?'include' extends U
    ? Consultations  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'User'
        ? UserGetPayload<S['include'][P]> | null :
        P extends 'Pet'
        ? UserPetsGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Consultations ?Consultations [P]
  : 
          P extends 'User'
        ? UserGetPayload<S['select'][P]> | null :
        P extends 'Pet'
        ? UserPetsGetPayload<S['select'][P]> | null : never
  } 
    : Consultations
  : Consultations


  type ConsultationsCountArgs = Merge<
    Omit<ConsultationsFindManyArgs, 'select' | 'include'> & {
      select?: ConsultationsCountAggregateInputType | true
    }
  >

  export interface ConsultationsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Consultations that matches the filter.
     * @param {ConsultationsFindUniqueArgs} args - Arguments to find a Consultations
     * @example
     * // Get one Consultations
     * const consultations = await prisma.consultations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConsultationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ConsultationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Consultations'> extends True ? CheckSelect<T, Prisma__ConsultationsClient<Consultations>, Prisma__ConsultationsClient<ConsultationsGetPayload<T>>> : CheckSelect<T, Prisma__ConsultationsClient<Consultations | null >, Prisma__ConsultationsClient<ConsultationsGetPayload<T> | null >>

    /**
     * Find the first Consultations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationsFindFirstArgs} args - Arguments to find a Consultations
     * @example
     * // Get one Consultations
     * const consultations = await prisma.consultations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConsultationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ConsultationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Consultations'> extends True ? CheckSelect<T, Prisma__ConsultationsClient<Consultations>, Prisma__ConsultationsClient<ConsultationsGetPayload<T>>> : CheckSelect<T, Prisma__ConsultationsClient<Consultations | null >, Prisma__ConsultationsClient<ConsultationsGetPayload<T> | null >>

    /**
     * Find zero or more Consultations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consultations
     * const consultations = await prisma.consultations.findMany()
     * 
     * // Get first 10 Consultations
     * const consultations = await prisma.consultations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultationsWithIdOnly = await prisma.consultations.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConsultationsFindManyArgs>(
      args?: SelectSubset<T, ConsultationsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Consultations>>, PrismaPromise<Array<ConsultationsGetPayload<T>>>>

    /**
     * Create a Consultations.
     * @param {ConsultationsCreateArgs} args - Arguments to create a Consultations.
     * @example
     * // Create one Consultations
     * const Consultations = await prisma.consultations.create({
     *   data: {
     *     // ... data to create a Consultations
     *   }
     * })
     * 
    **/
    create<T extends ConsultationsCreateArgs>(
      args: SelectSubset<T, ConsultationsCreateArgs>
    ): CheckSelect<T, Prisma__ConsultationsClient<Consultations>, Prisma__ConsultationsClient<ConsultationsGetPayload<T>>>

    /**
     * Create many Consultations.
     *     @param {ConsultationsCreateManyArgs} args - Arguments to create many Consultations.
     *     @example
     *     // Create many Consultations
     *     const consultations = await prisma.consultations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConsultationsCreateManyArgs>(
      args?: SelectSubset<T, ConsultationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Consultations.
     * @param {ConsultationsDeleteArgs} args - Arguments to delete one Consultations.
     * @example
     * // Delete one Consultations
     * const Consultations = await prisma.consultations.delete({
     *   where: {
     *     // ... filter to delete one Consultations
     *   }
     * })
     * 
    **/
    delete<T extends ConsultationsDeleteArgs>(
      args: SelectSubset<T, ConsultationsDeleteArgs>
    ): CheckSelect<T, Prisma__ConsultationsClient<Consultations>, Prisma__ConsultationsClient<ConsultationsGetPayload<T>>>

    /**
     * Update one Consultations.
     * @param {ConsultationsUpdateArgs} args - Arguments to update one Consultations.
     * @example
     * // Update one Consultations
     * const consultations = await prisma.consultations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConsultationsUpdateArgs>(
      args: SelectSubset<T, ConsultationsUpdateArgs>
    ): CheckSelect<T, Prisma__ConsultationsClient<Consultations>, Prisma__ConsultationsClient<ConsultationsGetPayload<T>>>

    /**
     * Delete zero or more Consultations.
     * @param {ConsultationsDeleteManyArgs} args - Arguments to filter Consultations to delete.
     * @example
     * // Delete a few Consultations
     * const { count } = await prisma.consultations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConsultationsDeleteManyArgs>(
      args?: SelectSubset<T, ConsultationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consultations
     * const consultations = await prisma.consultations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConsultationsUpdateManyArgs>(
      args: SelectSubset<T, ConsultationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Consultations.
     * @param {ConsultationsUpsertArgs} args - Arguments to update or create a Consultations.
     * @example
     * // Update or create a Consultations
     * const consultations = await prisma.consultations.upsert({
     *   create: {
     *     // ... data to create a Consultations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consultations we want to update
     *   }
     * })
    **/
    upsert<T extends ConsultationsUpsertArgs>(
      args: SelectSubset<T, ConsultationsUpsertArgs>
    ): CheckSelect<T, Prisma__ConsultationsClient<Consultations>, Prisma__ConsultationsClient<ConsultationsGetPayload<T>>>

    /**
     * Count the number of Consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationsCountArgs} args - Arguments to filter Consultations to count.
     * @example
     * // Count the number of Consultations
     * const count = await prisma.consultations.count({
     *   where: {
     *     // ... the filter for the Consultations we want to count
     *   }
     * })
    **/
    count<T extends ConsultationsCountArgs>(
      args?: Subset<T, ConsultationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultationsAggregateArgs>(args: Subset<T, ConsultationsAggregateArgs>): PrismaPromise<GetConsultationsAggregateType<T>>

    /**
     * Group by Consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsultationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsultationsGroupByArgs['orderBy'] }
        : { orderBy?: ConsultationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsultationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultationsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Consultations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ConsultationsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    Pet<T extends UserPetsArgs = {}>(args?: Subset<T, UserPetsArgs>): CheckSelect<T, Prisma__UserPetsClient<UserPets | null >, Prisma__UserPetsClient<UserPetsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Consultations findUnique
   */
  export type ConsultationsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Consultations
     * 
    **/
    select?: ConsultationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConsultationsInclude | null
    /**
     * Throw an Error if a Consultations can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Consultations to fetch.
     * 
    **/
    where: ConsultationsWhereUniqueInput
  }


  /**
   * Consultations findFirst
   */
  export type ConsultationsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Consultations
     * 
    **/
    select?: ConsultationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConsultationsInclude | null
    /**
     * Throw an Error if a Consultations can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Consultations to fetch.
     * 
    **/
    where?: ConsultationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     * 
    **/
    orderBy?: Enumerable<ConsultationsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consultations.
     * 
    **/
    cursor?: ConsultationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consultations.
     * 
    **/
    distinct?: Enumerable<ConsultationsScalarFieldEnum>
  }


  /**
   * Consultations findMany
   */
  export type ConsultationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Consultations
     * 
    **/
    select?: ConsultationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConsultationsInclude | null
    /**
     * Filter, which Consultations to fetch.
     * 
    **/
    where?: ConsultationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     * 
    **/
    orderBy?: Enumerable<ConsultationsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Consultations.
     * 
    **/
    cursor?: ConsultationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ConsultationsScalarFieldEnum>
  }


  /**
   * Consultations create
   */
  export type ConsultationsCreateArgs = {
    /**
     * Select specific fields to fetch from the Consultations
     * 
    **/
    select?: ConsultationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConsultationsInclude | null
    /**
     * The data needed to create a Consultations.
     * 
    **/
    data: XOR<ConsultationsCreateInput, ConsultationsUncheckedCreateInput>
  }


  /**
   * Consultations createMany
   */
  export type ConsultationsCreateManyArgs = {
    data: Enumerable<ConsultationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Consultations update
   */
  export type ConsultationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Consultations
     * 
    **/
    select?: ConsultationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConsultationsInclude | null
    /**
     * The data needed to update a Consultations.
     * 
    **/
    data: XOR<ConsultationsUpdateInput, ConsultationsUncheckedUpdateInput>
    /**
     * Choose, which Consultations to update.
     * 
    **/
    where: ConsultationsWhereUniqueInput
  }


  /**
   * Consultations updateMany
   */
  export type ConsultationsUpdateManyArgs = {
    data: XOR<ConsultationsUpdateManyMutationInput, ConsultationsUncheckedUpdateManyInput>
    where?: ConsultationsWhereInput
  }


  /**
   * Consultations upsert
   */
  export type ConsultationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Consultations
     * 
    **/
    select?: ConsultationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConsultationsInclude | null
    /**
     * The filter to search for the Consultations to update in case it exists.
     * 
    **/
    where: ConsultationsWhereUniqueInput
    /**
     * In case the Consultations found by the `where` argument doesn't exist, create a new Consultations with this data.
     * 
    **/
    create: XOR<ConsultationsCreateInput, ConsultationsUncheckedCreateInput>
    /**
     * In case the Consultations was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ConsultationsUpdateInput, ConsultationsUncheckedUpdateInput>
  }


  /**
   * Consultations delete
   */
  export type ConsultationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Consultations
     * 
    **/
    select?: ConsultationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConsultationsInclude | null
    /**
     * Filter which Consultations to delete.
     * 
    **/
    where: ConsultationsWhereUniqueInput
  }


  /**
   * Consultations deleteMany
   */
  export type ConsultationsDeleteManyArgs = {
    where?: ConsultationsWhereInput
  }


  /**
   * Consultations without action
   */
  export type ConsultationsArgs = {
    /**
     * Select specific fields to fetch from the Consultations
     * 
    **/
    select?: ConsultationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConsultationsInclude | null
  }



  /**
   * Model Articles
   */


  export type AggregateArticles = {
    _count: ArticlesCountAggregateOutputType | null
    count: ArticlesCountAggregateOutputType | null
    _avg: ArticlesAvgAggregateOutputType | null
    avg: ArticlesAvgAggregateOutputType | null
    _sum: ArticlesSumAggregateOutputType | null
    sum: ArticlesSumAggregateOutputType | null
    _min: ArticlesMinAggregateOutputType | null
    min: ArticlesMinAggregateOutputType | null
    _max: ArticlesMaxAggregateOutputType | null
    max: ArticlesMaxAggregateOutputType | null
  }

  export type ArticlesAvgAggregateOutputType = {
    id: number | null
    species_id: number | null
  }

  export type ArticlesSumAggregateOutputType = {
    id: number | null
    species_id: number | null
  }

  export type ArticlesMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    species_id: number | null
    image_url: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ArticlesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    species_id: number | null
    image_url: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ArticlesCountAggregateOutputType = {
    id: number
    title: number
    content: number
    species_id: number
    image_url: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ArticlesAvgAggregateInputType = {
    id?: true
    species_id?: true
  }

  export type ArticlesSumAggregateInputType = {
    id?: true
    species_id?: true
  }

  export type ArticlesMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    species_id?: true
    image_url?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type ArticlesMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    species_id?: true
    image_url?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type ArticlesCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    species_id?: true
    image_url?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ArticlesAggregateArgs = {
    /**
     * Filter which Articles to aggregate.
     * 
    **/
    where?: ArticlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     * 
    **/
    orderBy?: Enumerable<ArticlesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ArticlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Articles
    **/
    _count?: true | ArticlesCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ArticlesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticlesAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ArticlesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticlesSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ArticlesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticlesMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ArticlesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticlesMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ArticlesMaxAggregateInputType
  }

  export type GetArticlesAggregateType<T extends ArticlesAggregateArgs> = {
        [P in keyof T & keyof AggregateArticles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticles[P]>
      : GetScalarType<T[P], AggregateArticles[P]>
  }


    
    
  export type ArticlesGroupByArgs = {
    where?: ArticlesWhereInput
    orderBy?: Enumerable<ArticlesOrderByInput>
    by: Array<ArticlesScalarFieldEnum>
    having?: ArticlesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticlesCountAggregateInputType | true
    _avg?: ArticlesAvgAggregateInputType
    _sum?: ArticlesSumAggregateInputType
    _min?: ArticlesMinAggregateInputType
    _max?: ArticlesMaxAggregateInputType
  }


  export type ArticlesGroupByOutputType = {
    id: number
    title: string
    content: string
    species_id: number
    image_url: string
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: ArticlesCountAggregateOutputType | null
    _avg: ArticlesAvgAggregateOutputType | null
    _sum: ArticlesSumAggregateOutputType | null
    _min: ArticlesMinAggregateOutputType | null
    _max: ArticlesMaxAggregateOutputType | null
  }

  type GetArticlesGroupByPayload<T extends ArticlesGroupByArgs> = Promise<
    Array<
      PickArray<ArticlesGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ArticlesGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ArticlesGroupByOutputType[P]> 
            : GetScalarType<T[P], ArticlesGroupByOutputType[P]>
        }
      > 
    >


  export type ArticlesSelect = {
    id?: boolean
    title?: boolean
    content?: boolean
    species?: boolean | SpeciesArgs
    species_id?: boolean
    image_url?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ArticlesInclude = {
    species?: boolean | SpeciesArgs
  }

  export type ArticlesGetPayload<
    S extends boolean | null | undefined | ArticlesArgs,
    U = keyof S
      > = S extends true
        ? Articles
    : S extends undefined
    ? never
    : S extends ArticlesArgs | ArticlesFindManyArgs
    ?'include' extends U
    ? Articles  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'species'
        ? SpeciesGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Articles ?Articles [P]
  : 
          P extends 'species'
        ? SpeciesGetPayload<S['select'][P]> : never
  } 
    : Articles
  : Articles


  type ArticlesCountArgs = Merge<
    Omit<ArticlesFindManyArgs, 'select' | 'include'> & {
      select?: ArticlesCountAggregateInputType | true
    }
  >

  export interface ArticlesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Articles that matches the filter.
     * @param {ArticlesFindUniqueArgs} args - Arguments to find a Articles
     * @example
     * // Get one Articles
     * const articles = await prisma.articles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ArticlesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ArticlesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Articles'> extends True ? CheckSelect<T, Prisma__ArticlesClient<Articles>, Prisma__ArticlesClient<ArticlesGetPayload<T>>> : CheckSelect<T, Prisma__ArticlesClient<Articles | null >, Prisma__ArticlesClient<ArticlesGetPayload<T> | null >>

    /**
     * Find the first Articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticlesFindFirstArgs} args - Arguments to find a Articles
     * @example
     * // Get one Articles
     * const articles = await prisma.articles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ArticlesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ArticlesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Articles'> extends True ? CheckSelect<T, Prisma__ArticlesClient<Articles>, Prisma__ArticlesClient<ArticlesGetPayload<T>>> : CheckSelect<T, Prisma__ArticlesClient<Articles | null >, Prisma__ArticlesClient<ArticlesGetPayload<T> | null >>

    /**
     * Find zero or more Articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticlesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Articles
     * const articles = await prisma.articles.findMany()
     * 
     * // Get first 10 Articles
     * const articles = await prisma.articles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articlesWithIdOnly = await prisma.articles.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ArticlesFindManyArgs>(
      args?: SelectSubset<T, ArticlesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Articles>>, PrismaPromise<Array<ArticlesGetPayload<T>>>>

    /**
     * Create a Articles.
     * @param {ArticlesCreateArgs} args - Arguments to create a Articles.
     * @example
     * // Create one Articles
     * const Articles = await prisma.articles.create({
     *   data: {
     *     // ... data to create a Articles
     *   }
     * })
     * 
    **/
    create<T extends ArticlesCreateArgs>(
      args: SelectSubset<T, ArticlesCreateArgs>
    ): CheckSelect<T, Prisma__ArticlesClient<Articles>, Prisma__ArticlesClient<ArticlesGetPayload<T>>>

    /**
     * Create many Articles.
     *     @param {ArticlesCreateManyArgs} args - Arguments to create many Articles.
     *     @example
     *     // Create many Articles
     *     const articles = await prisma.articles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ArticlesCreateManyArgs>(
      args?: SelectSubset<T, ArticlesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Articles.
     * @param {ArticlesDeleteArgs} args - Arguments to delete one Articles.
     * @example
     * // Delete one Articles
     * const Articles = await prisma.articles.delete({
     *   where: {
     *     // ... filter to delete one Articles
     *   }
     * })
     * 
    **/
    delete<T extends ArticlesDeleteArgs>(
      args: SelectSubset<T, ArticlesDeleteArgs>
    ): CheckSelect<T, Prisma__ArticlesClient<Articles>, Prisma__ArticlesClient<ArticlesGetPayload<T>>>

    /**
     * Update one Articles.
     * @param {ArticlesUpdateArgs} args - Arguments to update one Articles.
     * @example
     * // Update one Articles
     * const articles = await prisma.articles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ArticlesUpdateArgs>(
      args: SelectSubset<T, ArticlesUpdateArgs>
    ): CheckSelect<T, Prisma__ArticlesClient<Articles>, Prisma__ArticlesClient<ArticlesGetPayload<T>>>

    /**
     * Delete zero or more Articles.
     * @param {ArticlesDeleteManyArgs} args - Arguments to filter Articles to delete.
     * @example
     * // Delete a few Articles
     * const { count } = await prisma.articles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ArticlesDeleteManyArgs>(
      args?: SelectSubset<T, ArticlesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticlesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Articles
     * const articles = await prisma.articles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ArticlesUpdateManyArgs>(
      args: SelectSubset<T, ArticlesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Articles.
     * @param {ArticlesUpsertArgs} args - Arguments to update or create a Articles.
     * @example
     * // Update or create a Articles
     * const articles = await prisma.articles.upsert({
     *   create: {
     *     // ... data to create a Articles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Articles we want to update
     *   }
     * })
    **/
    upsert<T extends ArticlesUpsertArgs>(
      args: SelectSubset<T, ArticlesUpsertArgs>
    ): CheckSelect<T, Prisma__ArticlesClient<Articles>, Prisma__ArticlesClient<ArticlesGetPayload<T>>>

    /**
     * Count the number of Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticlesCountArgs} args - Arguments to filter Articles to count.
     * @example
     * // Count the number of Articles
     * const count = await prisma.articles.count({
     *   where: {
     *     // ... the filter for the Articles we want to count
     *   }
     * })
    **/
    count<T extends ArticlesCountArgs>(
      args?: Subset<T, ArticlesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticlesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticlesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticlesAggregateArgs>(args: Subset<T, ArticlesAggregateArgs>): PrismaPromise<GetArticlesAggregateType<T>>

    /**
     * Group by Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticlesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticlesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticlesGroupByArgs['orderBy'] }
        : { orderBy?: ArticlesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticlesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticlesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Articles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ArticlesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    species<T extends SpeciesArgs = {}>(args?: Subset<T, SpeciesArgs>): CheckSelect<T, Prisma__SpeciesClient<Species | null >, Prisma__SpeciesClient<SpeciesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Articles findUnique
   */
  export type ArticlesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Articles
     * 
    **/
    select?: ArticlesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ArticlesInclude | null
    /**
     * Throw an Error if a Articles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Articles to fetch.
     * 
    **/
    where: ArticlesWhereUniqueInput
  }


  /**
   * Articles findFirst
   */
  export type ArticlesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Articles
     * 
    **/
    select?: ArticlesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ArticlesInclude | null
    /**
     * Throw an Error if a Articles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Articles to fetch.
     * 
    **/
    where?: ArticlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     * 
    **/
    orderBy?: Enumerable<ArticlesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     * 
    **/
    cursor?: ArticlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     * 
    **/
    distinct?: Enumerable<ArticlesScalarFieldEnum>
  }


  /**
   * Articles findMany
   */
  export type ArticlesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Articles
     * 
    **/
    select?: ArticlesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ArticlesInclude | null
    /**
     * Filter, which Articles to fetch.
     * 
    **/
    where?: ArticlesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     * 
    **/
    orderBy?: Enumerable<ArticlesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Articles.
     * 
    **/
    cursor?: ArticlesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ArticlesScalarFieldEnum>
  }


  /**
   * Articles create
   */
  export type ArticlesCreateArgs = {
    /**
     * Select specific fields to fetch from the Articles
     * 
    **/
    select?: ArticlesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ArticlesInclude | null
    /**
     * The data needed to create a Articles.
     * 
    **/
    data: XOR<ArticlesCreateInput, ArticlesUncheckedCreateInput>
  }


  /**
   * Articles createMany
   */
  export type ArticlesCreateManyArgs = {
    data: Enumerable<ArticlesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Articles update
   */
  export type ArticlesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Articles
     * 
    **/
    select?: ArticlesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ArticlesInclude | null
    /**
     * The data needed to update a Articles.
     * 
    **/
    data: XOR<ArticlesUpdateInput, ArticlesUncheckedUpdateInput>
    /**
     * Choose, which Articles to update.
     * 
    **/
    where: ArticlesWhereUniqueInput
  }


  /**
   * Articles updateMany
   */
  export type ArticlesUpdateManyArgs = {
    data: XOR<ArticlesUpdateManyMutationInput, ArticlesUncheckedUpdateManyInput>
    where?: ArticlesWhereInput
  }


  /**
   * Articles upsert
   */
  export type ArticlesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Articles
     * 
    **/
    select?: ArticlesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ArticlesInclude | null
    /**
     * The filter to search for the Articles to update in case it exists.
     * 
    **/
    where: ArticlesWhereUniqueInput
    /**
     * In case the Articles found by the `where` argument doesn't exist, create a new Articles with this data.
     * 
    **/
    create: XOR<ArticlesCreateInput, ArticlesUncheckedCreateInput>
    /**
     * In case the Articles was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ArticlesUpdateInput, ArticlesUncheckedUpdateInput>
  }


  /**
   * Articles delete
   */
  export type ArticlesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Articles
     * 
    **/
    select?: ArticlesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ArticlesInclude | null
    /**
     * Filter which Articles to delete.
     * 
    **/
    where: ArticlesWhereUniqueInput
  }


  /**
   * Articles deleteMany
   */
  export type ArticlesDeleteManyArgs = {
    where?: ArticlesWhereInput
  }


  /**
   * Articles without action
   */
  export type ArticlesArgs = {
    /**
     * Select specific fields to fetch from the Articles
     * 
    **/
    select?: ArticlesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ArticlesInclude | null
  }



  /**
   * Model Feedbacks
   */


  export type AggregateFeedbacks = {
    _count: FeedbacksCountAggregateOutputType | null
    count: FeedbacksCountAggregateOutputType | null
    _avg: FeedbacksAvgAggregateOutputType | null
    avg: FeedbacksAvgAggregateOutputType | null
    _sum: FeedbacksSumAggregateOutputType | null
    sum: FeedbacksSumAggregateOutputType | null
    _min: FeedbacksMinAggregateOutputType | null
    min: FeedbacksMinAggregateOutputType | null
    _max: FeedbacksMaxAggregateOutputType | null
    max: FeedbacksMaxAggregateOutputType | null
  }

  export type FeedbacksAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    rating: number | null
  }

  export type FeedbacksSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    rating: number | null
  }

  export type FeedbacksMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    vendor_id: string | null
    email: string | null
    title: string | null
    content: string | null
    rating: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FeedbacksMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    vendor_id: string | null
    email: string | null
    title: string | null
    content: string | null
    rating: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FeedbacksCountAggregateOutputType = {
    id: number
    user_id: number
    vendor_id: number
    email: number
    title: number
    content: number
    rating: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type FeedbacksAvgAggregateInputType = {
    id?: true
    user_id?: true
    rating?: true
  }

  export type FeedbacksSumAggregateInputType = {
    id?: true
    user_id?: true
    rating?: true
  }

  export type FeedbacksMinAggregateInputType = {
    id?: true
    user_id?: true
    vendor_id?: true
    email?: true
    title?: true
    content?: true
    rating?: true
    created_at?: true
    updated_at?: true
  }

  export type FeedbacksMaxAggregateInputType = {
    id?: true
    user_id?: true
    vendor_id?: true
    email?: true
    title?: true
    content?: true
    rating?: true
    created_at?: true
    updated_at?: true
  }

  export type FeedbacksCountAggregateInputType = {
    id?: true
    user_id?: true
    vendor_id?: true
    email?: true
    title?: true
    content?: true
    rating?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type FeedbacksAggregateArgs = {
    /**
     * Filter which Feedbacks to aggregate.
     * 
    **/
    where?: FeedbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     * 
    **/
    orderBy?: Enumerable<FeedbacksOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FeedbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbacksCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | FeedbacksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbacksAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: FeedbacksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbacksSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: FeedbacksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbacksMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: FeedbacksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbacksMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: FeedbacksMaxAggregateInputType
  }

  export type GetFeedbacksAggregateType<T extends FeedbacksAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedbacks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedbacks[P]>
      : GetScalarType<T[P], AggregateFeedbacks[P]>
  }


    
    
  export type FeedbacksGroupByArgs = {
    where?: FeedbacksWhereInput
    orderBy?: Enumerable<FeedbacksOrderByInput>
    by: Array<FeedbacksScalarFieldEnum>
    having?: FeedbacksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbacksCountAggregateInputType | true
    _avg?: FeedbacksAvgAggregateInputType
    _sum?: FeedbacksSumAggregateInputType
    _min?: FeedbacksMinAggregateInputType
    _max?: FeedbacksMaxAggregateInputType
  }


  export type FeedbacksGroupByOutputType = {
    id: number
    user_id: number
    vendor_id: string
    email: string
    title: string
    content: string
    rating: number
    created_at: Date
    updated_at: Date
    _count: FeedbacksCountAggregateOutputType | null
    _avg: FeedbacksAvgAggregateOutputType | null
    _sum: FeedbacksSumAggregateOutputType | null
    _min: FeedbacksMinAggregateOutputType | null
    _max: FeedbacksMaxAggregateOutputType | null
  }

  type GetFeedbacksGroupByPayload<T extends FeedbacksGroupByArgs> = Promise<
    Array<
      PickArray<FeedbacksGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof FeedbacksGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], FeedbacksGroupByOutputType[P]> 
            : GetScalarType<T[P], FeedbacksGroupByOutputType[P]>
        }
      > 
    >


  export type FeedbacksSelect = {
    id?: boolean
    user_id?: boolean
    Vendor?: boolean | VendorsArgs
    vendor_id?: boolean
    email?: boolean
    title?: boolean
    content?: boolean
    rating?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type FeedbacksInclude = {
    Vendor?: boolean | VendorsArgs
  }

  export type FeedbacksGetPayload<
    S extends boolean | null | undefined | FeedbacksArgs,
    U = keyof S
      > = S extends true
        ? Feedbacks
    : S extends undefined
    ? never
    : S extends FeedbacksArgs | FeedbacksFindManyArgs
    ?'include' extends U
    ? Feedbacks  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Vendor'
        ? VendorsGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Feedbacks ?Feedbacks [P]
  : 
          P extends 'Vendor'
        ? VendorsGetPayload<S['select'][P]> | null : never
  } 
    : Feedbacks
  : Feedbacks


  type FeedbacksCountArgs = Merge<
    Omit<FeedbacksFindManyArgs, 'select' | 'include'> & {
      select?: FeedbacksCountAggregateInputType | true
    }
  >

  export interface FeedbacksDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Feedbacks that matches the filter.
     * @param {FeedbacksFindUniqueArgs} args - Arguments to find a Feedbacks
     * @example
     * // Get one Feedbacks
     * const feedbacks = await prisma.feedbacks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeedbacksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FeedbacksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Feedbacks'> extends True ? CheckSelect<T, Prisma__FeedbacksClient<Feedbacks>, Prisma__FeedbacksClient<FeedbacksGetPayload<T>>> : CheckSelect<T, Prisma__FeedbacksClient<Feedbacks | null >, Prisma__FeedbacksClient<FeedbacksGetPayload<T> | null >>

    /**
     * Find the first Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbacksFindFirstArgs} args - Arguments to find a Feedbacks
     * @example
     * // Get one Feedbacks
     * const feedbacks = await prisma.feedbacks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeedbacksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FeedbacksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Feedbacks'> extends True ? CheckSelect<T, Prisma__FeedbacksClient<Feedbacks>, Prisma__FeedbacksClient<FeedbacksGetPayload<T>>> : CheckSelect<T, Prisma__FeedbacksClient<Feedbacks | null >, Prisma__FeedbacksClient<FeedbacksGetPayload<T> | null >>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbacksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedbacks.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedbacks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbacksWithIdOnly = await prisma.feedbacks.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FeedbacksFindManyArgs>(
      args?: SelectSubset<T, FeedbacksFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Feedbacks>>, PrismaPromise<Array<FeedbacksGetPayload<T>>>>

    /**
     * Create a Feedbacks.
     * @param {FeedbacksCreateArgs} args - Arguments to create a Feedbacks.
     * @example
     * // Create one Feedbacks
     * const Feedbacks = await prisma.feedbacks.create({
     *   data: {
     *     // ... data to create a Feedbacks
     *   }
     * })
     * 
    **/
    create<T extends FeedbacksCreateArgs>(
      args: SelectSubset<T, FeedbacksCreateArgs>
    ): CheckSelect<T, Prisma__FeedbacksClient<Feedbacks>, Prisma__FeedbacksClient<FeedbacksGetPayload<T>>>

    /**
     * Create many Feedbacks.
     *     @param {FeedbacksCreateManyArgs} args - Arguments to create many Feedbacks.
     *     @example
     *     // Create many Feedbacks
     *     const feedbacks = await prisma.feedbacks.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeedbacksCreateManyArgs>(
      args?: SelectSubset<T, FeedbacksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Feedbacks.
     * @param {FeedbacksDeleteArgs} args - Arguments to delete one Feedbacks.
     * @example
     * // Delete one Feedbacks
     * const Feedbacks = await prisma.feedbacks.delete({
     *   where: {
     *     // ... filter to delete one Feedbacks
     *   }
     * })
     * 
    **/
    delete<T extends FeedbacksDeleteArgs>(
      args: SelectSubset<T, FeedbacksDeleteArgs>
    ): CheckSelect<T, Prisma__FeedbacksClient<Feedbacks>, Prisma__FeedbacksClient<FeedbacksGetPayload<T>>>

    /**
     * Update one Feedbacks.
     * @param {FeedbacksUpdateArgs} args - Arguments to update one Feedbacks.
     * @example
     * // Update one Feedbacks
     * const feedbacks = await prisma.feedbacks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeedbacksUpdateArgs>(
      args: SelectSubset<T, FeedbacksUpdateArgs>
    ): CheckSelect<T, Prisma__FeedbacksClient<Feedbacks>, Prisma__FeedbacksClient<FeedbacksGetPayload<T>>>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbacksDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedbacks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeedbacksDeleteManyArgs>(
      args?: SelectSubset<T, FeedbacksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbacksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedbacks = await prisma.feedbacks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeedbacksUpdateManyArgs>(
      args: SelectSubset<T, FeedbacksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Feedbacks.
     * @param {FeedbacksUpsertArgs} args - Arguments to update or create a Feedbacks.
     * @example
     * // Update or create a Feedbacks
     * const feedbacks = await prisma.feedbacks.upsert({
     *   create: {
     *     // ... data to create a Feedbacks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedbacks we want to update
     *   }
     * })
    **/
    upsert<T extends FeedbacksUpsertArgs>(
      args: SelectSubset<T, FeedbacksUpsertArgs>
    ): CheckSelect<T, Prisma__FeedbacksClient<Feedbacks>, Prisma__FeedbacksClient<FeedbacksGetPayload<T>>>

    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbacksCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedbacks.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbacksCountArgs>(
      args?: Subset<T, FeedbacksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbacksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbacksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbacksAggregateArgs>(args: Subset<T, FeedbacksAggregateArgs>): PrismaPromise<GetFeedbacksAggregateType<T>>

    /**
     * Group by Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbacksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbacksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbacksGroupByArgs['orderBy'] }
        : { orderBy?: FeedbacksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbacksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbacksGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedbacks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FeedbacksClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Vendor<T extends VendorsArgs = {}>(args?: Subset<T, VendorsArgs>): CheckSelect<T, Prisma__VendorsClient<Vendors | null >, Prisma__VendorsClient<VendorsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Feedbacks findUnique
   */
  export type FeedbacksFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Feedbacks
     * 
    **/
    select?: FeedbacksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbacksInclude | null
    /**
     * Throw an Error if a Feedbacks can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Feedbacks to fetch.
     * 
    **/
    where: FeedbacksWhereUniqueInput
  }


  /**
   * Feedbacks findFirst
   */
  export type FeedbacksFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Feedbacks
     * 
    **/
    select?: FeedbacksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbacksInclude | null
    /**
     * Throw an Error if a Feedbacks can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Feedbacks to fetch.
     * 
    **/
    where?: FeedbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     * 
    **/
    orderBy?: Enumerable<FeedbacksOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     * 
    **/
    cursor?: FeedbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     * 
    **/
    distinct?: Enumerable<FeedbacksScalarFieldEnum>
  }


  /**
   * Feedbacks findMany
   */
  export type FeedbacksFindManyArgs = {
    /**
     * Select specific fields to fetch from the Feedbacks
     * 
    **/
    select?: FeedbacksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbacksInclude | null
    /**
     * Filter, which Feedbacks to fetch.
     * 
    **/
    where?: FeedbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     * 
    **/
    orderBy?: Enumerable<FeedbacksOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     * 
    **/
    cursor?: FeedbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FeedbacksScalarFieldEnum>
  }


  /**
   * Feedbacks create
   */
  export type FeedbacksCreateArgs = {
    /**
     * Select specific fields to fetch from the Feedbacks
     * 
    **/
    select?: FeedbacksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbacksInclude | null
    /**
     * The data needed to create a Feedbacks.
     * 
    **/
    data: XOR<FeedbacksCreateInput, FeedbacksUncheckedCreateInput>
  }


  /**
   * Feedbacks createMany
   */
  export type FeedbacksCreateManyArgs = {
    data: Enumerable<FeedbacksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Feedbacks update
   */
  export type FeedbacksUpdateArgs = {
    /**
     * Select specific fields to fetch from the Feedbacks
     * 
    **/
    select?: FeedbacksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbacksInclude | null
    /**
     * The data needed to update a Feedbacks.
     * 
    **/
    data: XOR<FeedbacksUpdateInput, FeedbacksUncheckedUpdateInput>
    /**
     * Choose, which Feedbacks to update.
     * 
    **/
    where: FeedbacksWhereUniqueInput
  }


  /**
   * Feedbacks updateMany
   */
  export type FeedbacksUpdateManyArgs = {
    data: XOR<FeedbacksUpdateManyMutationInput, FeedbacksUncheckedUpdateManyInput>
    where?: FeedbacksWhereInput
  }


  /**
   * Feedbacks upsert
   */
  export type FeedbacksUpsertArgs = {
    /**
     * Select specific fields to fetch from the Feedbacks
     * 
    **/
    select?: FeedbacksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbacksInclude | null
    /**
     * The filter to search for the Feedbacks to update in case it exists.
     * 
    **/
    where: FeedbacksWhereUniqueInput
    /**
     * In case the Feedbacks found by the `where` argument doesn't exist, create a new Feedbacks with this data.
     * 
    **/
    create: XOR<FeedbacksCreateInput, FeedbacksUncheckedCreateInput>
    /**
     * In case the Feedbacks was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FeedbacksUpdateInput, FeedbacksUncheckedUpdateInput>
  }


  /**
   * Feedbacks delete
   */
  export type FeedbacksDeleteArgs = {
    /**
     * Select specific fields to fetch from the Feedbacks
     * 
    **/
    select?: FeedbacksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbacksInclude | null
    /**
     * Filter which Feedbacks to delete.
     * 
    **/
    where: FeedbacksWhereUniqueInput
  }


  /**
   * Feedbacks deleteMany
   */
  export type FeedbacksDeleteManyArgs = {
    where?: FeedbacksWhereInput
  }


  /**
   * Feedbacks without action
   */
  export type FeedbacksArgs = {
    /**
     * Select specific fields to fetch from the Feedbacks
     * 
    **/
    select?: FeedbacksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbacksInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ProvinceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProvinceScalarFieldEnum = (typeof ProvinceScalarFieldEnum)[keyof typeof ProvinceScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    province_id: 'province_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    email: 'email',
    name: 'name',
    username: 'username',
    phone_number: 'phone_number',
    profile_picture_url: 'profile_picture_url',
    gender: 'gender',
    birthdate: 'birthdate',
    password: 'password',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AdminsScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    email: 'email',
    name: 'name',
    username: 'username',
    phone_number: 'phone_number',
    profile_picture_url: 'profile_picture_url',
    gender: 'gender',
    password: 'password',
    is_active: 'is_active',
    created_at: 'created_at'
  };

  export type AdminsScalarFieldEnum = (typeof AdminsScalarFieldEnum)[keyof typeof AdminsScalarFieldEnum]


  export const TokenScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    valid: 'valid',
    expiration: 'expiration',
    AdminsId: 'AdminsId'
  };

  export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]


  export const UserPetsScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    name: 'name',
    species: 'species',
    breed: 'breed',
    date_of_birth: 'date_of_birth',
    color: 'color',
    profile_picture_url: 'profile_picture_url',
    gender: 'gender',
    is_neutered: 'is_neutered',
    is_dog_friendly: 'is_dog_friendly',
    is_cat_friendly: 'is_cat_friendly',
    is_under_10_child_friendly: 'is_under_10_child_friendly',
    is_over_10_child_friendly: 'is_over_10_child_friendly',
    is_microchipped: 'is_microchipped',
    is_purebred: 'is_purebred',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    UserId: 'UserId'
  };

  export type UserPetsScalarFieldEnum = (typeof UserPetsScalarFieldEnum)[keyof typeof UserPetsScalarFieldEnum]


  export const User_AddressScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    label: 'label',
    address: 'address',
    is_default: 'is_default',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    city_id: 'city_id',
    province_id: 'province_id',
    user_id: 'user_id'
  };

  export type User_AddressScalarFieldEnum = (typeof User_AddressScalarFieldEnum)[keyof typeof User_AddressScalarFieldEnum]


  export const User_BankScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    alias: 'alias',
    bank_name: 'bank_name',
    account_number: 'account_number',
    bank_username: 'bank_username',
    is_default: 'is_default',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    UserId: 'UserId'
  };

  export type User_BankScalarFieldEnum = (typeof User_BankScalarFieldEnum)[keyof typeof User_BankScalarFieldEnum]


  export const Vendor_BankScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    alias: 'alias',
    bank_name: 'bank_name',
    account_number: 'account_number',
    bank_username: 'bank_username',
    is_default: 'is_default',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Vendor_BankScalarFieldEnum = (typeof Vendor_BankScalarFieldEnum)[keyof typeof Vendor_BankScalarFieldEnum]


  export const VaccineTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VaccineTypeScalarFieldEnum = (typeof VaccineTypeScalarFieldEnum)[keyof typeof VaccineTypeScalarFieldEnum]


  export const VaccineHistoryScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    pet_id: 'pet_id',
    veterinary: 'veterinary',
    vaccine_photo: 'vaccine_photo',
    date_administered: 'date_administered',
    is_manual: 'is_manual',
    date_valid_until: 'date_valid_until',
    vaccine_type_id: 'vaccine_type_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VaccineHistoryScalarFieldEnum = (typeof VaccineHistoryScalarFieldEnum)[keyof typeof VaccineHistoryScalarFieldEnum]


  export const VaccineHistoryPhotoScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    vaccine_history_id: 'vaccine_history_id',
    path: 'path',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VaccineHistoryPhotoScalarFieldEnum = (typeof VaccineHistoryPhotoScalarFieldEnum)[keyof typeof VaccineHistoryPhotoScalarFieldEnum]


  export const VendorsScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    email: 'email',
    is_verified: 'is_verified',
    vendor_role: 'vendor_role',
    price: 'price',
    total_patient: 'total_patient',
    rating: 'rating',
    name: 'name',
    username: 'username',
    address: 'address',
    phone_number: 'phone_number',
    profile_picture_url: 'profile_picture_url',
    gender: 'gender',
    speciality: 'speciality',
    birthdate: 'birthdate',
    google_maps_url: 'google_maps_url',
    str_number: 'str_number',
    str_issued_date: 'str_issued_date',
    alumni: 'alumni',
    city_id: 'city_id',
    province_id: 'province_id',
    lat: 'lat',
    long: 'long',
    days: 'days',
    ops_start_time: 'ops_start_time',
    ops_end_time: 'ops_end_time',
    duration: 'duration',
    rest: 'rest',
    total_poli: 'total_poli',
    image_url: 'image_url',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VendorsScalarFieldEnum = (typeof VendorsScalarFieldEnum)[keyof typeof VendorsScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    time_start: 'time_start',
    time_end: 'time_end',
    day_start: 'day_start',
    day_end: 'day_end',
    homecare_customer_limit: 'homecare_customer_limit',
    price: 'price',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const Vendor_DocumentsScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    document_type: 'document_type',
    document_path: 'document_path',
    created_at: 'created_at',
    updated_at: 'updated_at',
    VendorsId: 'VendorsId'
  };

  export type Vendor_DocumentsScalarFieldEnum = (typeof Vendor_DocumentsScalarFieldEnum)[keyof typeof Vendor_DocumentsScalarFieldEnum]


  export const Vendor_MedtreatsScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    medical_treatment_id: 'medical_treatment_id',
    is_homecare: 'is_homecare',
    created_at: 'created_at',
    updated_at: 'updated_at',
    VendorsId: 'VendorsId'
  };

  export type Vendor_MedtreatsScalarFieldEnum = (typeof Vendor_MedtreatsScalarFieldEnum)[keyof typeof Vendor_MedtreatsScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const SpeciesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    ClassId: 'ClassId'
  };

  export type SpeciesScalarFieldEnum = (typeof SpeciesScalarFieldEnum)[keyof typeof SpeciesScalarFieldEnum]


  export const Medical_TreatmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Medical_TreatmentScalarFieldEnum = (typeof Medical_TreatmentScalarFieldEnum)[keyof typeof Medical_TreatmentScalarFieldEnum]


  export const ConsultationsScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    user_id: 'user_id',
    pet_id: 'pet_id',
    vendor_id: 'vendor_id',
    chat_room_id: 'chat_room_id',
    vendor_role: 'vendor_role',
    diagnose: 'diagnose',
    prerequisite: 'prerequisite',
    date: 'date',
    time_start: 'time_start',
    time_end: 'time_end',
    order_status: 'order_status',
    reject_reason: 'reject_reason',
    total_payment: 'total_payment',
    payment_image_url: 'payment_image_url',
    rating: 'rating',
    comment: 'comment',
    user_bank_id: 'user_bank_id',
    vendor_bank_id: 'vendor_bank_id',
    user_address_id: 'user_address_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ConsultationsScalarFieldEnum = (typeof ConsultationsScalarFieldEnum)[keyof typeof ConsultationsScalarFieldEnum]


  export const ArticlesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    species_id: 'species_id',
    image_url: 'image_url',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ArticlesScalarFieldEnum = (typeof ArticlesScalarFieldEnum)[keyof typeof ArticlesScalarFieldEnum]


  export const FeedbacksScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    vendor_id: 'vendor_id',
    email: 'email',
    title: 'title',
    content: 'content',
    rating: 'rating',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type FeedbacksScalarFieldEnum = (typeof FeedbacksScalarFieldEnum)[keyof typeof FeedbacksScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type ProvinceWhereInput = {
    AND?: Enumerable<ProvinceWhereInput>
    OR?: Enumerable<ProvinceWhereInput>
    NOT?: Enumerable<ProvinceWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    City?: CityListRelationFilter
    User_Address?: User_AddressListRelationFilter
  }

  export type ProvinceOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProvinceWhereUniqueInput = {
    id?: number
  }

  export type ProvinceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProvinceScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProvinceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProvinceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CityWhereInput = {
    AND?: Enumerable<CityWhereInput>
    OR?: Enumerable<CityWhereInput>
    NOT?: Enumerable<CityWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    Province?: XOR<ProvinceRelationFilter, ProvinceWhereInput> | null
    province_id?: IntNullableFilter | number | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    User_Address?: User_AddressListRelationFilter
  }

  export type CityOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    province_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CityWhereUniqueInput = {
    id?: number
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CityScalarWhereWithAggregatesInput>
    OR?: Enumerable<CityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CityScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    province_id?: IntNullableWithAggregatesFilter | number | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    email?: StringFilter | string
    name?: StringNullableFilter | string | null
    username?: StringNullableFilter | string | null
    phone_number?: StringNullableFilter | string | null
    profile_picture_url?: StringNullableFilter | string | null
    gender?: EnumGenderNullableFilter | Gender | null
    birthdate?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    is_active?: BoolNullableFilter | boolean | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
    user_address?: User_AddressListRelationFilter
    user_bank?: User_BankListRelationFilter
    user_pets?: UserPetsListRelationFilter
    Consultations?: ConsultationsListRelationFilter
  }

  export type UserOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    email?: SortOrder
    name?: SortOrder
    username?: SortOrder
    phone_number?: SortOrder
    profile_picture_url?: SortOrder
    gender?: SortOrder
    birthdate?: SortOrder
    password?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type UserWhereUniqueInput = {
    id?: number
    uid?: string
    email?: string
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    username?: StringNullableWithAggregatesFilter | string | null
    phone_number?: StringNullableWithAggregatesFilter | string | null
    profile_picture_url?: StringNullableWithAggregatesFilter | string | null
    gender?: EnumGenderNullableWithAggregatesFilter | Gender | null
    birthdate?: StringNullableWithAggregatesFilter | string | null
    password?: StringNullableWithAggregatesFilter | string | null
    is_active?: BoolNullableWithAggregatesFilter | boolean | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type AdminsWhereInput = {
    AND?: Enumerable<AdminsWhereInput>
    OR?: Enumerable<AdminsWhereInput>
    NOT?: Enumerable<AdminsWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    email?: StringFilter | string
    name?: StringNullableFilter | string | null
    username?: StringNullableFilter | string | null
    phone_number?: StringNullableFilter | string | null
    profile_picture_url?: StringNullableFilter | string | null
    gender?: EnumGenderNullableFilter | Gender | null
    password?: StringNullableFilter | string | null
    tokens?: TokenListRelationFilter
    is_active?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
  }

  export type AdminsOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    email?: SortOrder
    name?: SortOrder
    username?: SortOrder
    phone_number?: SortOrder
    profile_picture_url?: SortOrder
    gender?: SortOrder
    password?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
  }

  export type AdminsWhereUniqueInput = {
    id?: number
    uid?: string
    email?: string
  }

  export type AdminsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AdminsScalarWhereWithAggregatesInput>
    OR?: Enumerable<AdminsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AdminsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    username?: StringNullableWithAggregatesFilter | string | null
    phone_number?: StringNullableWithAggregatesFilter | string | null
    profile_picture_url?: StringNullableWithAggregatesFilter | string | null
    gender?: EnumGenderNullableWithAggregatesFilter | Gender | null
    password?: StringNullableWithAggregatesFilter | string | null
    is_active?: BoolWithAggregatesFilter | boolean
    created_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TokenWhereInput = {
    AND?: Enumerable<TokenWhereInput>
    OR?: Enumerable<TokenWhereInput>
    NOT?: Enumerable<TokenWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    valid?: BoolFilter | boolean
    expiration?: DateTimeFilter | Date | string
    Admins?: XOR<AdminsRelationFilter, AdminsWhereInput>
    AdminsId?: IntFilter | number
  }

  export type TokenOrderByInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    valid?: SortOrder
    expiration?: SortOrder
    AdminsId?: SortOrder
  }

  export type TokenWhereUniqueInput = {
    id?: number
  }

  export type TokenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TokenScalarWhereWithAggregatesInput>
    OR?: Enumerable<TokenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TokenScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    valid?: BoolWithAggregatesFilter | boolean
    expiration?: DateTimeWithAggregatesFilter | Date | string
    AdminsId?: IntWithAggregatesFilter | number
  }

  export type UserPetsWhereInput = {
    AND?: Enumerable<UserPetsWhereInput>
    OR?: Enumerable<UserPetsWhereInput>
    NOT?: Enumerable<UserPetsWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    name?: StringFilter | string
    species?: StringNullableFilter | string | null
    breed?: StringNullableFilter | string | null
    date_of_birth?: DateTimeNullableFilter | Date | string | null
    color?: StringNullableFilter | string | null
    profile_picture_url?: StringNullableFilter | string | null
    gender?: EnumGenderNullableFilter | Gender | null
    is_neutered?: BoolNullableFilter | boolean | null
    is_dog_friendly?: BoolNullableFilter | boolean | null
    is_cat_friendly?: BoolNullableFilter | boolean | null
    is_under_10_child_friendly?: BoolNullableFilter | boolean | null
    is_over_10_child_friendly?: BoolNullableFilter | boolean | null
    is_microchipped?: BoolNullableFilter | boolean | null
    is_purebred?: BoolNullableFilter | boolean | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
    User?: XOR<UserRelationFilter, UserWhereInput>
    UserId?: StringFilter | string
    VaccineHistory?: VaccineHistoryListRelationFilter
    Consultations?: ConsultationsListRelationFilter
  }

  export type UserPetsOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    name?: SortOrder
    species?: SortOrder
    breed?: SortOrder
    date_of_birth?: SortOrder
    color?: SortOrder
    profile_picture_url?: SortOrder
    gender?: SortOrder
    is_neutered?: SortOrder
    is_dog_friendly?: SortOrder
    is_cat_friendly?: SortOrder
    is_under_10_child_friendly?: SortOrder
    is_over_10_child_friendly?: SortOrder
    is_microchipped?: SortOrder
    is_purebred?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    UserId?: SortOrder
  }

  export type UserPetsWhereUniqueInput = {
    id?: number
    uid?: string
  }

  export type UserPetsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserPetsScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserPetsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserPetsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    species?: StringNullableWithAggregatesFilter | string | null
    breed?: StringNullableWithAggregatesFilter | string | null
    date_of_birth?: DateTimeNullableWithAggregatesFilter | Date | string | null
    color?: StringNullableWithAggregatesFilter | string | null
    profile_picture_url?: StringNullableWithAggregatesFilter | string | null
    gender?: EnumGenderNullableWithAggregatesFilter | Gender | null
    is_neutered?: BoolNullableWithAggregatesFilter | boolean | null
    is_dog_friendly?: BoolNullableWithAggregatesFilter | boolean | null
    is_cat_friendly?: BoolNullableWithAggregatesFilter | boolean | null
    is_under_10_child_friendly?: BoolNullableWithAggregatesFilter | boolean | null
    is_over_10_child_friendly?: BoolNullableWithAggregatesFilter | boolean | null
    is_microchipped?: BoolNullableWithAggregatesFilter | boolean | null
    is_purebred?: BoolNullableWithAggregatesFilter | boolean | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    UserId?: StringWithAggregatesFilter | string
  }

  export type User_AddressWhereInput = {
    AND?: Enumerable<User_AddressWhereInput>
    OR?: Enumerable<User_AddressWhereInput>
    NOT?: Enumerable<User_AddressWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    label?: StringFilter | string
    address?: StringFilter | string
    is_default?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeNullableFilter | Date | string | null
    City?: XOR<CityRelationFilter, CityWhereInput> | null
    city_id?: IntNullableFilter | number | null
    Province?: XOR<ProvinceRelationFilter, ProvinceWhereInput> | null
    province_id?: IntNullableFilter | number | null
    User?: XOR<UserRelationFilter, UserWhereInput>
    user_id?: StringFilter | string
  }

  export type User_AddressOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    label?: SortOrder
    address?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    city_id?: SortOrder
    province_id?: SortOrder
    user_id?: SortOrder
  }

  export type User_AddressWhereUniqueInput = {
    id?: number
    uid?: string
  }

  export type User_AddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<User_AddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<User_AddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<User_AddressScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    label?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    is_default?: BoolWithAggregatesFilter | boolean
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    city_id?: IntNullableWithAggregatesFilter | number | null
    province_id?: IntNullableWithAggregatesFilter | number | null
    user_id?: StringWithAggregatesFilter | string
  }

  export type User_BankWhereInput = {
    AND?: Enumerable<User_BankWhereInput>
    OR?: Enumerable<User_BankWhereInput>
    NOT?: Enumerable<User_BankWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    alias?: StringFilter | string
    bank_name?: StringFilter | string
    account_number?: StringFilter | string
    bank_username?: StringFilter | string
    is_default?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeNullableFilter | Date | string | null
    User?: XOR<UserRelationFilter, UserWhereInput>
    UserId?: IntFilter | number
  }

  export type User_BankOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    alias?: SortOrder
    bank_name?: SortOrder
    account_number?: SortOrder
    bank_username?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    UserId?: SortOrder
  }

  export type User_BankWhereUniqueInput = {
    id?: number
    uid?: string
  }

  export type User_BankScalarWhereWithAggregatesInput = {
    AND?: Enumerable<User_BankScalarWhereWithAggregatesInput>
    OR?: Enumerable<User_BankScalarWhereWithAggregatesInput>
    NOT?: Enumerable<User_BankScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    alias?: StringWithAggregatesFilter | string
    bank_name?: StringWithAggregatesFilter | string
    account_number?: StringWithAggregatesFilter | string
    bank_username?: StringWithAggregatesFilter | string
    is_default?: BoolWithAggregatesFilter | boolean
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    UserId?: IntWithAggregatesFilter | number
  }

  export type Vendor_BankWhereInput = {
    AND?: Enumerable<Vendor_BankWhereInput>
    OR?: Enumerable<Vendor_BankWhereInput>
    NOT?: Enumerable<Vendor_BankWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    alias?: StringFilter | string
    bank_name?: StringFilter | string
    account_number?: StringFilter | string
    bank_username?: StringFilter | string
    is_default?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type Vendor_BankOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    alias?: SortOrder
    bank_name?: SortOrder
    account_number?: SortOrder
    bank_username?: SortOrder
    is_default?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Vendor_BankWhereUniqueInput = {
    id?: number
    uid?: string
  }

  export type Vendor_BankScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Vendor_BankScalarWhereWithAggregatesInput>
    OR?: Enumerable<Vendor_BankScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Vendor_BankScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    alias?: StringWithAggregatesFilter | string
    bank_name?: StringWithAggregatesFilter | string
    account_number?: StringWithAggregatesFilter | string
    bank_username?: StringWithAggregatesFilter | string
    is_default?: BoolWithAggregatesFilter | boolean
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type VaccineTypeWhereInput = {
    AND?: Enumerable<VaccineTypeWhereInput>
    OR?: Enumerable<VaccineTypeWhereInput>
    NOT?: Enumerable<VaccineTypeWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    VaccineHistory?: VaccineHistoryListRelationFilter
  }

  export type VaccineTypeOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VaccineTypeWhereUniqueInput = {
    id?: number
  }

  export type VaccineTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VaccineTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<VaccineTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VaccineTypeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type VaccineHistoryWhereInput = {
    AND?: Enumerable<VaccineHistoryWhereInput>
    OR?: Enumerable<VaccineHistoryWhereInput>
    NOT?: Enumerable<VaccineHistoryWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    pet?: XOR<UserPetsRelationFilter, UserPetsWhereInput> | null
    pet_id?: StringFilter | string
    veterinary?: StringFilter | string
    vaccine_photo?: StringFilter | string
    date_administered?: DateTimeFilter | Date | string
    is_manual?: BoolFilter | boolean
    date_valid_until?: DateTimeFilter | Date | string
    vaccine_type?: XOR<VaccineTypeRelationFilter, VaccineTypeWhereInput> | null
    vaccine_type_id?: IntNullableFilter | number | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    VaccineHistoryPhoto?: VaccineHistoryPhotoListRelationFilter
  }

  export type VaccineHistoryOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    pet_id?: SortOrder
    veterinary?: SortOrder
    vaccine_photo?: SortOrder
    date_administered?: SortOrder
    is_manual?: SortOrder
    date_valid_until?: SortOrder
    vaccine_type_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VaccineHistoryWhereUniqueInput = {
    id?: number
    uid?: string
  }

  export type VaccineHistoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VaccineHistoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<VaccineHistoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VaccineHistoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    pet_id?: StringWithAggregatesFilter | string
    veterinary?: StringWithAggregatesFilter | string
    vaccine_photo?: StringWithAggregatesFilter | string
    date_administered?: DateTimeWithAggregatesFilter | Date | string
    is_manual?: BoolWithAggregatesFilter | boolean
    date_valid_until?: DateTimeWithAggregatesFilter | Date | string
    vaccine_type_id?: IntNullableWithAggregatesFilter | number | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type VaccineHistoryPhotoWhereInput = {
    AND?: Enumerable<VaccineHistoryPhotoWhereInput>
    OR?: Enumerable<VaccineHistoryPhotoWhereInput>
    NOT?: Enumerable<VaccineHistoryPhotoWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    vaccine_history?: XOR<VaccineHistoryRelationFilter, VaccineHistoryWhereInput>
    vaccine_history_id?: IntFilter | number
    path?: StringFilter | string
    description?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type VaccineHistoryPhotoOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    vaccine_history_id?: SortOrder
    path?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VaccineHistoryPhotoWhereUniqueInput = {
    id?: number
    uid?: string
  }

  export type VaccineHistoryPhotoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VaccineHistoryPhotoScalarWhereWithAggregatesInput>
    OR?: Enumerable<VaccineHistoryPhotoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VaccineHistoryPhotoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    vaccine_history_id?: IntWithAggregatesFilter | number
    path?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type VendorsWhereInput = {
    AND?: Enumerable<VendorsWhereInput>
    OR?: Enumerable<VendorsWhereInput>
    NOT?: Enumerable<VendorsWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    email?: StringFilter | string
    is_verified?: BoolFilter | boolean
    vendor_role?: EnumTypeNullableFilter | Type | null
    price?: IntFilter | number
    total_patient?: IntNullableFilter | number | null
    rating?: FloatNullableFilter | number | null
    name?: StringFilter | string
    username?: StringFilter | string
    address?: StringFilter | string
    phone_number?: StringFilter | string
    profile_picture_url?: StringFilter | string
    gender?: EnumGenderNullableFilter | Gender | null
    speciality?: StringFilter | string
    birthdate?: StringFilter | string
    google_maps_url?: StringFilter | string
    str_number?: StringFilter | string
    str_issued_date?: StringFilter | string
    alumni?: StringFilter | string
    city_id?: IntFilter | number
    province_id?: IntFilter | number
    lat?: StringFilter | string
    long?: StringFilter | string
    days?: StringFilter | string
    ops_start_time?: StringFilter | string
    ops_end_time?: StringFilter | string
    duration?: IntFilter | number
    rest?: IntFilter | number
    total_poli?: IntFilter | number
    image_url?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    vendor_documents?: Vendor_DocumentsListRelationFilter
    vendor_medtreats?: Vendor_MedtreatsListRelationFilter
    Feedbacks?: FeedbacksListRelationFilter
  }

  export type VendorsOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    email?: SortOrder
    is_verified?: SortOrder
    vendor_role?: SortOrder
    price?: SortOrder
    total_patient?: SortOrder
    rating?: SortOrder
    name?: SortOrder
    username?: SortOrder
    address?: SortOrder
    phone_number?: SortOrder
    profile_picture_url?: SortOrder
    gender?: SortOrder
    speciality?: SortOrder
    birthdate?: SortOrder
    google_maps_url?: SortOrder
    str_number?: SortOrder
    str_issued_date?: SortOrder
    alumni?: SortOrder
    city_id?: SortOrder
    province_id?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    days?: SortOrder
    ops_start_time?: SortOrder
    ops_end_time?: SortOrder
    duration?: SortOrder
    rest?: SortOrder
    total_poli?: SortOrder
    image_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorsWhereUniqueInput = {
    id?: number
    uid?: string
    email?: string
  }

  export type VendorsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VendorsScalarWhereWithAggregatesInput>
    OR?: Enumerable<VendorsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VendorsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    is_verified?: BoolWithAggregatesFilter | boolean
    vendor_role?: EnumTypeNullableWithAggregatesFilter | Type | null
    price?: IntWithAggregatesFilter | number
    total_patient?: IntNullableWithAggregatesFilter | number | null
    rating?: FloatNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    username?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    phone_number?: StringWithAggregatesFilter | string
    profile_picture_url?: StringWithAggregatesFilter | string
    gender?: EnumGenderNullableWithAggregatesFilter | Gender | null
    speciality?: StringWithAggregatesFilter | string
    birthdate?: StringWithAggregatesFilter | string
    google_maps_url?: StringWithAggregatesFilter | string
    str_number?: StringWithAggregatesFilter | string
    str_issued_date?: StringWithAggregatesFilter | string
    alumni?: StringWithAggregatesFilter | string
    city_id?: IntWithAggregatesFilter | number
    province_id?: IntWithAggregatesFilter | number
    lat?: StringWithAggregatesFilter | string
    long?: StringWithAggregatesFilter | string
    days?: StringWithAggregatesFilter | string
    ops_start_time?: StringWithAggregatesFilter | string
    ops_end_time?: StringWithAggregatesFilter | string
    duration?: IntWithAggregatesFilter | number
    rest?: IntWithAggregatesFilter | number
    total_poli?: IntWithAggregatesFilter | number
    image_url?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ScheduleWhereInput = {
    AND?: Enumerable<ScheduleWhereInput>
    OR?: Enumerable<ScheduleWhereInput>
    NOT?: Enumerable<ScheduleWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    time_start?: StringFilter | string
    time_end?: StringFilter | string
    day_start?: StringFilter | string
    day_end?: StringFilter | string
    homecare_customer_limit?: IntFilter | number
    price?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type ScheduleOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    time_start?: SortOrder
    time_end?: SortOrder
    day_start?: SortOrder
    day_end?: SortOrder
    homecare_customer_limit?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ScheduleWhereUniqueInput = {
    id?: number
    uid?: string
  }

  export type ScheduleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ScheduleScalarWhereWithAggregatesInput>
    OR?: Enumerable<ScheduleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ScheduleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    time_start?: StringWithAggregatesFilter | string
    time_end?: StringWithAggregatesFilter | string
    day_start?: StringWithAggregatesFilter | string
    day_end?: StringWithAggregatesFilter | string
    homecare_customer_limit?: IntWithAggregatesFilter | number
    price?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type Vendor_DocumentsWhereInput = {
    AND?: Enumerable<Vendor_DocumentsWhereInput>
    OR?: Enumerable<Vendor_DocumentsWhereInput>
    NOT?: Enumerable<Vendor_DocumentsWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    document_type?: StringFilter | string
    document_path?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    Vendors?: XOR<VendorsRelationFilter, VendorsWhereInput>
    VendorsId?: IntFilter | number
  }

  export type Vendor_DocumentsOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    document_type?: SortOrder
    document_path?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    VendorsId?: SortOrder
  }

  export type Vendor_DocumentsWhereUniqueInput = {
    id?: number
    uid?: string
  }

  export type Vendor_DocumentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Vendor_DocumentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<Vendor_DocumentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Vendor_DocumentsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    document_type?: StringWithAggregatesFilter | string
    document_path?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    VendorsId?: IntWithAggregatesFilter | number
  }

  export type Vendor_MedtreatsWhereInput = {
    AND?: Enumerable<Vendor_MedtreatsWhereInput>
    OR?: Enumerable<Vendor_MedtreatsWhereInput>
    NOT?: Enumerable<Vendor_MedtreatsWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    medical_treatment_id?: StringFilter | string
    is_homecare?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    Vendors?: XOR<VendorsRelationFilter, VendorsWhereInput>
    VendorsId?: IntFilter | number
  }

  export type Vendor_MedtreatsOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    medical_treatment_id?: SortOrder
    is_homecare?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    VendorsId?: SortOrder
  }

  export type Vendor_MedtreatsWhereUniqueInput = {
    id?: number
    uid?: string
  }

  export type Vendor_MedtreatsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Vendor_MedtreatsScalarWhereWithAggregatesInput>
    OR?: Enumerable<Vendor_MedtreatsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Vendor_MedtreatsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    medical_treatment_id?: StringWithAggregatesFilter | string
    is_homecare?: BoolWithAggregatesFilter | boolean
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    VendorsId?: IntWithAggregatesFilter | number
  }

  export type ClassWhereInput = {
    AND?: Enumerable<ClassWhereInput>
    OR?: Enumerable<ClassWhereInput>
    NOT?: Enumerable<ClassWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeNullableFilter | Date | string | null
    species?: SpeciesListRelationFilter
  }

  export type ClassOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type ClassWhereUniqueInput = {
    id?: number
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClassScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClassScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClassScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SpeciesWhereInput = {
    AND?: Enumerable<SpeciesWhereInput>
    OR?: Enumerable<SpeciesWhereInput>
    NOT?: Enumerable<SpeciesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeNullableFilter | Date | string | null
    Articles?: ArticlesListRelationFilter
    Class?: XOR<ClassRelationFilter, ClassWhereInput>
    ClassId?: IntFilter | number
  }

  export type SpeciesOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    ClassId?: SortOrder
  }

  export type SpeciesWhereUniqueInput = {
    id?: number
  }

  export type SpeciesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SpeciesScalarWhereWithAggregatesInput>
    OR?: Enumerable<SpeciesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SpeciesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ClassId?: IntWithAggregatesFilter | number
  }

  export type Medical_TreatmentWhereInput = {
    AND?: Enumerable<Medical_TreatmentWhereInput>
    OR?: Enumerable<Medical_TreatmentWhereInput>
    NOT?: Enumerable<Medical_TreatmentWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type Medical_TreatmentOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Medical_TreatmentWhereUniqueInput = {
    id?: number
  }

  export type Medical_TreatmentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Medical_TreatmentScalarWhereWithAggregatesInput>
    OR?: Enumerable<Medical_TreatmentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Medical_TreatmentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ConsultationsWhereInput = {
    AND?: Enumerable<ConsultationsWhereInput>
    OR?: Enumerable<ConsultationsWhereInput>
    NOT?: Enumerable<ConsultationsWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    User?: XOR<UserRelationFilter, UserWhereInput> | null
    user_id?: StringFilter | string
    Pet?: XOR<UserPetsRelationFilter, UserPetsWhereInput> | null
    pet_id?: StringFilter | string
    vendor_id?: StringFilter | string
    chat_room_id?: StringFilter | string
    vendor_role?: EnumTypeNullableFilter | Type | null
    diagnose?: StringFilter | string
    prerequisite?: StringFilter | string
    date?: StringFilter | string
    time_start?: StringFilter | string
    time_end?: StringFilter | string
    order_status?: StringFilter | string
    reject_reason?: StringFilter | string
    total_payment?: IntFilter | number
    payment_image_url?: StringFilter | string
    rating?: IntFilter | number
    comment?: StringFilter | string
    user_bank_id?: IntFilter | number
    vendor_bank_id?: IntFilter | number
    user_address_id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type ConsultationsOrderByInput = {
    id?: SortOrder
    uid?: SortOrder
    user_id?: SortOrder
    pet_id?: SortOrder
    vendor_id?: SortOrder
    chat_room_id?: SortOrder
    vendor_role?: SortOrder
    diagnose?: SortOrder
    prerequisite?: SortOrder
    date?: SortOrder
    time_start?: SortOrder
    time_end?: SortOrder
    order_status?: SortOrder
    reject_reason?: SortOrder
    total_payment?: SortOrder
    payment_image_url?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    user_bank_id?: SortOrder
    vendor_bank_id?: SortOrder
    user_address_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ConsultationsWhereUniqueInput = {
    id?: number
    uid?: string
  }

  export type ConsultationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ConsultationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<ConsultationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ConsultationsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uid?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
    pet_id?: StringWithAggregatesFilter | string
    vendor_id?: StringWithAggregatesFilter | string
    chat_room_id?: StringWithAggregatesFilter | string
    vendor_role?: EnumTypeNullableWithAggregatesFilter | Type | null
    diagnose?: StringWithAggregatesFilter | string
    prerequisite?: StringWithAggregatesFilter | string
    date?: StringWithAggregatesFilter | string
    time_start?: StringWithAggregatesFilter | string
    time_end?: StringWithAggregatesFilter | string
    order_status?: StringWithAggregatesFilter | string
    reject_reason?: StringWithAggregatesFilter | string
    total_payment?: IntWithAggregatesFilter | number
    payment_image_url?: StringWithAggregatesFilter | string
    rating?: IntWithAggregatesFilter | number
    comment?: StringWithAggregatesFilter | string
    user_bank_id?: IntWithAggregatesFilter | number
    vendor_bank_id?: IntWithAggregatesFilter | number
    user_address_id?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ArticlesWhereInput = {
    AND?: Enumerable<ArticlesWhereInput>
    OR?: Enumerable<ArticlesWhereInput>
    NOT?: Enumerable<ArticlesWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    content?: StringFilter | string
    species?: XOR<SpeciesRelationFilter, SpeciesWhereInput>
    species_id?: IntFilter | number
    image_url?: StringFilter | string
    is_active?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type ArticlesOrderByInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    species_id?: SortOrder
    image_url?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ArticlesWhereUniqueInput = {
    id?: number
  }

  export type ArticlesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ArticlesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ArticlesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ArticlesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    species_id?: IntWithAggregatesFilter | number
    image_url?: StringWithAggregatesFilter | string
    is_active?: BoolWithAggregatesFilter | boolean
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type FeedbacksWhereInput = {
    AND?: Enumerable<FeedbacksWhereInput>
    OR?: Enumerable<FeedbacksWhereInput>
    NOT?: Enumerable<FeedbacksWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    Vendor?: XOR<VendorsRelationFilter, VendorsWhereInput> | null
    vendor_id?: StringFilter | string
    email?: StringFilter | string
    title?: StringFilter | string
    content?: StringFilter | string
    rating?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type FeedbacksOrderByInput = {
    id?: SortOrder
    user_id?: SortOrder
    vendor_id?: SortOrder
    email?: SortOrder
    title?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FeedbacksWhereUniqueInput = {
    id?: number
  }

  export type FeedbacksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FeedbacksScalarWhereWithAggregatesInput>
    OR?: Enumerable<FeedbacksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FeedbacksScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    vendor_id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    rating?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProvinceCreateInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    City?: CityCreateNestedManyWithoutProvinceInput
    User_Address?: User_AddressCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    City?: CityUncheckedCreateNestedManyWithoutProvinceInput
    User_Address?: User_AddressUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    City?: CityUpdateManyWithoutProvinceInput
    User_Address?: User_AddressUpdateManyWithoutProvinceInput
  }

  export type ProvinceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    City?: CityUncheckedUpdateManyWithoutProvinceInput
    User_Address?: User_AddressUncheckedUpdateManyWithoutProvinceInput
  }

  export type ProvinceCreateManyInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ProvinceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProvinceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityCreateInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    Province?: ProvinceCreateNestedOneWithoutCityInput
    User_Address?: User_AddressCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: number
    name: string
    province_id?: number | null
    created_at?: Date | string
    updated_at: Date | string
    User_Address?: User_AddressUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Province?: ProvinceUpdateOneWithoutCityInput
    User_Address?: User_AddressUpdateManyWithoutCityInput
  }

  export type CityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    province_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Address?: User_AddressUncheckedUpdateManyWithoutCityInput
  }

  export type CityCreateManyInput = {
    id?: number
    name: string
    province_id?: number | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type CityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    province_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    uid: string
    email: string
    name?: string | null
    username?: string | null
    phone_number?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    birthdate?: string | null
    password?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    user_address?: User_AddressCreateNestedManyWithoutUserInput
    user_bank?: User_BankCreateNestedManyWithoutUserInput
    user_pets?: UserPetsCreateNestedManyWithoutUserInput
    Consultations?: ConsultationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    uid: string
    email: string
    name?: string | null
    username?: string | null
    phone_number?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    birthdate?: string | null
    password?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    user_address?: User_AddressUncheckedCreateNestedManyWithoutUserInput
    user_bank?: User_BankUncheckedCreateNestedManyWithoutUserInput
    user_pets?: UserPetsUncheckedCreateNestedManyWithoutUserInput
    Consultations?: ConsultationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_address?: User_AddressUpdateManyWithoutUserInput
    user_bank?: User_BankUpdateManyWithoutUserInput
    user_pets?: UserPetsUpdateManyWithoutUserInput
    Consultations?: ConsultationsUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_address?: User_AddressUncheckedUpdateManyWithoutUserInput
    user_bank?: User_BankUncheckedUpdateManyWithoutUserInput
    user_pets?: UserPetsUncheckedUpdateManyWithoutUserInput
    Consultations?: ConsultationsUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateManyInput = {
    id?: number
    uid: string
    email: string
    name?: string | null
    username?: string | null
    phone_number?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    birthdate?: string | null
    password?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminsCreateInput = {
    uid: string
    email: string
    name?: string | null
    username?: string | null
    phone_number?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    password?: string | null
    is_active?: boolean
    created_at?: Date | string
    tokens?: TokenCreateNestedManyWithoutAdminsInput
  }

  export type AdminsUncheckedCreateInput = {
    id?: number
    uid: string
    email: string
    name?: string | null
    username?: string | null
    phone_number?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    password?: string | null
    is_active?: boolean
    created_at?: Date | string
    tokens?: TokenUncheckedCreateNestedManyWithoutAdminsInput
  }

  export type AdminsUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUpdateManyWithoutAdminsInput
  }

  export type AdminsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUncheckedUpdateManyWithoutAdminsInput
  }

  export type AdminsCreateManyInput = {
    id?: number
    uid: string
    email: string
    name?: string | null
    username?: string | null
    phone_number?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    password?: string | null
    is_active?: boolean
    created_at?: Date | string
  }

  export type AdminsUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenCreateInput = {
    created_at: Date | string
    updated_at: Date | string
    valid: boolean
    expiration: Date | string
    Admins: AdminsCreateNestedOneWithoutTokensInput
  }

  export type TokenUncheckedCreateInput = {
    id?: number
    created_at: Date | string
    updated_at: Date | string
    valid: boolean
    expiration: Date | string
    AdminsId: number
  }

  export type TokenUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expiration?: DateTimeFieldUpdateOperationsInput | Date | string
    Admins?: AdminsUpdateOneRequiredWithoutTokensInput
  }

  export type TokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expiration?: DateTimeFieldUpdateOperationsInput | Date | string
    AdminsId?: IntFieldUpdateOperationsInput | number
  }

  export type TokenCreateManyInput = {
    id?: number
    created_at: Date | string
    updated_at: Date | string
    valid: boolean
    expiration: Date | string
    AdminsId: number
  }

  export type TokenUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expiration?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expiration?: DateTimeFieldUpdateOperationsInput | Date | string
    AdminsId?: IntFieldUpdateOperationsInput | number
  }

  export type UserPetsCreateInput = {
    uid: string
    name: string
    species?: string | null
    breed?: string | null
    date_of_birth?: Date | string | null
    color?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    is_neutered?: boolean | null
    is_dog_friendly?: boolean | null
    is_cat_friendly?: boolean | null
    is_under_10_child_friendly?: boolean | null
    is_over_10_child_friendly?: boolean | null
    is_microchipped?: boolean | null
    is_purebred?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    User: UserCreateNestedOneWithoutUser_petsInput
    VaccineHistory?: VaccineHistoryCreateNestedManyWithoutPetInput
    Consultations?: ConsultationsCreateNestedManyWithoutPetInput
  }

  export type UserPetsUncheckedCreateInput = {
    id?: number
    uid: string
    name: string
    species?: string | null
    breed?: string | null
    date_of_birth?: Date | string | null
    color?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    is_neutered?: boolean | null
    is_dog_friendly?: boolean | null
    is_cat_friendly?: boolean | null
    is_under_10_child_friendly?: boolean | null
    is_over_10_child_friendly?: boolean | null
    is_microchipped?: boolean | null
    is_purebred?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    UserId: string
    VaccineHistory?: VaccineHistoryUncheckedCreateNestedManyWithoutPetInput
    Consultations?: ConsultationsUncheckedCreateNestedManyWithoutPetInput
  }

  export type UserPetsUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    species?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    is_neutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_dog_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_cat_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_under_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_over_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_microchipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_purebred?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutUser_petsInput
    VaccineHistory?: VaccineHistoryUpdateManyWithoutPetInput
    Consultations?: ConsultationsUpdateManyWithoutPetInput
  }

  export type UserPetsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    species?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    is_neutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_dog_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_cat_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_under_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_over_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_microchipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_purebred?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserId?: StringFieldUpdateOperationsInput | string
    VaccineHistory?: VaccineHistoryUncheckedUpdateManyWithoutPetInput
    Consultations?: ConsultationsUncheckedUpdateManyWithoutPetInput
  }

  export type UserPetsCreateManyInput = {
    id?: number
    uid: string
    name: string
    species?: string | null
    breed?: string | null
    date_of_birth?: Date | string | null
    color?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    is_neutered?: boolean | null
    is_dog_friendly?: boolean | null
    is_cat_friendly?: boolean | null
    is_under_10_child_friendly?: boolean | null
    is_over_10_child_friendly?: boolean | null
    is_microchipped?: boolean | null
    is_purebred?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    UserId: string
  }

  export type UserPetsUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    species?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    is_neutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_dog_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_cat_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_under_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_over_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_microchipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_purebred?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPetsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    species?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    is_neutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_dog_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_cat_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_under_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_over_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_microchipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_purebred?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type User_AddressCreateInput = {
    uid: string
    label: string
    address: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    City?: CityCreateNestedOneWithoutUser_AddressInput
    Province?: ProvinceCreateNestedOneWithoutUser_AddressInput
    User: UserCreateNestedOneWithoutUser_addressInput
  }

  export type User_AddressUncheckedCreateInput = {
    id?: number
    uid: string
    label: string
    address: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    city_id?: number | null
    province_id?: number | null
    user_id: string
  }

  export type User_AddressUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    City?: CityUpdateOneWithoutUser_AddressInput
    Province?: ProvinceUpdateOneWithoutUser_AddressInput
    User?: UserUpdateOneRequiredWithoutUser_addressInput
  }

  export type User_AddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city_id?: NullableIntFieldUpdateOperationsInput | number | null
    province_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type User_AddressCreateManyInput = {
    id?: number
    uid: string
    label: string
    address: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    city_id?: number | null
    province_id?: number | null
    user_id: string
  }

  export type User_AddressUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type User_AddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city_id?: NullableIntFieldUpdateOperationsInput | number | null
    province_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type User_BankCreateInput = {
    uid: string
    alias: string
    bank_name: string
    account_number: string
    bank_username: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    User: UserCreateNestedOneWithoutUser_bankInput
  }

  export type User_BankUncheckedCreateInput = {
    id?: number
    uid: string
    alias: string
    bank_name: string
    account_number: string
    bank_username: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    UserId: number
  }

  export type User_BankUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    bank_username?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutUser_bankInput
  }

  export type User_BankUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    bank_username?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type User_BankCreateManyInput = {
    id?: number
    uid: string
    alias: string
    bank_name: string
    account_number: string
    bank_username: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    UserId: number
  }

  export type User_BankUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    bank_username?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type User_BankUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    bank_username?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type Vendor_BankCreateInput = {
    uid: string
    alias: string
    bank_name: string
    account_number: string
    bank_username: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type Vendor_BankUncheckedCreateInput = {
    id?: number
    uid: string
    alias: string
    bank_name: string
    account_number: string
    bank_username: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type Vendor_BankUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    bank_username?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Vendor_BankUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    bank_username?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Vendor_BankCreateManyInput = {
    id?: number
    uid: string
    alias: string
    bank_name: string
    account_number: string
    bank_username: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type Vendor_BankUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    bank_username?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Vendor_BankUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    bank_username?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccineTypeCreateInput = {
    name: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
    VaccineHistory?: VaccineHistoryCreateNestedManyWithoutVaccine_typeInput
  }

  export type VaccineTypeUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
    VaccineHistory?: VaccineHistoryUncheckedCreateNestedManyWithoutVaccine_typeInput
  }

  export type VaccineTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    VaccineHistory?: VaccineHistoryUpdateManyWithoutVaccine_typeInput
  }

  export type VaccineTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    VaccineHistory?: VaccineHistoryUncheckedUpdateManyWithoutVaccine_typeInput
  }

  export type VaccineTypeCreateManyInput = {
    id?: number
    name: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type VaccineTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccineTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccineHistoryCreateInput = {
    uid: string
    veterinary: string
    vaccine_photo: string
    date_administered: Date | string
    is_manual: boolean
    date_valid_until: Date | string
    created_at?: Date | string
    updated_at: Date | string
    pet?: UserPetsCreateNestedOneWithoutVaccineHistoryInput
    vaccine_type?: VaccineTypeCreateNestedOneWithoutVaccineHistoryInput
    VaccineHistoryPhoto?: VaccineHistoryPhotoCreateNestedManyWithoutVaccine_historyInput
  }

  export type VaccineHistoryUncheckedCreateInput = {
    id?: number
    uid: string
    pet_id: string
    veterinary: string
    vaccine_photo: string
    date_administered: Date | string
    is_manual: boolean
    date_valid_until: Date | string
    vaccine_type_id?: number | null
    created_at?: Date | string
    updated_at: Date | string
    VaccineHistoryPhoto?: VaccineHistoryPhotoUncheckedCreateNestedManyWithoutVaccine_historyInput
  }

  export type VaccineHistoryUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    veterinary?: StringFieldUpdateOperationsInput | string
    vaccine_photo?: StringFieldUpdateOperationsInput | string
    date_administered?: DateTimeFieldUpdateOperationsInput | Date | string
    is_manual?: BoolFieldUpdateOperationsInput | boolean
    date_valid_until?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    pet?: UserPetsUpdateOneWithoutVaccineHistoryInput
    vaccine_type?: VaccineTypeUpdateOneWithoutVaccineHistoryInput
    VaccineHistoryPhoto?: VaccineHistoryPhotoUpdateManyWithoutVaccine_historyInput
  }

  export type VaccineHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    pet_id?: StringFieldUpdateOperationsInput | string
    veterinary?: StringFieldUpdateOperationsInput | string
    vaccine_photo?: StringFieldUpdateOperationsInput | string
    date_administered?: DateTimeFieldUpdateOperationsInput | Date | string
    is_manual?: BoolFieldUpdateOperationsInput | boolean
    date_valid_until?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccine_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    VaccineHistoryPhoto?: VaccineHistoryPhotoUncheckedUpdateManyWithoutVaccine_historyInput
  }

  export type VaccineHistoryCreateManyInput = {
    id?: number
    uid: string
    pet_id: string
    veterinary: string
    vaccine_photo: string
    date_administered: Date | string
    is_manual: boolean
    date_valid_until: Date | string
    vaccine_type_id?: number | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type VaccineHistoryUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    veterinary?: StringFieldUpdateOperationsInput | string
    vaccine_photo?: StringFieldUpdateOperationsInput | string
    date_administered?: DateTimeFieldUpdateOperationsInput | Date | string
    is_manual?: BoolFieldUpdateOperationsInput | boolean
    date_valid_until?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccineHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    pet_id?: StringFieldUpdateOperationsInput | string
    veterinary?: StringFieldUpdateOperationsInput | string
    vaccine_photo?: StringFieldUpdateOperationsInput | string
    date_administered?: DateTimeFieldUpdateOperationsInput | Date | string
    is_manual?: BoolFieldUpdateOperationsInput | boolean
    date_valid_until?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccine_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccineHistoryPhotoCreateInput = {
    uid: string
    path: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
    vaccine_history: VaccineHistoryCreateNestedOneWithoutVaccineHistoryPhotoInput
  }

  export type VaccineHistoryPhotoUncheckedCreateInput = {
    id?: number
    uid: string
    vaccine_history_id: number
    path: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type VaccineHistoryPhotoUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccine_history?: VaccineHistoryUpdateOneRequiredWithoutVaccineHistoryPhotoInput
  }

  export type VaccineHistoryPhotoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    vaccine_history_id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccineHistoryPhotoCreateManyInput = {
    id?: number
    uid: string
    vaccine_history_id: number
    path: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type VaccineHistoryPhotoUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccineHistoryPhotoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    vaccine_history_id?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorsCreateInput = {
    uid: string
    email: string
    is_verified: boolean
    vendor_role?: Type | null
    price: number
    total_patient?: number | null
    rating?: number | null
    name: string
    username: string
    address: string
    phone_number: string
    profile_picture_url: string
    gender?: Gender | null
    speciality: string
    birthdate: string
    google_maps_url: string
    str_number: string
    str_issued_date: string
    alumni: string
    city_id: number
    province_id: number
    lat: string
    long: string
    days: string
    ops_start_time: string
    ops_end_time: string
    duration: number
    rest: number
    total_poli: number
    image_url: string
    created_at?: Date | string
    updated_at?: Date | string
    vendor_documents?: Vendor_DocumentsCreateNestedManyWithoutVendorsInput
    vendor_medtreats?: Vendor_MedtreatsCreateNestedManyWithoutVendorsInput
    Feedbacks?: FeedbacksCreateNestedManyWithoutVendorInput
  }

  export type VendorsUncheckedCreateInput = {
    id?: number
    uid: string
    email: string
    is_verified: boolean
    vendor_role?: Type | null
    price: number
    total_patient?: number | null
    rating?: number | null
    name: string
    username: string
    address: string
    phone_number: string
    profile_picture_url: string
    gender?: Gender | null
    speciality: string
    birthdate: string
    google_maps_url: string
    str_number: string
    str_issued_date: string
    alumni: string
    city_id: number
    province_id: number
    lat: string
    long: string
    days: string
    ops_start_time: string
    ops_end_time: string
    duration: number
    rest: number
    total_poli: number
    image_url: string
    created_at?: Date | string
    updated_at?: Date | string
    vendor_documents?: Vendor_DocumentsUncheckedCreateNestedManyWithoutVendorsInput
    vendor_medtreats?: Vendor_MedtreatsUncheckedCreateNestedManyWithoutVendorsInput
    Feedbacks?: FeedbacksUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorsUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    vendor_role?: NullableEnumTypeFieldUpdateOperationsInput | Type | null
    price?: IntFieldUpdateOperationsInput | number
    total_patient?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    profile_picture_url?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    speciality?: StringFieldUpdateOperationsInput | string
    birthdate?: StringFieldUpdateOperationsInput | string
    google_maps_url?: StringFieldUpdateOperationsInput | string
    str_number?: StringFieldUpdateOperationsInput | string
    str_issued_date?: StringFieldUpdateOperationsInput | string
    alumni?: StringFieldUpdateOperationsInput | string
    city_id?: IntFieldUpdateOperationsInput | number
    province_id?: IntFieldUpdateOperationsInput | number
    lat?: StringFieldUpdateOperationsInput | string
    long?: StringFieldUpdateOperationsInput | string
    days?: StringFieldUpdateOperationsInput | string
    ops_start_time?: StringFieldUpdateOperationsInput | string
    ops_end_time?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    rest?: IntFieldUpdateOperationsInput | number
    total_poli?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor_documents?: Vendor_DocumentsUpdateManyWithoutVendorsInput
    vendor_medtreats?: Vendor_MedtreatsUpdateManyWithoutVendorsInput
    Feedbacks?: FeedbacksUpdateManyWithoutVendorInput
  }

  export type VendorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    vendor_role?: NullableEnumTypeFieldUpdateOperationsInput | Type | null
    price?: IntFieldUpdateOperationsInput | number
    total_patient?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    profile_picture_url?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    speciality?: StringFieldUpdateOperationsInput | string
    birthdate?: StringFieldUpdateOperationsInput | string
    google_maps_url?: StringFieldUpdateOperationsInput | string
    str_number?: StringFieldUpdateOperationsInput | string
    str_issued_date?: StringFieldUpdateOperationsInput | string
    alumni?: StringFieldUpdateOperationsInput | string
    city_id?: IntFieldUpdateOperationsInput | number
    province_id?: IntFieldUpdateOperationsInput | number
    lat?: StringFieldUpdateOperationsInput | string
    long?: StringFieldUpdateOperationsInput | string
    days?: StringFieldUpdateOperationsInput | string
    ops_start_time?: StringFieldUpdateOperationsInput | string
    ops_end_time?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    rest?: IntFieldUpdateOperationsInput | number
    total_poli?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor_documents?: Vendor_DocumentsUncheckedUpdateManyWithoutVendorsInput
    vendor_medtreats?: Vendor_MedtreatsUncheckedUpdateManyWithoutVendorsInput
    Feedbacks?: FeedbacksUncheckedUpdateManyWithoutVendorInput
  }

  export type VendorsCreateManyInput = {
    id?: number
    uid: string
    email: string
    is_verified: boolean
    vendor_role?: Type | null
    price: number
    total_patient?: number | null
    rating?: number | null
    name: string
    username: string
    address: string
    phone_number: string
    profile_picture_url: string
    gender?: Gender | null
    speciality: string
    birthdate: string
    google_maps_url: string
    str_number: string
    str_issued_date: string
    alumni: string
    city_id: number
    province_id: number
    lat: string
    long: string
    days: string
    ops_start_time: string
    ops_end_time: string
    duration: number
    rest: number
    total_poli: number
    image_url: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorsUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    vendor_role?: NullableEnumTypeFieldUpdateOperationsInput | Type | null
    price?: IntFieldUpdateOperationsInput | number
    total_patient?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    profile_picture_url?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    speciality?: StringFieldUpdateOperationsInput | string
    birthdate?: StringFieldUpdateOperationsInput | string
    google_maps_url?: StringFieldUpdateOperationsInput | string
    str_number?: StringFieldUpdateOperationsInput | string
    str_issued_date?: StringFieldUpdateOperationsInput | string
    alumni?: StringFieldUpdateOperationsInput | string
    city_id?: IntFieldUpdateOperationsInput | number
    province_id?: IntFieldUpdateOperationsInput | number
    lat?: StringFieldUpdateOperationsInput | string
    long?: StringFieldUpdateOperationsInput | string
    days?: StringFieldUpdateOperationsInput | string
    ops_start_time?: StringFieldUpdateOperationsInput | string
    ops_end_time?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    rest?: IntFieldUpdateOperationsInput | number
    total_poli?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    vendor_role?: NullableEnumTypeFieldUpdateOperationsInput | Type | null
    price?: IntFieldUpdateOperationsInput | number
    total_patient?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    profile_picture_url?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    speciality?: StringFieldUpdateOperationsInput | string
    birthdate?: StringFieldUpdateOperationsInput | string
    google_maps_url?: StringFieldUpdateOperationsInput | string
    str_number?: StringFieldUpdateOperationsInput | string
    str_issued_date?: StringFieldUpdateOperationsInput | string
    alumni?: StringFieldUpdateOperationsInput | string
    city_id?: IntFieldUpdateOperationsInput | number
    province_id?: IntFieldUpdateOperationsInput | number
    lat?: StringFieldUpdateOperationsInput | string
    long?: StringFieldUpdateOperationsInput | string
    days?: StringFieldUpdateOperationsInput | string
    ops_start_time?: StringFieldUpdateOperationsInput | string
    ops_end_time?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    rest?: IntFieldUpdateOperationsInput | number
    total_poli?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleCreateInput = {
    uid: string
    time_start: string
    time_end: string
    day_start: string
    day_end: string
    homecare_customer_limit: number
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ScheduleUncheckedCreateInput = {
    id?: number
    uid: string
    time_start: string
    time_end: string
    day_start: string
    day_end: string
    homecare_customer_limit: number
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ScheduleUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    time_start?: StringFieldUpdateOperationsInput | string
    time_end?: StringFieldUpdateOperationsInput | string
    day_start?: StringFieldUpdateOperationsInput | string
    day_end?: StringFieldUpdateOperationsInput | string
    homecare_customer_limit?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    time_start?: StringFieldUpdateOperationsInput | string
    time_end?: StringFieldUpdateOperationsInput | string
    day_start?: StringFieldUpdateOperationsInput | string
    day_end?: StringFieldUpdateOperationsInput | string
    homecare_customer_limit?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleCreateManyInput = {
    id?: number
    uid: string
    time_start: string
    time_end: string
    day_start: string
    day_end: string
    homecare_customer_limit: number
    price: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ScheduleUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    time_start?: StringFieldUpdateOperationsInput | string
    time_end?: StringFieldUpdateOperationsInput | string
    day_start?: StringFieldUpdateOperationsInput | string
    day_end?: StringFieldUpdateOperationsInput | string
    homecare_customer_limit?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    time_start?: StringFieldUpdateOperationsInput | string
    time_end?: StringFieldUpdateOperationsInput | string
    day_start?: StringFieldUpdateOperationsInput | string
    day_end?: StringFieldUpdateOperationsInput | string
    homecare_customer_limit?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Vendor_DocumentsCreateInput = {
    uid: string
    document_type: string
    document_path: string
    created_at?: Date | string
    updated_at: Date | string
    Vendors: VendorsCreateNestedOneWithoutVendor_documentsInput
  }

  export type Vendor_DocumentsUncheckedCreateInput = {
    id?: number
    uid: string
    document_type: string
    document_path: string
    created_at?: Date | string
    updated_at: Date | string
    VendorsId: number
  }

  export type Vendor_DocumentsUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    document_type?: StringFieldUpdateOperationsInput | string
    document_path?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Vendors?: VendorsUpdateOneRequiredWithoutVendor_documentsInput
  }

  export type Vendor_DocumentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    document_type?: StringFieldUpdateOperationsInput | string
    document_path?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    VendorsId?: IntFieldUpdateOperationsInput | number
  }

  export type Vendor_DocumentsCreateManyInput = {
    id?: number
    uid: string
    document_type: string
    document_path: string
    created_at?: Date | string
    updated_at: Date | string
    VendorsId: number
  }

  export type Vendor_DocumentsUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    document_type?: StringFieldUpdateOperationsInput | string
    document_path?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Vendor_DocumentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    document_type?: StringFieldUpdateOperationsInput | string
    document_path?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    VendorsId?: IntFieldUpdateOperationsInput | number
  }

  export type Vendor_MedtreatsCreateInput = {
    uid: string
    medical_treatment_id: string
    is_homecare: boolean
    created_at?: Date | string
    updated_at: Date | string
    Vendors: VendorsCreateNestedOneWithoutVendor_medtreatsInput
  }

  export type Vendor_MedtreatsUncheckedCreateInput = {
    id?: number
    uid: string
    medical_treatment_id: string
    is_homecare: boolean
    created_at?: Date | string
    updated_at: Date | string
    VendorsId: number
  }

  export type Vendor_MedtreatsUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    medical_treatment_id?: StringFieldUpdateOperationsInput | string
    is_homecare?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Vendors?: VendorsUpdateOneRequiredWithoutVendor_medtreatsInput
  }

  export type Vendor_MedtreatsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    medical_treatment_id?: StringFieldUpdateOperationsInput | string
    is_homecare?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    VendorsId?: IntFieldUpdateOperationsInput | number
  }

  export type Vendor_MedtreatsCreateManyInput = {
    id?: number
    uid: string
    medical_treatment_id: string
    is_homecare: boolean
    created_at?: Date | string
    updated_at: Date | string
    VendorsId: number
  }

  export type Vendor_MedtreatsUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    medical_treatment_id?: StringFieldUpdateOperationsInput | string
    is_homecare?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Vendor_MedtreatsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    medical_treatment_id?: StringFieldUpdateOperationsInput | string
    is_homecare?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    VendorsId?: IntFieldUpdateOperationsInput | number
  }

  export type ClassCreateInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    species?: SpeciesCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    species?: SpeciesUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    species?: SpeciesUpdateManyWithoutClassInput
  }

  export type ClassUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    species?: SpeciesUncheckedUpdateManyWithoutClassInput
  }

  export type ClassCreateManyInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
  }

  export type ClassUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClassUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SpeciesCreateInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    Articles?: ArticlesCreateNestedManyWithoutSpeciesInput
    Class: ClassCreateNestedOneWithoutSpeciesInput
  }

  export type SpeciesUncheckedCreateInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    ClassId: number
    Articles?: ArticlesUncheckedCreateNestedManyWithoutSpeciesInput
  }

  export type SpeciesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Articles?: ArticlesUpdateManyWithoutSpeciesInput
    Class?: ClassUpdateOneRequiredWithoutSpeciesInput
  }

  export type SpeciesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ClassId?: IntFieldUpdateOperationsInput | number
    Articles?: ArticlesUncheckedUpdateManyWithoutSpeciesInput
  }

  export type SpeciesCreateManyInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    ClassId: number
  }

  export type SpeciesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SpeciesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ClassId?: IntFieldUpdateOperationsInput | number
  }

  export type Medical_TreatmentCreateInput = {
    name: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type Medical_TreatmentUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type Medical_TreatmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Medical_TreatmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Medical_TreatmentCreateManyInput = {
    id?: number
    name: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type Medical_TreatmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Medical_TreatmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationsCreateInput = {
    uid: string
    vendor_id: string
    chat_room_id: string
    vendor_role?: Type | null
    diagnose: string
    prerequisite: string
    date: string
    time_start: string
    time_end: string
    order_status: string
    reject_reason: string
    total_payment: number
    payment_image_url: string
    rating: number
    comment: string
    user_bank_id: number
    vendor_bank_id: number
    user_address_id: number
    created_at?: Date | string
    updated_at?: Date | string
    User?: UserCreateNestedOneWithoutConsultationsInput
    Pet?: UserPetsCreateNestedOneWithoutConsultationsInput
  }

  export type ConsultationsUncheckedCreateInput = {
    id?: number
    uid: string
    user_id: string
    pet_id: string
    vendor_id: string
    chat_room_id: string
    vendor_role?: Type | null
    diagnose: string
    prerequisite: string
    date: string
    time_start: string
    time_end: string
    order_status: string
    reject_reason: string
    total_payment: number
    payment_image_url: string
    rating: number
    comment: string
    user_bank_id: number
    vendor_bank_id: number
    user_address_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ConsultationsUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    chat_room_id?: StringFieldUpdateOperationsInput | string
    vendor_role?: NullableEnumTypeFieldUpdateOperationsInput | Type | null
    diagnose?: StringFieldUpdateOperationsInput | string
    prerequisite?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time_start?: StringFieldUpdateOperationsInput | string
    time_end?: StringFieldUpdateOperationsInput | string
    order_status?: StringFieldUpdateOperationsInput | string
    reject_reason?: StringFieldUpdateOperationsInput | string
    total_payment?: IntFieldUpdateOperationsInput | number
    payment_image_url?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    user_bank_id?: IntFieldUpdateOperationsInput | number
    vendor_bank_id?: IntFieldUpdateOperationsInput | number
    user_address_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutConsultationsInput
    Pet?: UserPetsUpdateOneWithoutConsultationsInput
  }

  export type ConsultationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    pet_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    chat_room_id?: StringFieldUpdateOperationsInput | string
    vendor_role?: NullableEnumTypeFieldUpdateOperationsInput | Type | null
    diagnose?: StringFieldUpdateOperationsInput | string
    prerequisite?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time_start?: StringFieldUpdateOperationsInput | string
    time_end?: StringFieldUpdateOperationsInput | string
    order_status?: StringFieldUpdateOperationsInput | string
    reject_reason?: StringFieldUpdateOperationsInput | string
    total_payment?: IntFieldUpdateOperationsInput | number
    payment_image_url?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    user_bank_id?: IntFieldUpdateOperationsInput | number
    vendor_bank_id?: IntFieldUpdateOperationsInput | number
    user_address_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationsCreateManyInput = {
    id?: number
    uid: string
    user_id: string
    pet_id: string
    vendor_id: string
    chat_room_id: string
    vendor_role?: Type | null
    diagnose: string
    prerequisite: string
    date: string
    time_start: string
    time_end: string
    order_status: string
    reject_reason: string
    total_payment: number
    payment_image_url: string
    rating: number
    comment: string
    user_bank_id: number
    vendor_bank_id: number
    user_address_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ConsultationsUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    chat_room_id?: StringFieldUpdateOperationsInput | string
    vendor_role?: NullableEnumTypeFieldUpdateOperationsInput | Type | null
    diagnose?: StringFieldUpdateOperationsInput | string
    prerequisite?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time_start?: StringFieldUpdateOperationsInput | string
    time_end?: StringFieldUpdateOperationsInput | string
    order_status?: StringFieldUpdateOperationsInput | string
    reject_reason?: StringFieldUpdateOperationsInput | string
    total_payment?: IntFieldUpdateOperationsInput | number
    payment_image_url?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    user_bank_id?: IntFieldUpdateOperationsInput | number
    vendor_bank_id?: IntFieldUpdateOperationsInput | number
    user_address_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    pet_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    chat_room_id?: StringFieldUpdateOperationsInput | string
    vendor_role?: NullableEnumTypeFieldUpdateOperationsInput | Type | null
    diagnose?: StringFieldUpdateOperationsInput | string
    prerequisite?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time_start?: StringFieldUpdateOperationsInput | string
    time_end?: StringFieldUpdateOperationsInput | string
    order_status?: StringFieldUpdateOperationsInput | string
    reject_reason?: StringFieldUpdateOperationsInput | string
    total_payment?: IntFieldUpdateOperationsInput | number
    payment_image_url?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    user_bank_id?: IntFieldUpdateOperationsInput | number
    vendor_bank_id?: IntFieldUpdateOperationsInput | number
    user_address_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticlesCreateInput = {
    title: string
    content: string
    image_url: string
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
    species: SpeciesCreateNestedOneWithoutArticlesInput
  }

  export type ArticlesUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    species_id: number
    image_url: string
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ArticlesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    species?: SpeciesUpdateOneRequiredWithoutArticlesInput
  }

  export type ArticlesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    species_id?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticlesCreateManyInput = {
    id?: number
    title: string
    content: string
    species_id: number
    image_url: string
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ArticlesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticlesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    species_id?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbacksCreateInput = {
    user_id: number
    email: string
    title: string
    content: string
    rating: number
    created_at?: Date | string
    updated_at: Date | string
    Vendor?: VendorsCreateNestedOneWithoutFeedbacksInput
  }

  export type FeedbacksUncheckedCreateInput = {
    id?: number
    user_id: number
    vendor_id: string
    email: string
    title: string
    content: string
    rating: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type FeedbacksUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Vendor?: VendorsUpdateOneWithoutFeedbacksInput
  }

  export type FeedbacksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    vendor_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbacksCreateManyInput = {
    id?: number
    user_id: number
    vendor_id: string
    email: string
    title: string
    content: string
    rating: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type FeedbacksUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbacksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    vendor_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type CityListRelationFilter = {
    every?: CityWhereInput
    some?: CityWhereInput
    none?: CityWhereInput
  }

  export type User_AddressListRelationFilter = {
    every?: User_AddressWhereInput
    some?: User_AddressWhereInput
    none?: User_AddressWhereInput
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringFilter
    _max?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeFilter
  }

  export type ProvinceRelationFilter = {
    is?: ProvinceWhereInput | null
    isNot?: ProvinceWhereInput | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntNullableFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type EnumGenderNullableFilter = {
    equals?: Gender | null
    in?: Enumerable<Gender> | null
    notIn?: Enumerable<Gender> | null
    not?: NestedEnumGenderNullableFilter | Gender | null
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type User_BankListRelationFilter = {
    every?: User_BankWhereInput
    some?: User_BankWhereInput
    none?: User_BankWhereInput
  }

  export type UserPetsListRelationFilter = {
    every?: UserPetsWhereInput
    some?: UserPetsWhereInput
    none?: UserPetsWhereInput
  }

  export type ConsultationsListRelationFilter = {
    every?: ConsultationsWhereInput
    some?: ConsultationsWhereInput
    none?: ConsultationsWhereInput
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringNullableFilter
  }

  export type EnumGenderNullableWithAggregatesFilter = {
    equals?: Gender | null
    in?: Enumerable<Gender> | null
    notIn?: Enumerable<Gender> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter | Gender | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedEnumGenderNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumGenderNullableFilter
    _max?: NestedEnumGenderNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumGenderNullableFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeNullableFilter
  }

  export type TokenListRelationFilter = {
    every?: TokenWhereInput
    some?: TokenWhereInput
    none?: TokenWhereInput
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolFilter
    _max?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolFilter
  }

  export type AdminsRelationFilter = {
    is?: AdminsWhereInput
    isNot?: AdminsWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type VaccineHistoryListRelationFilter = {
    every?: VaccineHistoryWhereInput
    some?: VaccineHistoryWhereInput
    none?: VaccineHistoryWhereInput
  }

  export type CityRelationFilter = {
    is?: CityWhereInput | null
    isNot?: CityWhereInput | null
  }

  export type UserPetsRelationFilter = {
    is?: UserPetsWhereInput | null
    isNot?: UserPetsWhereInput | null
  }

  export type VaccineTypeRelationFilter = {
    is?: VaccineTypeWhereInput | null
    isNot?: VaccineTypeWhereInput | null
  }

  export type VaccineHistoryPhotoListRelationFilter = {
    every?: VaccineHistoryPhotoWhereInput
    some?: VaccineHistoryPhotoWhereInput
    none?: VaccineHistoryPhotoWhereInput
  }

  export type VaccineHistoryRelationFilter = {
    is?: VaccineHistoryWhereInput
    isNot?: VaccineHistoryWhereInput
  }

  export type EnumTypeNullableFilter = {
    equals?: Type | null
    in?: Enumerable<Type> | null
    notIn?: Enumerable<Type> | null
    not?: NestedEnumTypeNullableFilter | Type | null
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type Vendor_DocumentsListRelationFilter = {
    every?: Vendor_DocumentsWhereInput
    some?: Vendor_DocumentsWhereInput
    none?: Vendor_DocumentsWhereInput
  }

  export type Vendor_MedtreatsListRelationFilter = {
    every?: Vendor_MedtreatsWhereInput
    some?: Vendor_MedtreatsWhereInput
    none?: Vendor_MedtreatsWhereInput
  }

  export type FeedbacksListRelationFilter = {
    every?: FeedbacksWhereInput
    some?: FeedbacksWhereInput
    none?: FeedbacksWhereInput
  }

  export type EnumTypeNullableWithAggregatesFilter = {
    equals?: Type | null
    in?: Enumerable<Type> | null
    notIn?: Enumerable<Type> | null
    not?: NestedEnumTypeNullableWithAggregatesFilter | Type | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedEnumTypeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumTypeNullableFilter
    _max?: NestedEnumTypeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumTypeNullableFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedFloatNullableFilter
  }

  export type VendorsRelationFilter = {
    is?: VendorsWhereInput
    isNot?: VendorsWhereInput
  }

  export type SpeciesListRelationFilter = {
    every?: SpeciesWhereInput
    some?: SpeciesWhereInput
    none?: SpeciesWhereInput
  }

  export type ArticlesListRelationFilter = {
    every?: ArticlesWhereInput
    some?: ArticlesWhereInput
    none?: ArticlesWhereInput
  }

  export type ClassRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type SpeciesRelationFilter = {
    is?: SpeciesWhereInput
    isNot?: SpeciesWhereInput
  }

  export type CityCreateNestedManyWithoutProvinceInput = {
    create?: XOR<Enumerable<CityCreateWithoutProvinceInput>, Enumerable<CityUncheckedCreateWithoutProvinceInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutProvinceInput>
    createMany?: CityCreateManyProvinceInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
  }

  export type User_AddressCreateNestedManyWithoutProvinceInput = {
    create?: XOR<Enumerable<User_AddressCreateWithoutProvinceInput>, Enumerable<User_AddressUncheckedCreateWithoutProvinceInput>>
    connectOrCreate?: Enumerable<User_AddressCreateOrConnectWithoutProvinceInput>
    createMany?: User_AddressCreateManyProvinceInputEnvelope
    connect?: Enumerable<User_AddressWhereUniqueInput>
  }

  export type CityUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<Enumerable<CityCreateWithoutProvinceInput>, Enumerable<CityUncheckedCreateWithoutProvinceInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutProvinceInput>
    createMany?: CityCreateManyProvinceInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
  }

  export type User_AddressUncheckedCreateNestedManyWithoutProvinceInput = {
    create?: XOR<Enumerable<User_AddressCreateWithoutProvinceInput>, Enumerable<User_AddressUncheckedCreateWithoutProvinceInput>>
    connectOrCreate?: Enumerable<User_AddressCreateOrConnectWithoutProvinceInput>
    createMany?: User_AddressCreateManyProvinceInputEnvelope
    connect?: Enumerable<User_AddressWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CityUpdateManyWithoutProvinceInput = {
    create?: XOR<Enumerable<CityCreateWithoutProvinceInput>, Enumerable<CityUncheckedCreateWithoutProvinceInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutProvinceInput>
    upsert?: Enumerable<CityUpsertWithWhereUniqueWithoutProvinceInput>
    createMany?: CityCreateManyProvinceInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
    set?: Enumerable<CityWhereUniqueInput>
    disconnect?: Enumerable<CityWhereUniqueInput>
    delete?: Enumerable<CityWhereUniqueInput>
    update?: Enumerable<CityUpdateWithWhereUniqueWithoutProvinceInput>
    updateMany?: Enumerable<CityUpdateManyWithWhereWithoutProvinceInput>
    deleteMany?: Enumerable<CityScalarWhereInput>
  }

  export type User_AddressUpdateManyWithoutProvinceInput = {
    create?: XOR<Enumerable<User_AddressCreateWithoutProvinceInput>, Enumerable<User_AddressUncheckedCreateWithoutProvinceInput>>
    connectOrCreate?: Enumerable<User_AddressCreateOrConnectWithoutProvinceInput>
    upsert?: Enumerable<User_AddressUpsertWithWhereUniqueWithoutProvinceInput>
    createMany?: User_AddressCreateManyProvinceInputEnvelope
    connect?: Enumerable<User_AddressWhereUniqueInput>
    set?: Enumerable<User_AddressWhereUniqueInput>
    disconnect?: Enumerable<User_AddressWhereUniqueInput>
    delete?: Enumerable<User_AddressWhereUniqueInput>
    update?: Enumerable<User_AddressUpdateWithWhereUniqueWithoutProvinceInput>
    updateMany?: Enumerable<User_AddressUpdateManyWithWhereWithoutProvinceInput>
    deleteMany?: Enumerable<User_AddressScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CityUncheckedUpdateManyWithoutProvinceInput = {
    create?: XOR<Enumerable<CityCreateWithoutProvinceInput>, Enumerable<CityUncheckedCreateWithoutProvinceInput>>
    connectOrCreate?: Enumerable<CityCreateOrConnectWithoutProvinceInput>
    upsert?: Enumerable<CityUpsertWithWhereUniqueWithoutProvinceInput>
    createMany?: CityCreateManyProvinceInputEnvelope
    connect?: Enumerable<CityWhereUniqueInput>
    set?: Enumerable<CityWhereUniqueInput>
    disconnect?: Enumerable<CityWhereUniqueInput>
    delete?: Enumerable<CityWhereUniqueInput>
    update?: Enumerable<CityUpdateWithWhereUniqueWithoutProvinceInput>
    updateMany?: Enumerable<CityUpdateManyWithWhereWithoutProvinceInput>
    deleteMany?: Enumerable<CityScalarWhereInput>
  }

  export type User_AddressUncheckedUpdateManyWithoutProvinceInput = {
    create?: XOR<Enumerable<User_AddressCreateWithoutProvinceInput>, Enumerable<User_AddressUncheckedCreateWithoutProvinceInput>>
    connectOrCreate?: Enumerable<User_AddressCreateOrConnectWithoutProvinceInput>
    upsert?: Enumerable<User_AddressUpsertWithWhereUniqueWithoutProvinceInput>
    createMany?: User_AddressCreateManyProvinceInputEnvelope
    connect?: Enumerable<User_AddressWhereUniqueInput>
    set?: Enumerable<User_AddressWhereUniqueInput>
    disconnect?: Enumerable<User_AddressWhereUniqueInput>
    delete?: Enumerable<User_AddressWhereUniqueInput>
    update?: Enumerable<User_AddressUpdateWithWhereUniqueWithoutProvinceInput>
    updateMany?: Enumerable<User_AddressUpdateManyWithWhereWithoutProvinceInput>
    deleteMany?: Enumerable<User_AddressScalarWhereInput>
  }

  export type ProvinceCreateNestedOneWithoutCityInput = {
    create?: XOR<ProvinceCreateWithoutCityInput, ProvinceUncheckedCreateWithoutCityInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutCityInput
    connect?: ProvinceWhereUniqueInput
  }

  export type User_AddressCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<User_AddressCreateWithoutCityInput>, Enumerable<User_AddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<User_AddressCreateOrConnectWithoutCityInput>
    createMany?: User_AddressCreateManyCityInputEnvelope
    connect?: Enumerable<User_AddressWhereUniqueInput>
  }

  export type User_AddressUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<User_AddressCreateWithoutCityInput>, Enumerable<User_AddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<User_AddressCreateOrConnectWithoutCityInput>
    createMany?: User_AddressCreateManyCityInputEnvelope
    connect?: Enumerable<User_AddressWhereUniqueInput>
  }

  export type ProvinceUpdateOneWithoutCityInput = {
    create?: XOR<ProvinceCreateWithoutCityInput, ProvinceUncheckedCreateWithoutCityInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutCityInput
    upsert?: ProvinceUpsertWithoutCityInput
    connect?: ProvinceWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ProvinceUpdateWithoutCityInput, ProvinceUncheckedUpdateWithoutCityInput>
  }

  export type User_AddressUpdateManyWithoutCityInput = {
    create?: XOR<Enumerable<User_AddressCreateWithoutCityInput>, Enumerable<User_AddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<User_AddressCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<User_AddressUpsertWithWhereUniqueWithoutCityInput>
    createMany?: User_AddressCreateManyCityInputEnvelope
    connect?: Enumerable<User_AddressWhereUniqueInput>
    set?: Enumerable<User_AddressWhereUniqueInput>
    disconnect?: Enumerable<User_AddressWhereUniqueInput>
    delete?: Enumerable<User_AddressWhereUniqueInput>
    update?: Enumerable<User_AddressUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<User_AddressUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<User_AddressScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type User_AddressUncheckedUpdateManyWithoutCityInput = {
    create?: XOR<Enumerable<User_AddressCreateWithoutCityInput>, Enumerable<User_AddressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<User_AddressCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<User_AddressUpsertWithWhereUniqueWithoutCityInput>
    createMany?: User_AddressCreateManyCityInputEnvelope
    connect?: Enumerable<User_AddressWhereUniqueInput>
    set?: Enumerable<User_AddressWhereUniqueInput>
    disconnect?: Enumerable<User_AddressWhereUniqueInput>
    delete?: Enumerable<User_AddressWhereUniqueInput>
    update?: Enumerable<User_AddressUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<User_AddressUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<User_AddressScalarWhereInput>
  }

  export type User_AddressCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<User_AddressCreateWithoutUserInput>, Enumerable<User_AddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<User_AddressCreateOrConnectWithoutUserInput>
    createMany?: User_AddressCreateManyUserInputEnvelope
    connect?: Enumerable<User_AddressWhereUniqueInput>
  }

  export type User_BankCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<User_BankCreateWithoutUserInput>, Enumerable<User_BankUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<User_BankCreateOrConnectWithoutUserInput>
    createMany?: User_BankCreateManyUserInputEnvelope
    connect?: Enumerable<User_BankWhereUniqueInput>
  }

  export type UserPetsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserPetsCreateWithoutUserInput>, Enumerable<UserPetsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserPetsCreateOrConnectWithoutUserInput>
    createMany?: UserPetsCreateManyUserInputEnvelope
    connect?: Enumerable<UserPetsWhereUniqueInput>
  }

  export type ConsultationsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ConsultationsCreateWithoutUserInput>, Enumerable<ConsultationsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ConsultationsCreateOrConnectWithoutUserInput>
    createMany?: ConsultationsCreateManyUserInputEnvelope
    connect?: Enumerable<ConsultationsWhereUniqueInput>
  }

  export type User_AddressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<User_AddressCreateWithoutUserInput>, Enumerable<User_AddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<User_AddressCreateOrConnectWithoutUserInput>
    createMany?: User_AddressCreateManyUserInputEnvelope
    connect?: Enumerable<User_AddressWhereUniqueInput>
  }

  export type User_BankUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<User_BankCreateWithoutUserInput>, Enumerable<User_BankUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<User_BankCreateOrConnectWithoutUserInput>
    createMany?: User_BankCreateManyUserInputEnvelope
    connect?: Enumerable<User_BankWhereUniqueInput>
  }

  export type UserPetsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserPetsCreateWithoutUserInput>, Enumerable<UserPetsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserPetsCreateOrConnectWithoutUserInput>
    createMany?: UserPetsCreateManyUserInputEnvelope
    connect?: Enumerable<UserPetsWhereUniqueInput>
  }

  export type ConsultationsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ConsultationsCreateWithoutUserInput>, Enumerable<ConsultationsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ConsultationsCreateOrConnectWithoutUserInput>
    createMany?: ConsultationsCreateManyUserInputEnvelope
    connect?: Enumerable<ConsultationsWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: Gender | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type User_AddressUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<User_AddressCreateWithoutUserInput>, Enumerable<User_AddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<User_AddressCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<User_AddressUpsertWithWhereUniqueWithoutUserInput>
    createMany?: User_AddressCreateManyUserInputEnvelope
    connect?: Enumerable<User_AddressWhereUniqueInput>
    set?: Enumerable<User_AddressWhereUniqueInput>
    disconnect?: Enumerable<User_AddressWhereUniqueInput>
    delete?: Enumerable<User_AddressWhereUniqueInput>
    update?: Enumerable<User_AddressUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<User_AddressUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<User_AddressScalarWhereInput>
  }

  export type User_BankUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<User_BankCreateWithoutUserInput>, Enumerable<User_BankUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<User_BankCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<User_BankUpsertWithWhereUniqueWithoutUserInput>
    createMany?: User_BankCreateManyUserInputEnvelope
    connect?: Enumerable<User_BankWhereUniqueInput>
    set?: Enumerable<User_BankWhereUniqueInput>
    disconnect?: Enumerable<User_BankWhereUniqueInput>
    delete?: Enumerable<User_BankWhereUniqueInput>
    update?: Enumerable<User_BankUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<User_BankUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<User_BankScalarWhereInput>
  }

  export type UserPetsUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserPetsCreateWithoutUserInput>, Enumerable<UserPetsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserPetsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserPetsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserPetsCreateManyUserInputEnvelope
    connect?: Enumerable<UserPetsWhereUniqueInput>
    set?: Enumerable<UserPetsWhereUniqueInput>
    disconnect?: Enumerable<UserPetsWhereUniqueInput>
    delete?: Enumerable<UserPetsWhereUniqueInput>
    update?: Enumerable<UserPetsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserPetsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserPetsScalarWhereInput>
  }

  export type ConsultationsUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ConsultationsCreateWithoutUserInput>, Enumerable<ConsultationsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ConsultationsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ConsultationsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ConsultationsCreateManyUserInputEnvelope
    connect?: Enumerable<ConsultationsWhereUniqueInput>
    set?: Enumerable<ConsultationsWhereUniqueInput>
    disconnect?: Enumerable<ConsultationsWhereUniqueInput>
    delete?: Enumerable<ConsultationsWhereUniqueInput>
    update?: Enumerable<ConsultationsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ConsultationsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ConsultationsScalarWhereInput>
  }

  export type User_AddressUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<User_AddressCreateWithoutUserInput>, Enumerable<User_AddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<User_AddressCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<User_AddressUpsertWithWhereUniqueWithoutUserInput>
    createMany?: User_AddressCreateManyUserInputEnvelope
    connect?: Enumerable<User_AddressWhereUniqueInput>
    set?: Enumerable<User_AddressWhereUniqueInput>
    disconnect?: Enumerable<User_AddressWhereUniqueInput>
    delete?: Enumerable<User_AddressWhereUniqueInput>
    update?: Enumerable<User_AddressUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<User_AddressUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<User_AddressScalarWhereInput>
  }

  export type User_BankUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<User_BankCreateWithoutUserInput>, Enumerable<User_BankUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<User_BankCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<User_BankUpsertWithWhereUniqueWithoutUserInput>
    createMany?: User_BankCreateManyUserInputEnvelope
    connect?: Enumerable<User_BankWhereUniqueInput>
    set?: Enumerable<User_BankWhereUniqueInput>
    disconnect?: Enumerable<User_BankWhereUniqueInput>
    delete?: Enumerable<User_BankWhereUniqueInput>
    update?: Enumerable<User_BankUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<User_BankUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<User_BankScalarWhereInput>
  }

  export type UserPetsUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<UserPetsCreateWithoutUserInput>, Enumerable<UserPetsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserPetsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserPetsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserPetsCreateManyUserInputEnvelope
    connect?: Enumerable<UserPetsWhereUniqueInput>
    set?: Enumerable<UserPetsWhereUniqueInput>
    disconnect?: Enumerable<UserPetsWhereUniqueInput>
    delete?: Enumerable<UserPetsWhereUniqueInput>
    update?: Enumerable<UserPetsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserPetsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserPetsScalarWhereInput>
  }

  export type ConsultationsUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ConsultationsCreateWithoutUserInput>, Enumerable<ConsultationsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ConsultationsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ConsultationsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ConsultationsCreateManyUserInputEnvelope
    connect?: Enumerable<ConsultationsWhereUniqueInput>
    set?: Enumerable<ConsultationsWhereUniqueInput>
    disconnect?: Enumerable<ConsultationsWhereUniqueInput>
    delete?: Enumerable<ConsultationsWhereUniqueInput>
    update?: Enumerable<ConsultationsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ConsultationsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ConsultationsScalarWhereInput>
  }

  export type TokenCreateNestedManyWithoutAdminsInput = {
    create?: XOR<Enumerable<TokenCreateWithoutAdminsInput>, Enumerable<TokenUncheckedCreateWithoutAdminsInput>>
    connectOrCreate?: Enumerable<TokenCreateOrConnectWithoutAdminsInput>
    createMany?: TokenCreateManyAdminsInputEnvelope
    connect?: Enumerable<TokenWhereUniqueInput>
  }

  export type TokenUncheckedCreateNestedManyWithoutAdminsInput = {
    create?: XOR<Enumerable<TokenCreateWithoutAdminsInput>, Enumerable<TokenUncheckedCreateWithoutAdminsInput>>
    connectOrCreate?: Enumerable<TokenCreateOrConnectWithoutAdminsInput>
    createMany?: TokenCreateManyAdminsInputEnvelope
    connect?: Enumerable<TokenWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TokenUpdateManyWithoutAdminsInput = {
    create?: XOR<Enumerable<TokenCreateWithoutAdminsInput>, Enumerable<TokenUncheckedCreateWithoutAdminsInput>>
    connectOrCreate?: Enumerable<TokenCreateOrConnectWithoutAdminsInput>
    upsert?: Enumerable<TokenUpsertWithWhereUniqueWithoutAdminsInput>
    createMany?: TokenCreateManyAdminsInputEnvelope
    connect?: Enumerable<TokenWhereUniqueInput>
    set?: Enumerable<TokenWhereUniqueInput>
    disconnect?: Enumerable<TokenWhereUniqueInput>
    delete?: Enumerable<TokenWhereUniqueInput>
    update?: Enumerable<TokenUpdateWithWhereUniqueWithoutAdminsInput>
    updateMany?: Enumerable<TokenUpdateManyWithWhereWithoutAdminsInput>
    deleteMany?: Enumerable<TokenScalarWhereInput>
  }

  export type TokenUncheckedUpdateManyWithoutAdminsInput = {
    create?: XOR<Enumerable<TokenCreateWithoutAdminsInput>, Enumerable<TokenUncheckedCreateWithoutAdminsInput>>
    connectOrCreate?: Enumerable<TokenCreateOrConnectWithoutAdminsInput>
    upsert?: Enumerable<TokenUpsertWithWhereUniqueWithoutAdminsInput>
    createMany?: TokenCreateManyAdminsInputEnvelope
    connect?: Enumerable<TokenWhereUniqueInput>
    set?: Enumerable<TokenWhereUniqueInput>
    disconnect?: Enumerable<TokenWhereUniqueInput>
    delete?: Enumerable<TokenWhereUniqueInput>
    update?: Enumerable<TokenUpdateWithWhereUniqueWithoutAdminsInput>
    updateMany?: Enumerable<TokenUpdateManyWithWhereWithoutAdminsInput>
    deleteMany?: Enumerable<TokenScalarWhereInput>
  }

  export type AdminsCreateNestedOneWithoutTokensInput = {
    create?: XOR<AdminsCreateWithoutTokensInput, AdminsUncheckedCreateWithoutTokensInput>
    connectOrCreate?: AdminsCreateOrConnectWithoutTokensInput
    connect?: AdminsWhereUniqueInput
  }

  export type AdminsUpdateOneRequiredWithoutTokensInput = {
    create?: XOR<AdminsCreateWithoutTokensInput, AdminsUncheckedCreateWithoutTokensInput>
    connectOrCreate?: AdminsCreateOrConnectWithoutTokensInput
    upsert?: AdminsUpsertWithoutTokensInput
    connect?: AdminsWhereUniqueInput
    update?: XOR<AdminsUpdateWithoutTokensInput, AdminsUncheckedUpdateWithoutTokensInput>
  }

  export type UserCreateNestedOneWithoutUser_petsInput = {
    create?: XOR<UserCreateWithoutUser_petsInput, UserUncheckedCreateWithoutUser_petsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_petsInput
    connect?: UserWhereUniqueInput
  }

  export type VaccineHistoryCreateNestedManyWithoutPetInput = {
    create?: XOR<Enumerable<VaccineHistoryCreateWithoutPetInput>, Enumerable<VaccineHistoryUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<VaccineHistoryCreateOrConnectWithoutPetInput>
    createMany?: VaccineHistoryCreateManyPetInputEnvelope
    connect?: Enumerable<VaccineHistoryWhereUniqueInput>
  }

  export type ConsultationsCreateNestedManyWithoutPetInput = {
    create?: XOR<Enumerable<ConsultationsCreateWithoutPetInput>, Enumerable<ConsultationsUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<ConsultationsCreateOrConnectWithoutPetInput>
    createMany?: ConsultationsCreateManyPetInputEnvelope
    connect?: Enumerable<ConsultationsWhereUniqueInput>
  }

  export type VaccineHistoryUncheckedCreateNestedManyWithoutPetInput = {
    create?: XOR<Enumerable<VaccineHistoryCreateWithoutPetInput>, Enumerable<VaccineHistoryUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<VaccineHistoryCreateOrConnectWithoutPetInput>
    createMany?: VaccineHistoryCreateManyPetInputEnvelope
    connect?: Enumerable<VaccineHistoryWhereUniqueInput>
  }

  export type ConsultationsUncheckedCreateNestedManyWithoutPetInput = {
    create?: XOR<Enumerable<ConsultationsCreateWithoutPetInput>, Enumerable<ConsultationsUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<ConsultationsCreateOrConnectWithoutPetInput>
    createMany?: ConsultationsCreateManyPetInputEnvelope
    connect?: Enumerable<ConsultationsWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutUser_petsInput = {
    create?: XOR<UserCreateWithoutUser_petsInput, UserUncheckedCreateWithoutUser_petsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_petsInput
    upsert?: UserUpsertWithoutUser_petsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUser_petsInput, UserUncheckedUpdateWithoutUser_petsInput>
  }

  export type VaccineHistoryUpdateManyWithoutPetInput = {
    create?: XOR<Enumerable<VaccineHistoryCreateWithoutPetInput>, Enumerable<VaccineHistoryUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<VaccineHistoryCreateOrConnectWithoutPetInput>
    upsert?: Enumerable<VaccineHistoryUpsertWithWhereUniqueWithoutPetInput>
    createMany?: VaccineHistoryCreateManyPetInputEnvelope
    connect?: Enumerable<VaccineHistoryWhereUniqueInput>
    set?: Enumerable<VaccineHistoryWhereUniqueInput>
    disconnect?: Enumerable<VaccineHistoryWhereUniqueInput>
    delete?: Enumerable<VaccineHistoryWhereUniqueInput>
    update?: Enumerable<VaccineHistoryUpdateWithWhereUniqueWithoutPetInput>
    updateMany?: Enumerable<VaccineHistoryUpdateManyWithWhereWithoutPetInput>
    deleteMany?: Enumerable<VaccineHistoryScalarWhereInput>
  }

  export type ConsultationsUpdateManyWithoutPetInput = {
    create?: XOR<Enumerable<ConsultationsCreateWithoutPetInput>, Enumerable<ConsultationsUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<ConsultationsCreateOrConnectWithoutPetInput>
    upsert?: Enumerable<ConsultationsUpsertWithWhereUniqueWithoutPetInput>
    createMany?: ConsultationsCreateManyPetInputEnvelope
    connect?: Enumerable<ConsultationsWhereUniqueInput>
    set?: Enumerable<ConsultationsWhereUniqueInput>
    disconnect?: Enumerable<ConsultationsWhereUniqueInput>
    delete?: Enumerable<ConsultationsWhereUniqueInput>
    update?: Enumerable<ConsultationsUpdateWithWhereUniqueWithoutPetInput>
    updateMany?: Enumerable<ConsultationsUpdateManyWithWhereWithoutPetInput>
    deleteMany?: Enumerable<ConsultationsScalarWhereInput>
  }

  export type VaccineHistoryUncheckedUpdateManyWithoutPetInput = {
    create?: XOR<Enumerable<VaccineHistoryCreateWithoutPetInput>, Enumerable<VaccineHistoryUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<VaccineHistoryCreateOrConnectWithoutPetInput>
    upsert?: Enumerable<VaccineHistoryUpsertWithWhereUniqueWithoutPetInput>
    createMany?: VaccineHistoryCreateManyPetInputEnvelope
    connect?: Enumerable<VaccineHistoryWhereUniqueInput>
    set?: Enumerable<VaccineHistoryWhereUniqueInput>
    disconnect?: Enumerable<VaccineHistoryWhereUniqueInput>
    delete?: Enumerable<VaccineHistoryWhereUniqueInput>
    update?: Enumerable<VaccineHistoryUpdateWithWhereUniqueWithoutPetInput>
    updateMany?: Enumerable<VaccineHistoryUpdateManyWithWhereWithoutPetInput>
    deleteMany?: Enumerable<VaccineHistoryScalarWhereInput>
  }

  export type ConsultationsUncheckedUpdateManyWithoutPetInput = {
    create?: XOR<Enumerable<ConsultationsCreateWithoutPetInput>, Enumerable<ConsultationsUncheckedCreateWithoutPetInput>>
    connectOrCreate?: Enumerable<ConsultationsCreateOrConnectWithoutPetInput>
    upsert?: Enumerable<ConsultationsUpsertWithWhereUniqueWithoutPetInput>
    createMany?: ConsultationsCreateManyPetInputEnvelope
    connect?: Enumerable<ConsultationsWhereUniqueInput>
    set?: Enumerable<ConsultationsWhereUniqueInput>
    disconnect?: Enumerable<ConsultationsWhereUniqueInput>
    delete?: Enumerable<ConsultationsWhereUniqueInput>
    update?: Enumerable<ConsultationsUpdateWithWhereUniqueWithoutPetInput>
    updateMany?: Enumerable<ConsultationsUpdateManyWithWhereWithoutPetInput>
    deleteMany?: Enumerable<ConsultationsScalarWhereInput>
  }

  export type CityCreateNestedOneWithoutUser_AddressInput = {
    create?: XOR<CityCreateWithoutUser_AddressInput, CityUncheckedCreateWithoutUser_AddressInput>
    connectOrCreate?: CityCreateOrConnectWithoutUser_AddressInput
    connect?: CityWhereUniqueInput
  }

  export type ProvinceCreateNestedOneWithoutUser_AddressInput = {
    create?: XOR<ProvinceCreateWithoutUser_AddressInput, ProvinceUncheckedCreateWithoutUser_AddressInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutUser_AddressInput
    connect?: ProvinceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUser_addressInput = {
    create?: XOR<UserCreateWithoutUser_addressInput, UserUncheckedCreateWithoutUser_addressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_addressInput
    connect?: UserWhereUniqueInput
  }

  export type CityUpdateOneWithoutUser_AddressInput = {
    create?: XOR<CityCreateWithoutUser_AddressInput, CityUncheckedCreateWithoutUser_AddressInput>
    connectOrCreate?: CityCreateOrConnectWithoutUser_AddressInput
    upsert?: CityUpsertWithoutUser_AddressInput
    connect?: CityWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CityUpdateWithoutUser_AddressInput, CityUncheckedUpdateWithoutUser_AddressInput>
  }

  export type ProvinceUpdateOneWithoutUser_AddressInput = {
    create?: XOR<ProvinceCreateWithoutUser_AddressInput, ProvinceUncheckedCreateWithoutUser_AddressInput>
    connectOrCreate?: ProvinceCreateOrConnectWithoutUser_AddressInput
    upsert?: ProvinceUpsertWithoutUser_AddressInput
    connect?: ProvinceWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ProvinceUpdateWithoutUser_AddressInput, ProvinceUncheckedUpdateWithoutUser_AddressInput>
  }

  export type UserUpdateOneRequiredWithoutUser_addressInput = {
    create?: XOR<UserCreateWithoutUser_addressInput, UserUncheckedCreateWithoutUser_addressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_addressInput
    upsert?: UserUpsertWithoutUser_addressInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUser_addressInput, UserUncheckedUpdateWithoutUser_addressInput>
  }

  export type UserCreateNestedOneWithoutUser_bankInput = {
    create?: XOR<UserCreateWithoutUser_bankInput, UserUncheckedCreateWithoutUser_bankInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_bankInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUser_bankInput = {
    create?: XOR<UserCreateWithoutUser_bankInput, UserUncheckedCreateWithoutUser_bankInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_bankInput
    upsert?: UserUpsertWithoutUser_bankInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUser_bankInput, UserUncheckedUpdateWithoutUser_bankInput>
  }

  export type VaccineHistoryCreateNestedManyWithoutVaccine_typeInput = {
    create?: XOR<Enumerable<VaccineHistoryCreateWithoutVaccine_typeInput>, Enumerable<VaccineHistoryUncheckedCreateWithoutVaccine_typeInput>>
    connectOrCreate?: Enumerable<VaccineHistoryCreateOrConnectWithoutVaccine_typeInput>
    createMany?: VaccineHistoryCreateManyVaccine_typeInputEnvelope
    connect?: Enumerable<VaccineHistoryWhereUniqueInput>
  }

  export type VaccineHistoryUncheckedCreateNestedManyWithoutVaccine_typeInput = {
    create?: XOR<Enumerable<VaccineHistoryCreateWithoutVaccine_typeInput>, Enumerable<VaccineHistoryUncheckedCreateWithoutVaccine_typeInput>>
    connectOrCreate?: Enumerable<VaccineHistoryCreateOrConnectWithoutVaccine_typeInput>
    createMany?: VaccineHistoryCreateManyVaccine_typeInputEnvelope
    connect?: Enumerable<VaccineHistoryWhereUniqueInput>
  }

  export type VaccineHistoryUpdateManyWithoutVaccine_typeInput = {
    create?: XOR<Enumerable<VaccineHistoryCreateWithoutVaccine_typeInput>, Enumerable<VaccineHistoryUncheckedCreateWithoutVaccine_typeInput>>
    connectOrCreate?: Enumerable<VaccineHistoryCreateOrConnectWithoutVaccine_typeInput>
    upsert?: Enumerable<VaccineHistoryUpsertWithWhereUniqueWithoutVaccine_typeInput>
    createMany?: VaccineHistoryCreateManyVaccine_typeInputEnvelope
    connect?: Enumerable<VaccineHistoryWhereUniqueInput>
    set?: Enumerable<VaccineHistoryWhereUniqueInput>
    disconnect?: Enumerable<VaccineHistoryWhereUniqueInput>
    delete?: Enumerable<VaccineHistoryWhereUniqueInput>
    update?: Enumerable<VaccineHistoryUpdateWithWhereUniqueWithoutVaccine_typeInput>
    updateMany?: Enumerable<VaccineHistoryUpdateManyWithWhereWithoutVaccine_typeInput>
    deleteMany?: Enumerable<VaccineHistoryScalarWhereInput>
  }

  export type VaccineHistoryUncheckedUpdateManyWithoutVaccine_typeInput = {
    create?: XOR<Enumerable<VaccineHistoryCreateWithoutVaccine_typeInput>, Enumerable<VaccineHistoryUncheckedCreateWithoutVaccine_typeInput>>
    connectOrCreate?: Enumerable<VaccineHistoryCreateOrConnectWithoutVaccine_typeInput>
    upsert?: Enumerable<VaccineHistoryUpsertWithWhereUniqueWithoutVaccine_typeInput>
    createMany?: VaccineHistoryCreateManyVaccine_typeInputEnvelope
    connect?: Enumerable<VaccineHistoryWhereUniqueInput>
    set?: Enumerable<VaccineHistoryWhereUniqueInput>
    disconnect?: Enumerable<VaccineHistoryWhereUniqueInput>
    delete?: Enumerable<VaccineHistoryWhereUniqueInput>
    update?: Enumerable<VaccineHistoryUpdateWithWhereUniqueWithoutVaccine_typeInput>
    updateMany?: Enumerable<VaccineHistoryUpdateManyWithWhereWithoutVaccine_typeInput>
    deleteMany?: Enumerable<VaccineHistoryScalarWhereInput>
  }

  export type UserPetsCreateNestedOneWithoutVaccineHistoryInput = {
    create?: XOR<UserPetsCreateWithoutVaccineHistoryInput, UserPetsUncheckedCreateWithoutVaccineHistoryInput>
    connectOrCreate?: UserPetsCreateOrConnectWithoutVaccineHistoryInput
    connect?: UserPetsWhereUniqueInput
  }

  export type VaccineTypeCreateNestedOneWithoutVaccineHistoryInput = {
    create?: XOR<VaccineTypeCreateWithoutVaccineHistoryInput, VaccineTypeUncheckedCreateWithoutVaccineHistoryInput>
    connectOrCreate?: VaccineTypeCreateOrConnectWithoutVaccineHistoryInput
    connect?: VaccineTypeWhereUniqueInput
  }

  export type VaccineHistoryPhotoCreateNestedManyWithoutVaccine_historyInput = {
    create?: XOR<Enumerable<VaccineHistoryPhotoCreateWithoutVaccine_historyInput>, Enumerable<VaccineHistoryPhotoUncheckedCreateWithoutVaccine_historyInput>>
    connectOrCreate?: Enumerable<VaccineHistoryPhotoCreateOrConnectWithoutVaccine_historyInput>
    createMany?: VaccineHistoryPhotoCreateManyVaccine_historyInputEnvelope
    connect?: Enumerable<VaccineHistoryPhotoWhereUniqueInput>
  }

  export type VaccineHistoryPhotoUncheckedCreateNestedManyWithoutVaccine_historyInput = {
    create?: XOR<Enumerable<VaccineHistoryPhotoCreateWithoutVaccine_historyInput>, Enumerable<VaccineHistoryPhotoUncheckedCreateWithoutVaccine_historyInput>>
    connectOrCreate?: Enumerable<VaccineHistoryPhotoCreateOrConnectWithoutVaccine_historyInput>
    createMany?: VaccineHistoryPhotoCreateManyVaccine_historyInputEnvelope
    connect?: Enumerable<VaccineHistoryPhotoWhereUniqueInput>
  }

  export type UserPetsUpdateOneWithoutVaccineHistoryInput = {
    create?: XOR<UserPetsCreateWithoutVaccineHistoryInput, UserPetsUncheckedCreateWithoutVaccineHistoryInput>
    connectOrCreate?: UserPetsCreateOrConnectWithoutVaccineHistoryInput
    upsert?: UserPetsUpsertWithoutVaccineHistoryInput
    connect?: UserPetsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserPetsUpdateWithoutVaccineHistoryInput, UserPetsUncheckedUpdateWithoutVaccineHistoryInput>
  }

  export type VaccineTypeUpdateOneWithoutVaccineHistoryInput = {
    create?: XOR<VaccineTypeCreateWithoutVaccineHistoryInput, VaccineTypeUncheckedCreateWithoutVaccineHistoryInput>
    connectOrCreate?: VaccineTypeCreateOrConnectWithoutVaccineHistoryInput
    upsert?: VaccineTypeUpsertWithoutVaccineHistoryInput
    connect?: VaccineTypeWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<VaccineTypeUpdateWithoutVaccineHistoryInput, VaccineTypeUncheckedUpdateWithoutVaccineHistoryInput>
  }

  export type VaccineHistoryPhotoUpdateManyWithoutVaccine_historyInput = {
    create?: XOR<Enumerable<VaccineHistoryPhotoCreateWithoutVaccine_historyInput>, Enumerable<VaccineHistoryPhotoUncheckedCreateWithoutVaccine_historyInput>>
    connectOrCreate?: Enumerable<VaccineHistoryPhotoCreateOrConnectWithoutVaccine_historyInput>
    upsert?: Enumerable<VaccineHistoryPhotoUpsertWithWhereUniqueWithoutVaccine_historyInput>
    createMany?: VaccineHistoryPhotoCreateManyVaccine_historyInputEnvelope
    connect?: Enumerable<VaccineHistoryPhotoWhereUniqueInput>
    set?: Enumerable<VaccineHistoryPhotoWhereUniqueInput>
    disconnect?: Enumerable<VaccineHistoryPhotoWhereUniqueInput>
    delete?: Enumerable<VaccineHistoryPhotoWhereUniqueInput>
    update?: Enumerable<VaccineHistoryPhotoUpdateWithWhereUniqueWithoutVaccine_historyInput>
    updateMany?: Enumerable<VaccineHistoryPhotoUpdateManyWithWhereWithoutVaccine_historyInput>
    deleteMany?: Enumerable<VaccineHistoryPhotoScalarWhereInput>
  }

  export type VaccineHistoryPhotoUncheckedUpdateManyWithoutVaccine_historyInput = {
    create?: XOR<Enumerable<VaccineHistoryPhotoCreateWithoutVaccine_historyInput>, Enumerable<VaccineHistoryPhotoUncheckedCreateWithoutVaccine_historyInput>>
    connectOrCreate?: Enumerable<VaccineHistoryPhotoCreateOrConnectWithoutVaccine_historyInput>
    upsert?: Enumerable<VaccineHistoryPhotoUpsertWithWhereUniqueWithoutVaccine_historyInput>
    createMany?: VaccineHistoryPhotoCreateManyVaccine_historyInputEnvelope
    connect?: Enumerable<VaccineHistoryPhotoWhereUniqueInput>
    set?: Enumerable<VaccineHistoryPhotoWhereUniqueInput>
    disconnect?: Enumerable<VaccineHistoryPhotoWhereUniqueInput>
    delete?: Enumerable<VaccineHistoryPhotoWhereUniqueInput>
    update?: Enumerable<VaccineHistoryPhotoUpdateWithWhereUniqueWithoutVaccine_historyInput>
    updateMany?: Enumerable<VaccineHistoryPhotoUpdateManyWithWhereWithoutVaccine_historyInput>
    deleteMany?: Enumerable<VaccineHistoryPhotoScalarWhereInput>
  }

  export type VaccineHistoryCreateNestedOneWithoutVaccineHistoryPhotoInput = {
    create?: XOR<VaccineHistoryCreateWithoutVaccineHistoryPhotoInput, VaccineHistoryUncheckedCreateWithoutVaccineHistoryPhotoInput>
    connectOrCreate?: VaccineHistoryCreateOrConnectWithoutVaccineHistoryPhotoInput
    connect?: VaccineHistoryWhereUniqueInput
  }

  export type VaccineHistoryUpdateOneRequiredWithoutVaccineHistoryPhotoInput = {
    create?: XOR<VaccineHistoryCreateWithoutVaccineHistoryPhotoInput, VaccineHistoryUncheckedCreateWithoutVaccineHistoryPhotoInput>
    connectOrCreate?: VaccineHistoryCreateOrConnectWithoutVaccineHistoryPhotoInput
    upsert?: VaccineHistoryUpsertWithoutVaccineHistoryPhotoInput
    connect?: VaccineHistoryWhereUniqueInput
    update?: XOR<VaccineHistoryUpdateWithoutVaccineHistoryPhotoInput, VaccineHistoryUncheckedUpdateWithoutVaccineHistoryPhotoInput>
  }

  export type Vendor_DocumentsCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<Vendor_DocumentsCreateWithoutVendorsInput>, Enumerable<Vendor_DocumentsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<Vendor_DocumentsCreateOrConnectWithoutVendorsInput>
    createMany?: Vendor_DocumentsCreateManyVendorsInputEnvelope
    connect?: Enumerable<Vendor_DocumentsWhereUniqueInput>
  }

  export type Vendor_MedtreatsCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<Vendor_MedtreatsCreateWithoutVendorsInput>, Enumerable<Vendor_MedtreatsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<Vendor_MedtreatsCreateOrConnectWithoutVendorsInput>
    createMany?: Vendor_MedtreatsCreateManyVendorsInputEnvelope
    connect?: Enumerable<Vendor_MedtreatsWhereUniqueInput>
  }

  export type FeedbacksCreateNestedManyWithoutVendorInput = {
    create?: XOR<Enumerable<FeedbacksCreateWithoutVendorInput>, Enumerable<FeedbacksUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<FeedbacksCreateOrConnectWithoutVendorInput>
    createMany?: FeedbacksCreateManyVendorInputEnvelope
    connect?: Enumerable<FeedbacksWhereUniqueInput>
  }

  export type Vendor_DocumentsUncheckedCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<Vendor_DocumentsCreateWithoutVendorsInput>, Enumerable<Vendor_DocumentsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<Vendor_DocumentsCreateOrConnectWithoutVendorsInput>
    createMany?: Vendor_DocumentsCreateManyVendorsInputEnvelope
    connect?: Enumerable<Vendor_DocumentsWhereUniqueInput>
  }

  export type Vendor_MedtreatsUncheckedCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<Vendor_MedtreatsCreateWithoutVendorsInput>, Enumerable<Vendor_MedtreatsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<Vendor_MedtreatsCreateOrConnectWithoutVendorsInput>
    createMany?: Vendor_MedtreatsCreateManyVendorsInputEnvelope
    connect?: Enumerable<Vendor_MedtreatsWhereUniqueInput>
  }

  export type FeedbacksUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<Enumerable<FeedbacksCreateWithoutVendorInput>, Enumerable<FeedbacksUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<FeedbacksCreateOrConnectWithoutVendorInput>
    createMany?: FeedbacksCreateManyVendorInputEnvelope
    connect?: Enumerable<FeedbacksWhereUniqueInput>
  }

  export type NullableEnumTypeFieldUpdateOperationsInput = {
    set?: Type | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type Vendor_DocumentsUpdateManyWithoutVendorsInput = {
    create?: XOR<Enumerable<Vendor_DocumentsCreateWithoutVendorsInput>, Enumerable<Vendor_DocumentsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<Vendor_DocumentsCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<Vendor_DocumentsUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: Vendor_DocumentsCreateManyVendorsInputEnvelope
    connect?: Enumerable<Vendor_DocumentsWhereUniqueInput>
    set?: Enumerable<Vendor_DocumentsWhereUniqueInput>
    disconnect?: Enumerable<Vendor_DocumentsWhereUniqueInput>
    delete?: Enumerable<Vendor_DocumentsWhereUniqueInput>
    update?: Enumerable<Vendor_DocumentsUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<Vendor_DocumentsUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<Vendor_DocumentsScalarWhereInput>
  }

  export type Vendor_MedtreatsUpdateManyWithoutVendorsInput = {
    create?: XOR<Enumerable<Vendor_MedtreatsCreateWithoutVendorsInput>, Enumerable<Vendor_MedtreatsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<Vendor_MedtreatsCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<Vendor_MedtreatsUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: Vendor_MedtreatsCreateManyVendorsInputEnvelope
    connect?: Enumerable<Vendor_MedtreatsWhereUniqueInput>
    set?: Enumerable<Vendor_MedtreatsWhereUniqueInput>
    disconnect?: Enumerable<Vendor_MedtreatsWhereUniqueInput>
    delete?: Enumerable<Vendor_MedtreatsWhereUniqueInput>
    update?: Enumerable<Vendor_MedtreatsUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<Vendor_MedtreatsUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<Vendor_MedtreatsScalarWhereInput>
  }

  export type FeedbacksUpdateManyWithoutVendorInput = {
    create?: XOR<Enumerable<FeedbacksCreateWithoutVendorInput>, Enumerable<FeedbacksUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<FeedbacksCreateOrConnectWithoutVendorInput>
    upsert?: Enumerable<FeedbacksUpsertWithWhereUniqueWithoutVendorInput>
    createMany?: FeedbacksCreateManyVendorInputEnvelope
    connect?: Enumerable<FeedbacksWhereUniqueInput>
    set?: Enumerable<FeedbacksWhereUniqueInput>
    disconnect?: Enumerable<FeedbacksWhereUniqueInput>
    delete?: Enumerable<FeedbacksWhereUniqueInput>
    update?: Enumerable<FeedbacksUpdateWithWhereUniqueWithoutVendorInput>
    updateMany?: Enumerable<FeedbacksUpdateManyWithWhereWithoutVendorInput>
    deleteMany?: Enumerable<FeedbacksScalarWhereInput>
  }

  export type Vendor_DocumentsUncheckedUpdateManyWithoutVendorsInput = {
    create?: XOR<Enumerable<Vendor_DocumentsCreateWithoutVendorsInput>, Enumerable<Vendor_DocumentsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<Vendor_DocumentsCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<Vendor_DocumentsUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: Vendor_DocumentsCreateManyVendorsInputEnvelope
    connect?: Enumerable<Vendor_DocumentsWhereUniqueInput>
    set?: Enumerable<Vendor_DocumentsWhereUniqueInput>
    disconnect?: Enumerable<Vendor_DocumentsWhereUniqueInput>
    delete?: Enumerable<Vendor_DocumentsWhereUniqueInput>
    update?: Enumerable<Vendor_DocumentsUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<Vendor_DocumentsUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<Vendor_DocumentsScalarWhereInput>
  }

  export type Vendor_MedtreatsUncheckedUpdateManyWithoutVendorsInput = {
    create?: XOR<Enumerable<Vendor_MedtreatsCreateWithoutVendorsInput>, Enumerable<Vendor_MedtreatsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<Vendor_MedtreatsCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<Vendor_MedtreatsUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: Vendor_MedtreatsCreateManyVendorsInputEnvelope
    connect?: Enumerable<Vendor_MedtreatsWhereUniqueInput>
    set?: Enumerable<Vendor_MedtreatsWhereUniqueInput>
    disconnect?: Enumerable<Vendor_MedtreatsWhereUniqueInput>
    delete?: Enumerable<Vendor_MedtreatsWhereUniqueInput>
    update?: Enumerable<Vendor_MedtreatsUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<Vendor_MedtreatsUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<Vendor_MedtreatsScalarWhereInput>
  }

  export type FeedbacksUncheckedUpdateManyWithoutVendorInput = {
    create?: XOR<Enumerable<FeedbacksCreateWithoutVendorInput>, Enumerable<FeedbacksUncheckedCreateWithoutVendorInput>>
    connectOrCreate?: Enumerable<FeedbacksCreateOrConnectWithoutVendorInput>
    upsert?: Enumerable<FeedbacksUpsertWithWhereUniqueWithoutVendorInput>
    createMany?: FeedbacksCreateManyVendorInputEnvelope
    connect?: Enumerable<FeedbacksWhereUniqueInput>
    set?: Enumerable<FeedbacksWhereUniqueInput>
    disconnect?: Enumerable<FeedbacksWhereUniqueInput>
    delete?: Enumerable<FeedbacksWhereUniqueInput>
    update?: Enumerable<FeedbacksUpdateWithWhereUniqueWithoutVendorInput>
    updateMany?: Enumerable<FeedbacksUpdateManyWithWhereWithoutVendorInput>
    deleteMany?: Enumerable<FeedbacksScalarWhereInput>
  }

  export type VendorsCreateNestedOneWithoutVendor_documentsInput = {
    create?: XOR<VendorsCreateWithoutVendor_documentsInput, VendorsUncheckedCreateWithoutVendor_documentsInput>
    connectOrCreate?: VendorsCreateOrConnectWithoutVendor_documentsInput
    connect?: VendorsWhereUniqueInput
  }

  export type VendorsUpdateOneRequiredWithoutVendor_documentsInput = {
    create?: XOR<VendorsCreateWithoutVendor_documentsInput, VendorsUncheckedCreateWithoutVendor_documentsInput>
    connectOrCreate?: VendorsCreateOrConnectWithoutVendor_documentsInput
    upsert?: VendorsUpsertWithoutVendor_documentsInput
    connect?: VendorsWhereUniqueInput
    update?: XOR<VendorsUpdateWithoutVendor_documentsInput, VendorsUncheckedUpdateWithoutVendor_documentsInput>
  }

  export type VendorsCreateNestedOneWithoutVendor_medtreatsInput = {
    create?: XOR<VendorsCreateWithoutVendor_medtreatsInput, VendorsUncheckedCreateWithoutVendor_medtreatsInput>
    connectOrCreate?: VendorsCreateOrConnectWithoutVendor_medtreatsInput
    connect?: VendorsWhereUniqueInput
  }

  export type VendorsUpdateOneRequiredWithoutVendor_medtreatsInput = {
    create?: XOR<VendorsCreateWithoutVendor_medtreatsInput, VendorsUncheckedCreateWithoutVendor_medtreatsInput>
    connectOrCreate?: VendorsCreateOrConnectWithoutVendor_medtreatsInput
    upsert?: VendorsUpsertWithoutVendor_medtreatsInput
    connect?: VendorsWhereUniqueInput
    update?: XOR<VendorsUpdateWithoutVendor_medtreatsInput, VendorsUncheckedUpdateWithoutVendor_medtreatsInput>
  }

  export type SpeciesCreateNestedManyWithoutClassInput = {
    create?: XOR<Enumerable<SpeciesCreateWithoutClassInput>, Enumerable<SpeciesUncheckedCreateWithoutClassInput>>
    connectOrCreate?: Enumerable<SpeciesCreateOrConnectWithoutClassInput>
    createMany?: SpeciesCreateManyClassInputEnvelope
    connect?: Enumerable<SpeciesWhereUniqueInput>
  }

  export type SpeciesUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<Enumerable<SpeciesCreateWithoutClassInput>, Enumerable<SpeciesUncheckedCreateWithoutClassInput>>
    connectOrCreate?: Enumerable<SpeciesCreateOrConnectWithoutClassInput>
    createMany?: SpeciesCreateManyClassInputEnvelope
    connect?: Enumerable<SpeciesWhereUniqueInput>
  }

  export type SpeciesUpdateManyWithoutClassInput = {
    create?: XOR<Enumerable<SpeciesCreateWithoutClassInput>, Enumerable<SpeciesUncheckedCreateWithoutClassInput>>
    connectOrCreate?: Enumerable<SpeciesCreateOrConnectWithoutClassInput>
    upsert?: Enumerable<SpeciesUpsertWithWhereUniqueWithoutClassInput>
    createMany?: SpeciesCreateManyClassInputEnvelope
    connect?: Enumerable<SpeciesWhereUniqueInput>
    set?: Enumerable<SpeciesWhereUniqueInput>
    disconnect?: Enumerable<SpeciesWhereUniqueInput>
    delete?: Enumerable<SpeciesWhereUniqueInput>
    update?: Enumerable<SpeciesUpdateWithWhereUniqueWithoutClassInput>
    updateMany?: Enumerable<SpeciesUpdateManyWithWhereWithoutClassInput>
    deleteMany?: Enumerable<SpeciesScalarWhereInput>
  }

  export type SpeciesUncheckedUpdateManyWithoutClassInput = {
    create?: XOR<Enumerable<SpeciesCreateWithoutClassInput>, Enumerable<SpeciesUncheckedCreateWithoutClassInput>>
    connectOrCreate?: Enumerable<SpeciesCreateOrConnectWithoutClassInput>
    upsert?: Enumerable<SpeciesUpsertWithWhereUniqueWithoutClassInput>
    createMany?: SpeciesCreateManyClassInputEnvelope
    connect?: Enumerable<SpeciesWhereUniqueInput>
    set?: Enumerable<SpeciesWhereUniqueInput>
    disconnect?: Enumerable<SpeciesWhereUniqueInput>
    delete?: Enumerable<SpeciesWhereUniqueInput>
    update?: Enumerable<SpeciesUpdateWithWhereUniqueWithoutClassInput>
    updateMany?: Enumerable<SpeciesUpdateManyWithWhereWithoutClassInput>
    deleteMany?: Enumerable<SpeciesScalarWhereInput>
  }

  export type ArticlesCreateNestedManyWithoutSpeciesInput = {
    create?: XOR<Enumerable<ArticlesCreateWithoutSpeciesInput>, Enumerable<ArticlesUncheckedCreateWithoutSpeciesInput>>
    connectOrCreate?: Enumerable<ArticlesCreateOrConnectWithoutSpeciesInput>
    createMany?: ArticlesCreateManySpeciesInputEnvelope
    connect?: Enumerable<ArticlesWhereUniqueInput>
  }

  export type ClassCreateNestedOneWithoutSpeciesInput = {
    create?: XOR<ClassCreateWithoutSpeciesInput, ClassUncheckedCreateWithoutSpeciesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSpeciesInput
    connect?: ClassWhereUniqueInput
  }

  export type ArticlesUncheckedCreateNestedManyWithoutSpeciesInput = {
    create?: XOR<Enumerable<ArticlesCreateWithoutSpeciesInput>, Enumerable<ArticlesUncheckedCreateWithoutSpeciesInput>>
    connectOrCreate?: Enumerable<ArticlesCreateOrConnectWithoutSpeciesInput>
    createMany?: ArticlesCreateManySpeciesInputEnvelope
    connect?: Enumerable<ArticlesWhereUniqueInput>
  }

  export type ArticlesUpdateManyWithoutSpeciesInput = {
    create?: XOR<Enumerable<ArticlesCreateWithoutSpeciesInput>, Enumerable<ArticlesUncheckedCreateWithoutSpeciesInput>>
    connectOrCreate?: Enumerable<ArticlesCreateOrConnectWithoutSpeciesInput>
    upsert?: Enumerable<ArticlesUpsertWithWhereUniqueWithoutSpeciesInput>
    createMany?: ArticlesCreateManySpeciesInputEnvelope
    connect?: Enumerable<ArticlesWhereUniqueInput>
    set?: Enumerable<ArticlesWhereUniqueInput>
    disconnect?: Enumerable<ArticlesWhereUniqueInput>
    delete?: Enumerable<ArticlesWhereUniqueInput>
    update?: Enumerable<ArticlesUpdateWithWhereUniqueWithoutSpeciesInput>
    updateMany?: Enumerable<ArticlesUpdateManyWithWhereWithoutSpeciesInput>
    deleteMany?: Enumerable<ArticlesScalarWhereInput>
  }

  export type ClassUpdateOneRequiredWithoutSpeciesInput = {
    create?: XOR<ClassCreateWithoutSpeciesInput, ClassUncheckedCreateWithoutSpeciesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSpeciesInput
    upsert?: ClassUpsertWithoutSpeciesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<ClassUpdateWithoutSpeciesInput, ClassUncheckedUpdateWithoutSpeciesInput>
  }

  export type ArticlesUncheckedUpdateManyWithoutSpeciesInput = {
    create?: XOR<Enumerable<ArticlesCreateWithoutSpeciesInput>, Enumerable<ArticlesUncheckedCreateWithoutSpeciesInput>>
    connectOrCreate?: Enumerable<ArticlesCreateOrConnectWithoutSpeciesInput>
    upsert?: Enumerable<ArticlesUpsertWithWhereUniqueWithoutSpeciesInput>
    createMany?: ArticlesCreateManySpeciesInputEnvelope
    connect?: Enumerable<ArticlesWhereUniqueInput>
    set?: Enumerable<ArticlesWhereUniqueInput>
    disconnect?: Enumerable<ArticlesWhereUniqueInput>
    delete?: Enumerable<ArticlesWhereUniqueInput>
    update?: Enumerable<ArticlesUpdateWithWhereUniqueWithoutSpeciesInput>
    updateMany?: Enumerable<ArticlesUpdateManyWithWhereWithoutSpeciesInput>
    deleteMany?: Enumerable<ArticlesScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutConsultationsInput = {
    create?: XOR<UserCreateWithoutConsultationsInput, UserUncheckedCreateWithoutConsultationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConsultationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserPetsCreateNestedOneWithoutConsultationsInput = {
    create?: XOR<UserPetsCreateWithoutConsultationsInput, UserPetsUncheckedCreateWithoutConsultationsInput>
    connectOrCreate?: UserPetsCreateOrConnectWithoutConsultationsInput
    connect?: UserPetsWhereUniqueInput
  }

  export type UserUpdateOneWithoutConsultationsInput = {
    create?: XOR<UserCreateWithoutConsultationsInput, UserUncheckedCreateWithoutConsultationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConsultationsInput
    upsert?: UserUpsertWithoutConsultationsInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserUpdateWithoutConsultationsInput, UserUncheckedUpdateWithoutConsultationsInput>
  }

  export type UserPetsUpdateOneWithoutConsultationsInput = {
    create?: XOR<UserPetsCreateWithoutConsultationsInput, UserPetsUncheckedCreateWithoutConsultationsInput>
    connectOrCreate?: UserPetsCreateOrConnectWithoutConsultationsInput
    upsert?: UserPetsUpsertWithoutConsultationsInput
    connect?: UserPetsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserPetsUpdateWithoutConsultationsInput, UserPetsUncheckedUpdateWithoutConsultationsInput>
  }

  export type SpeciesCreateNestedOneWithoutArticlesInput = {
    create?: XOR<SpeciesCreateWithoutArticlesInput, SpeciesUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: SpeciesCreateOrConnectWithoutArticlesInput
    connect?: SpeciesWhereUniqueInput
  }

  export type SpeciesUpdateOneRequiredWithoutArticlesInput = {
    create?: XOR<SpeciesCreateWithoutArticlesInput, SpeciesUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: SpeciesCreateOrConnectWithoutArticlesInput
    upsert?: SpeciesUpsertWithoutArticlesInput
    connect?: SpeciesWhereUniqueInput
    update?: XOR<SpeciesUpdateWithoutArticlesInput, SpeciesUncheckedUpdateWithoutArticlesInput>
  }

  export type VendorsCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<VendorsCreateWithoutFeedbacksInput, VendorsUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: VendorsCreateOrConnectWithoutFeedbacksInput
    connect?: VendorsWhereUniqueInput
  }

  export type VendorsUpdateOneWithoutFeedbacksInput = {
    create?: XOR<VendorsCreateWithoutFeedbacksInput, VendorsUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: VendorsCreateOrConnectWithoutFeedbacksInput
    upsert?: VendorsUpsertWithoutFeedbacksInput
    connect?: VendorsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<VendorsUpdateWithoutFeedbacksInput, VendorsUncheckedUpdateWithoutFeedbacksInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringFilter
    _max?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedEnumGenderNullableFilter = {
    equals?: Gender | null
    in?: Enumerable<Gender> | null
    notIn?: Enumerable<Gender> | null
    not?: NestedEnumGenderNullableFilter | Gender | null
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringNullableFilter
  }

  export type NestedEnumGenderNullableWithAggregatesFilter = {
    equals?: Gender | null
    in?: Enumerable<Gender> | null
    notIn?: Enumerable<Gender> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter | Gender | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedEnumGenderNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumGenderNullableFilter
    _max?: NestedEnumGenderNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumGenderNullableFilter
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolNullableFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeNullableFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolFilter
    _max?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolFilter
  }

  export type NestedEnumTypeNullableFilter = {
    equals?: Type | null
    in?: Enumerable<Type> | null
    notIn?: Enumerable<Type> | null
    not?: NestedEnumTypeNullableFilter | Type | null
  }

  export type NestedEnumTypeNullableWithAggregatesFilter = {
    equals?: Type | null
    in?: Enumerable<Type> | null
    notIn?: Enumerable<Type> | null
    not?: NestedEnumTypeNullableWithAggregatesFilter | Type | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedEnumTypeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumTypeNullableFilter
    _max?: NestedEnumTypeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumTypeNullableFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedFloatNullableFilter
  }

  export type CityCreateWithoutProvinceInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    User_Address?: User_AddressCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutProvinceInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    User_Address?: User_AddressUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutProvinceInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput>
  }

  export type CityCreateManyProvinceInputEnvelope = {
    data: Enumerable<CityCreateManyProvinceInput>
    skipDuplicates?: boolean
  }

  export type User_AddressCreateWithoutProvinceInput = {
    uid: string
    label: string
    address: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    City?: CityCreateNestedOneWithoutUser_AddressInput
    User: UserCreateNestedOneWithoutUser_addressInput
  }

  export type User_AddressUncheckedCreateWithoutProvinceInput = {
    id?: number
    uid: string
    label: string
    address: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    city_id?: number | null
    user_id: string
  }

  export type User_AddressCreateOrConnectWithoutProvinceInput = {
    where: User_AddressWhereUniqueInput
    create: XOR<User_AddressCreateWithoutProvinceInput, User_AddressUncheckedCreateWithoutProvinceInput>
  }

  export type User_AddressCreateManyProvinceInputEnvelope = {
    data: Enumerable<User_AddressCreateManyProvinceInput>
    skipDuplicates?: boolean
  }

  export type CityUpsertWithWhereUniqueWithoutProvinceInput = {
    where: CityWhereUniqueInput
    update: XOR<CityUpdateWithoutProvinceInput, CityUncheckedUpdateWithoutProvinceInput>
    create: XOR<CityCreateWithoutProvinceInput, CityUncheckedCreateWithoutProvinceInput>
  }

  export type CityUpdateWithWhereUniqueWithoutProvinceInput = {
    where: CityWhereUniqueInput
    data: XOR<CityUpdateWithoutProvinceInput, CityUncheckedUpdateWithoutProvinceInput>
  }

  export type CityUpdateManyWithWhereWithoutProvinceInput = {
    where: CityScalarWhereInput
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyWithoutCityInput>
  }

  export type CityScalarWhereInput = {
    AND?: Enumerable<CityScalarWhereInput>
    OR?: Enumerable<CityScalarWhereInput>
    NOT?: Enumerable<CityScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    province_id?: IntNullableFilter | number | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type User_AddressUpsertWithWhereUniqueWithoutProvinceInput = {
    where: User_AddressWhereUniqueInput
    update: XOR<User_AddressUpdateWithoutProvinceInput, User_AddressUncheckedUpdateWithoutProvinceInput>
    create: XOR<User_AddressCreateWithoutProvinceInput, User_AddressUncheckedCreateWithoutProvinceInput>
  }

  export type User_AddressUpdateWithWhereUniqueWithoutProvinceInput = {
    where: User_AddressWhereUniqueInput
    data: XOR<User_AddressUpdateWithoutProvinceInput, User_AddressUncheckedUpdateWithoutProvinceInput>
  }

  export type User_AddressUpdateManyWithWhereWithoutProvinceInput = {
    where: User_AddressScalarWhereInput
    data: XOR<User_AddressUpdateManyMutationInput, User_AddressUncheckedUpdateManyWithoutUser_AddressInput>
  }

  export type User_AddressScalarWhereInput = {
    AND?: Enumerable<User_AddressScalarWhereInput>
    OR?: Enumerable<User_AddressScalarWhereInput>
    NOT?: Enumerable<User_AddressScalarWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    label?: StringFilter | string
    address?: StringFilter | string
    is_default?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeNullableFilter | Date | string | null
    city_id?: IntNullableFilter | number | null
    province_id?: IntNullableFilter | number | null
    user_id?: StringFilter | string
  }

  export type ProvinceCreateWithoutCityInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    User_Address?: User_AddressCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateWithoutCityInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    User_Address?: User_AddressUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceCreateOrConnectWithoutCityInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutCityInput, ProvinceUncheckedCreateWithoutCityInput>
  }

  export type User_AddressCreateWithoutCityInput = {
    uid: string
    label: string
    address: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    Province?: ProvinceCreateNestedOneWithoutUser_AddressInput
    User: UserCreateNestedOneWithoutUser_addressInput
  }

  export type User_AddressUncheckedCreateWithoutCityInput = {
    id?: number
    uid: string
    label: string
    address: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    province_id?: number | null
    user_id: string
  }

  export type User_AddressCreateOrConnectWithoutCityInput = {
    where: User_AddressWhereUniqueInput
    create: XOR<User_AddressCreateWithoutCityInput, User_AddressUncheckedCreateWithoutCityInput>
  }

  export type User_AddressCreateManyCityInputEnvelope = {
    data: Enumerable<User_AddressCreateManyCityInput>
    skipDuplicates?: boolean
  }

  export type ProvinceUpsertWithoutCityInput = {
    update: XOR<ProvinceUpdateWithoutCityInput, ProvinceUncheckedUpdateWithoutCityInput>
    create: XOR<ProvinceCreateWithoutCityInput, ProvinceUncheckedCreateWithoutCityInput>
  }

  export type ProvinceUpdateWithoutCityInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Address?: User_AddressUpdateManyWithoutProvinceInput
  }

  export type ProvinceUncheckedUpdateWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Address?: User_AddressUncheckedUpdateManyWithoutProvinceInput
  }

  export type User_AddressUpsertWithWhereUniqueWithoutCityInput = {
    where: User_AddressWhereUniqueInput
    update: XOR<User_AddressUpdateWithoutCityInput, User_AddressUncheckedUpdateWithoutCityInput>
    create: XOR<User_AddressCreateWithoutCityInput, User_AddressUncheckedCreateWithoutCityInput>
  }

  export type User_AddressUpdateWithWhereUniqueWithoutCityInput = {
    where: User_AddressWhereUniqueInput
    data: XOR<User_AddressUpdateWithoutCityInput, User_AddressUncheckedUpdateWithoutCityInput>
  }

  export type User_AddressUpdateManyWithWhereWithoutCityInput = {
    where: User_AddressScalarWhereInput
    data: XOR<User_AddressUpdateManyMutationInput, User_AddressUncheckedUpdateManyWithoutUser_AddressInput>
  }

  export type User_AddressCreateWithoutUserInput = {
    uid: string
    label: string
    address: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    City?: CityCreateNestedOneWithoutUser_AddressInput
    Province?: ProvinceCreateNestedOneWithoutUser_AddressInput
  }

  export type User_AddressUncheckedCreateWithoutUserInput = {
    id?: number
    uid: string
    label: string
    address: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    city_id?: number | null
    province_id?: number | null
  }

  export type User_AddressCreateOrConnectWithoutUserInput = {
    where: User_AddressWhereUniqueInput
    create: XOR<User_AddressCreateWithoutUserInput, User_AddressUncheckedCreateWithoutUserInput>
  }

  export type User_AddressCreateManyUserInputEnvelope = {
    data: Enumerable<User_AddressCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type User_BankCreateWithoutUserInput = {
    uid: string
    alias: string
    bank_name: string
    account_number: string
    bank_username: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
  }

  export type User_BankUncheckedCreateWithoutUserInput = {
    id?: number
    uid: string
    alias: string
    bank_name: string
    account_number: string
    bank_username: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
  }

  export type User_BankCreateOrConnectWithoutUserInput = {
    where: User_BankWhereUniqueInput
    create: XOR<User_BankCreateWithoutUserInput, User_BankUncheckedCreateWithoutUserInput>
  }

  export type User_BankCreateManyUserInputEnvelope = {
    data: Enumerable<User_BankCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserPetsCreateWithoutUserInput = {
    uid: string
    name: string
    species?: string | null
    breed?: string | null
    date_of_birth?: Date | string | null
    color?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    is_neutered?: boolean | null
    is_dog_friendly?: boolean | null
    is_cat_friendly?: boolean | null
    is_under_10_child_friendly?: boolean | null
    is_over_10_child_friendly?: boolean | null
    is_microchipped?: boolean | null
    is_purebred?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    VaccineHistory?: VaccineHistoryCreateNestedManyWithoutPetInput
    Consultations?: ConsultationsCreateNestedManyWithoutPetInput
  }

  export type UserPetsUncheckedCreateWithoutUserInput = {
    id?: number
    uid: string
    name: string
    species?: string | null
    breed?: string | null
    date_of_birth?: Date | string | null
    color?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    is_neutered?: boolean | null
    is_dog_friendly?: boolean | null
    is_cat_friendly?: boolean | null
    is_under_10_child_friendly?: boolean | null
    is_over_10_child_friendly?: boolean | null
    is_microchipped?: boolean | null
    is_purebred?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    VaccineHistory?: VaccineHistoryUncheckedCreateNestedManyWithoutPetInput
    Consultations?: ConsultationsUncheckedCreateNestedManyWithoutPetInput
  }

  export type UserPetsCreateOrConnectWithoutUserInput = {
    where: UserPetsWhereUniqueInput
    create: XOR<UserPetsCreateWithoutUserInput, UserPetsUncheckedCreateWithoutUserInput>
  }

  export type UserPetsCreateManyUserInputEnvelope = {
    data: Enumerable<UserPetsCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ConsultationsCreateWithoutUserInput = {
    uid: string
    vendor_id: string
    chat_room_id: string
    vendor_role?: Type | null
    diagnose: string
    prerequisite: string
    date: string
    time_start: string
    time_end: string
    order_status: string
    reject_reason: string
    total_payment: number
    payment_image_url: string
    rating: number
    comment: string
    user_bank_id: number
    vendor_bank_id: number
    user_address_id: number
    created_at?: Date | string
    updated_at?: Date | string
    Pet?: UserPetsCreateNestedOneWithoutConsultationsInput
  }

  export type ConsultationsUncheckedCreateWithoutUserInput = {
    id?: number
    uid: string
    pet_id: string
    vendor_id: string
    chat_room_id: string
    vendor_role?: Type | null
    diagnose: string
    prerequisite: string
    date: string
    time_start: string
    time_end: string
    order_status: string
    reject_reason: string
    total_payment: number
    payment_image_url: string
    rating: number
    comment: string
    user_bank_id: number
    vendor_bank_id: number
    user_address_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ConsultationsCreateOrConnectWithoutUserInput = {
    where: ConsultationsWhereUniqueInput
    create: XOR<ConsultationsCreateWithoutUserInput, ConsultationsUncheckedCreateWithoutUserInput>
  }

  export type ConsultationsCreateManyUserInputEnvelope = {
    data: Enumerable<ConsultationsCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type User_AddressUpsertWithWhereUniqueWithoutUserInput = {
    where: User_AddressWhereUniqueInput
    update: XOR<User_AddressUpdateWithoutUserInput, User_AddressUncheckedUpdateWithoutUserInput>
    create: XOR<User_AddressCreateWithoutUserInput, User_AddressUncheckedCreateWithoutUserInput>
  }

  export type User_AddressUpdateWithWhereUniqueWithoutUserInput = {
    where: User_AddressWhereUniqueInput
    data: XOR<User_AddressUpdateWithoutUserInput, User_AddressUncheckedUpdateWithoutUserInput>
  }

  export type User_AddressUpdateManyWithWhereWithoutUserInput = {
    where: User_AddressScalarWhereInput
    data: XOR<User_AddressUpdateManyMutationInput, User_AddressUncheckedUpdateManyWithoutUser_addressInput>
  }

  export type User_BankUpsertWithWhereUniqueWithoutUserInput = {
    where: User_BankWhereUniqueInput
    update: XOR<User_BankUpdateWithoutUserInput, User_BankUncheckedUpdateWithoutUserInput>
    create: XOR<User_BankCreateWithoutUserInput, User_BankUncheckedCreateWithoutUserInput>
  }

  export type User_BankUpdateWithWhereUniqueWithoutUserInput = {
    where: User_BankWhereUniqueInput
    data: XOR<User_BankUpdateWithoutUserInput, User_BankUncheckedUpdateWithoutUserInput>
  }

  export type User_BankUpdateManyWithWhereWithoutUserInput = {
    where: User_BankScalarWhereInput
    data: XOR<User_BankUpdateManyMutationInput, User_BankUncheckedUpdateManyWithoutUser_bankInput>
  }

  export type User_BankScalarWhereInput = {
    AND?: Enumerable<User_BankScalarWhereInput>
    OR?: Enumerable<User_BankScalarWhereInput>
    NOT?: Enumerable<User_BankScalarWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    alias?: StringFilter | string
    bank_name?: StringFilter | string
    account_number?: StringFilter | string
    bank_username?: StringFilter | string
    is_default?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeNullableFilter | Date | string | null
    UserId?: IntFilter | number
  }

  export type UserPetsUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPetsWhereUniqueInput
    update: XOR<UserPetsUpdateWithoutUserInput, UserPetsUncheckedUpdateWithoutUserInput>
    create: XOR<UserPetsCreateWithoutUserInput, UserPetsUncheckedCreateWithoutUserInput>
  }

  export type UserPetsUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPetsWhereUniqueInput
    data: XOR<UserPetsUpdateWithoutUserInput, UserPetsUncheckedUpdateWithoutUserInput>
  }

  export type UserPetsUpdateManyWithWhereWithoutUserInput = {
    where: UserPetsScalarWhereInput
    data: XOR<UserPetsUpdateManyMutationInput, UserPetsUncheckedUpdateManyWithoutUser_petsInput>
  }

  export type UserPetsScalarWhereInput = {
    AND?: Enumerable<UserPetsScalarWhereInput>
    OR?: Enumerable<UserPetsScalarWhereInput>
    NOT?: Enumerable<UserPetsScalarWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    name?: StringFilter | string
    species?: StringNullableFilter | string | null
    breed?: StringNullableFilter | string | null
    date_of_birth?: DateTimeNullableFilter | Date | string | null
    color?: StringNullableFilter | string | null
    profile_picture_url?: StringNullableFilter | string | null
    gender?: EnumGenderNullableFilter | Gender | null
    is_neutered?: BoolNullableFilter | boolean | null
    is_dog_friendly?: BoolNullableFilter | boolean | null
    is_cat_friendly?: BoolNullableFilter | boolean | null
    is_under_10_child_friendly?: BoolNullableFilter | boolean | null
    is_over_10_child_friendly?: BoolNullableFilter | boolean | null
    is_microchipped?: BoolNullableFilter | boolean | null
    is_purebred?: BoolNullableFilter | boolean | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
    UserId?: StringFilter | string
  }

  export type ConsultationsUpsertWithWhereUniqueWithoutUserInput = {
    where: ConsultationsWhereUniqueInput
    update: XOR<ConsultationsUpdateWithoutUserInput, ConsultationsUncheckedUpdateWithoutUserInput>
    create: XOR<ConsultationsCreateWithoutUserInput, ConsultationsUncheckedCreateWithoutUserInput>
  }

  export type ConsultationsUpdateWithWhereUniqueWithoutUserInput = {
    where: ConsultationsWhereUniqueInput
    data: XOR<ConsultationsUpdateWithoutUserInput, ConsultationsUncheckedUpdateWithoutUserInput>
  }

  export type ConsultationsUpdateManyWithWhereWithoutUserInput = {
    where: ConsultationsScalarWhereInput
    data: XOR<ConsultationsUpdateManyMutationInput, ConsultationsUncheckedUpdateManyWithoutConsultationsInput>
  }

  export type ConsultationsScalarWhereInput = {
    AND?: Enumerable<ConsultationsScalarWhereInput>
    OR?: Enumerable<ConsultationsScalarWhereInput>
    NOT?: Enumerable<ConsultationsScalarWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    user_id?: StringFilter | string
    pet_id?: StringFilter | string
    vendor_id?: StringFilter | string
    chat_room_id?: StringFilter | string
    vendor_role?: EnumTypeNullableFilter | Type | null
    diagnose?: StringFilter | string
    prerequisite?: StringFilter | string
    date?: StringFilter | string
    time_start?: StringFilter | string
    time_end?: StringFilter | string
    order_status?: StringFilter | string
    reject_reason?: StringFilter | string
    total_payment?: IntFilter | number
    payment_image_url?: StringFilter | string
    rating?: IntFilter | number
    comment?: StringFilter | string
    user_bank_id?: IntFilter | number
    vendor_bank_id?: IntFilter | number
    user_address_id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type TokenCreateWithoutAdminsInput = {
    created_at: Date | string
    updated_at: Date | string
    valid: boolean
    expiration: Date | string
  }

  export type TokenUncheckedCreateWithoutAdminsInput = {
    id?: number
    created_at: Date | string
    updated_at: Date | string
    valid: boolean
    expiration: Date | string
  }

  export type TokenCreateOrConnectWithoutAdminsInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutAdminsInput, TokenUncheckedCreateWithoutAdminsInput>
  }

  export type TokenCreateManyAdminsInputEnvelope = {
    data: Enumerable<TokenCreateManyAdminsInput>
    skipDuplicates?: boolean
  }

  export type TokenUpsertWithWhereUniqueWithoutAdminsInput = {
    where: TokenWhereUniqueInput
    update: XOR<TokenUpdateWithoutAdminsInput, TokenUncheckedUpdateWithoutAdminsInput>
    create: XOR<TokenCreateWithoutAdminsInput, TokenUncheckedCreateWithoutAdminsInput>
  }

  export type TokenUpdateWithWhereUniqueWithoutAdminsInput = {
    where: TokenWhereUniqueInput
    data: XOR<TokenUpdateWithoutAdminsInput, TokenUncheckedUpdateWithoutAdminsInput>
  }

  export type TokenUpdateManyWithWhereWithoutAdminsInput = {
    where: TokenScalarWhereInput
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyWithoutTokensInput>
  }

  export type TokenScalarWhereInput = {
    AND?: Enumerable<TokenScalarWhereInput>
    OR?: Enumerable<TokenScalarWhereInput>
    NOT?: Enumerable<TokenScalarWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    valid?: BoolFilter | boolean
    expiration?: DateTimeFilter | Date | string
    AdminsId?: IntFilter | number
  }

  export type AdminsCreateWithoutTokensInput = {
    uid: string
    email: string
    name?: string | null
    username?: string | null
    phone_number?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    password?: string | null
    is_active?: boolean
    created_at?: Date | string
  }

  export type AdminsUncheckedCreateWithoutTokensInput = {
    id?: number
    uid: string
    email: string
    name?: string | null
    username?: string | null
    phone_number?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    password?: string | null
    is_active?: boolean
    created_at?: Date | string
  }

  export type AdminsCreateOrConnectWithoutTokensInput = {
    where: AdminsWhereUniqueInput
    create: XOR<AdminsCreateWithoutTokensInput, AdminsUncheckedCreateWithoutTokensInput>
  }

  export type AdminsUpsertWithoutTokensInput = {
    update: XOR<AdminsUpdateWithoutTokensInput, AdminsUncheckedUpdateWithoutTokensInput>
    create: XOR<AdminsCreateWithoutTokensInput, AdminsUncheckedCreateWithoutTokensInput>
  }

  export type AdminsUpdateWithoutTokensInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminsUncheckedUpdateWithoutTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutUser_petsInput = {
    uid: string
    email: string
    name?: string | null
    username?: string | null
    phone_number?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    birthdate?: string | null
    password?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    user_address?: User_AddressCreateNestedManyWithoutUserInput
    user_bank?: User_BankCreateNestedManyWithoutUserInput
    Consultations?: ConsultationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_petsInput = {
    id?: number
    uid: string
    email: string
    name?: string | null
    username?: string | null
    phone_number?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    birthdate?: string | null
    password?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    user_address?: User_AddressUncheckedCreateNestedManyWithoutUserInput
    user_bank?: User_BankUncheckedCreateNestedManyWithoutUserInput
    Consultations?: ConsultationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_petsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_petsInput, UserUncheckedCreateWithoutUser_petsInput>
  }

  export type VaccineHistoryCreateWithoutPetInput = {
    uid: string
    veterinary: string
    vaccine_photo: string
    date_administered: Date | string
    is_manual: boolean
    date_valid_until: Date | string
    created_at?: Date | string
    updated_at: Date | string
    vaccine_type?: VaccineTypeCreateNestedOneWithoutVaccineHistoryInput
    VaccineHistoryPhoto?: VaccineHistoryPhotoCreateNestedManyWithoutVaccine_historyInput
  }

  export type VaccineHistoryUncheckedCreateWithoutPetInput = {
    id?: number
    uid: string
    veterinary: string
    vaccine_photo: string
    date_administered: Date | string
    is_manual: boolean
    date_valid_until: Date | string
    vaccine_type_id?: number | null
    created_at?: Date | string
    updated_at: Date | string
    VaccineHistoryPhoto?: VaccineHistoryPhotoUncheckedCreateNestedManyWithoutVaccine_historyInput
  }

  export type VaccineHistoryCreateOrConnectWithoutPetInput = {
    where: VaccineHistoryWhereUniqueInput
    create: XOR<VaccineHistoryCreateWithoutPetInput, VaccineHistoryUncheckedCreateWithoutPetInput>
  }

  export type VaccineHistoryCreateManyPetInputEnvelope = {
    data: Enumerable<VaccineHistoryCreateManyPetInput>
    skipDuplicates?: boolean
  }

  export type ConsultationsCreateWithoutPetInput = {
    uid: string
    vendor_id: string
    chat_room_id: string
    vendor_role?: Type | null
    diagnose: string
    prerequisite: string
    date: string
    time_start: string
    time_end: string
    order_status: string
    reject_reason: string
    total_payment: number
    payment_image_url: string
    rating: number
    comment: string
    user_bank_id: number
    vendor_bank_id: number
    user_address_id: number
    created_at?: Date | string
    updated_at?: Date | string
    User?: UserCreateNestedOneWithoutConsultationsInput
  }

  export type ConsultationsUncheckedCreateWithoutPetInput = {
    id?: number
    uid: string
    user_id: string
    vendor_id: string
    chat_room_id: string
    vendor_role?: Type | null
    diagnose: string
    prerequisite: string
    date: string
    time_start: string
    time_end: string
    order_status: string
    reject_reason: string
    total_payment: number
    payment_image_url: string
    rating: number
    comment: string
    user_bank_id: number
    vendor_bank_id: number
    user_address_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ConsultationsCreateOrConnectWithoutPetInput = {
    where: ConsultationsWhereUniqueInput
    create: XOR<ConsultationsCreateWithoutPetInput, ConsultationsUncheckedCreateWithoutPetInput>
  }

  export type ConsultationsCreateManyPetInputEnvelope = {
    data: Enumerable<ConsultationsCreateManyPetInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutUser_petsInput = {
    update: XOR<UserUpdateWithoutUser_petsInput, UserUncheckedUpdateWithoutUser_petsInput>
    create: XOR<UserCreateWithoutUser_petsInput, UserUncheckedCreateWithoutUser_petsInput>
  }

  export type UserUpdateWithoutUser_petsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_address?: User_AddressUpdateManyWithoutUserInput
    user_bank?: User_BankUpdateManyWithoutUserInput
    Consultations?: ConsultationsUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUser_petsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_address?: User_AddressUncheckedUpdateManyWithoutUserInput
    user_bank?: User_BankUncheckedUpdateManyWithoutUserInput
    Consultations?: ConsultationsUncheckedUpdateManyWithoutUserInput
  }

  export type VaccineHistoryUpsertWithWhereUniqueWithoutPetInput = {
    where: VaccineHistoryWhereUniqueInput
    update: XOR<VaccineHistoryUpdateWithoutPetInput, VaccineHistoryUncheckedUpdateWithoutPetInput>
    create: XOR<VaccineHistoryCreateWithoutPetInput, VaccineHistoryUncheckedCreateWithoutPetInput>
  }

  export type VaccineHistoryUpdateWithWhereUniqueWithoutPetInput = {
    where: VaccineHistoryWhereUniqueInput
    data: XOR<VaccineHistoryUpdateWithoutPetInput, VaccineHistoryUncheckedUpdateWithoutPetInput>
  }

  export type VaccineHistoryUpdateManyWithWhereWithoutPetInput = {
    where: VaccineHistoryScalarWhereInput
    data: XOR<VaccineHistoryUpdateManyMutationInput, VaccineHistoryUncheckedUpdateManyWithoutVaccineHistoryInput>
  }

  export type VaccineHistoryScalarWhereInput = {
    AND?: Enumerable<VaccineHistoryScalarWhereInput>
    OR?: Enumerable<VaccineHistoryScalarWhereInput>
    NOT?: Enumerable<VaccineHistoryScalarWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    pet_id?: StringFilter | string
    veterinary?: StringFilter | string
    vaccine_photo?: StringFilter | string
    date_administered?: DateTimeFilter | Date | string
    is_manual?: BoolFilter | boolean
    date_valid_until?: DateTimeFilter | Date | string
    vaccine_type_id?: IntNullableFilter | number | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type ConsultationsUpsertWithWhereUniqueWithoutPetInput = {
    where: ConsultationsWhereUniqueInput
    update: XOR<ConsultationsUpdateWithoutPetInput, ConsultationsUncheckedUpdateWithoutPetInput>
    create: XOR<ConsultationsCreateWithoutPetInput, ConsultationsUncheckedCreateWithoutPetInput>
  }

  export type ConsultationsUpdateWithWhereUniqueWithoutPetInput = {
    where: ConsultationsWhereUniqueInput
    data: XOR<ConsultationsUpdateWithoutPetInput, ConsultationsUncheckedUpdateWithoutPetInput>
  }

  export type ConsultationsUpdateManyWithWhereWithoutPetInput = {
    where: ConsultationsScalarWhereInput
    data: XOR<ConsultationsUpdateManyMutationInput, ConsultationsUncheckedUpdateManyWithoutConsultationsInput>
  }

  export type CityCreateWithoutUser_AddressInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    Province?: ProvinceCreateNestedOneWithoutCityInput
  }

  export type CityUncheckedCreateWithoutUser_AddressInput = {
    id?: number
    name: string
    province_id?: number | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type CityCreateOrConnectWithoutUser_AddressInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutUser_AddressInput, CityUncheckedCreateWithoutUser_AddressInput>
  }

  export type ProvinceCreateWithoutUser_AddressInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    City?: CityCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceUncheckedCreateWithoutUser_AddressInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    City?: CityUncheckedCreateNestedManyWithoutProvinceInput
  }

  export type ProvinceCreateOrConnectWithoutUser_AddressInput = {
    where: ProvinceWhereUniqueInput
    create: XOR<ProvinceCreateWithoutUser_AddressInput, ProvinceUncheckedCreateWithoutUser_AddressInput>
  }

  export type UserCreateWithoutUser_addressInput = {
    uid: string
    email: string
    name?: string | null
    username?: string | null
    phone_number?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    birthdate?: string | null
    password?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    user_bank?: User_BankCreateNestedManyWithoutUserInput
    user_pets?: UserPetsCreateNestedManyWithoutUserInput
    Consultations?: ConsultationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_addressInput = {
    id?: number
    uid: string
    email: string
    name?: string | null
    username?: string | null
    phone_number?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    birthdate?: string | null
    password?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    user_bank?: User_BankUncheckedCreateNestedManyWithoutUserInput
    user_pets?: UserPetsUncheckedCreateNestedManyWithoutUserInput
    Consultations?: ConsultationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_addressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_addressInput, UserUncheckedCreateWithoutUser_addressInput>
  }

  export type CityUpsertWithoutUser_AddressInput = {
    update: XOR<CityUpdateWithoutUser_AddressInput, CityUncheckedUpdateWithoutUser_AddressInput>
    create: XOR<CityCreateWithoutUser_AddressInput, CityUncheckedCreateWithoutUser_AddressInput>
  }

  export type CityUpdateWithoutUser_AddressInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Province?: ProvinceUpdateOneWithoutCityInput
  }

  export type CityUncheckedUpdateWithoutUser_AddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    province_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProvinceUpsertWithoutUser_AddressInput = {
    update: XOR<ProvinceUpdateWithoutUser_AddressInput, ProvinceUncheckedUpdateWithoutUser_AddressInput>
    create: XOR<ProvinceCreateWithoutUser_AddressInput, ProvinceUncheckedCreateWithoutUser_AddressInput>
  }

  export type ProvinceUpdateWithoutUser_AddressInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    City?: CityUpdateManyWithoutProvinceInput
  }

  export type ProvinceUncheckedUpdateWithoutUser_AddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    City?: CityUncheckedUpdateManyWithoutProvinceInput
  }

  export type UserUpsertWithoutUser_addressInput = {
    update: XOR<UserUpdateWithoutUser_addressInput, UserUncheckedUpdateWithoutUser_addressInput>
    create: XOR<UserCreateWithoutUser_addressInput, UserUncheckedCreateWithoutUser_addressInput>
  }

  export type UserUpdateWithoutUser_addressInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_bank?: User_BankUpdateManyWithoutUserInput
    user_pets?: UserPetsUpdateManyWithoutUserInput
    Consultations?: ConsultationsUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUser_addressInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_bank?: User_BankUncheckedUpdateManyWithoutUserInput
    user_pets?: UserPetsUncheckedUpdateManyWithoutUserInput
    Consultations?: ConsultationsUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutUser_bankInput = {
    uid: string
    email: string
    name?: string | null
    username?: string | null
    phone_number?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    birthdate?: string | null
    password?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    user_address?: User_AddressCreateNestedManyWithoutUserInput
    user_pets?: UserPetsCreateNestedManyWithoutUserInput
    Consultations?: ConsultationsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_bankInput = {
    id?: number
    uid: string
    email: string
    name?: string | null
    username?: string | null
    phone_number?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    birthdate?: string | null
    password?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    user_address?: User_AddressUncheckedCreateNestedManyWithoutUserInput
    user_pets?: UserPetsUncheckedCreateNestedManyWithoutUserInput
    Consultations?: ConsultationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_bankInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_bankInput, UserUncheckedCreateWithoutUser_bankInput>
  }

  export type UserUpsertWithoutUser_bankInput = {
    update: XOR<UserUpdateWithoutUser_bankInput, UserUncheckedUpdateWithoutUser_bankInput>
    create: XOR<UserCreateWithoutUser_bankInput, UserUncheckedCreateWithoutUser_bankInput>
  }

  export type UserUpdateWithoutUser_bankInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_address?: User_AddressUpdateManyWithoutUserInput
    user_pets?: UserPetsUpdateManyWithoutUserInput
    Consultations?: ConsultationsUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutUser_bankInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_address?: User_AddressUncheckedUpdateManyWithoutUserInput
    user_pets?: UserPetsUncheckedUpdateManyWithoutUserInput
    Consultations?: ConsultationsUncheckedUpdateManyWithoutUserInput
  }

  export type VaccineHistoryCreateWithoutVaccine_typeInput = {
    uid: string
    veterinary: string
    vaccine_photo: string
    date_administered: Date | string
    is_manual: boolean
    date_valid_until: Date | string
    created_at?: Date | string
    updated_at: Date | string
    pet?: UserPetsCreateNestedOneWithoutVaccineHistoryInput
    VaccineHistoryPhoto?: VaccineHistoryPhotoCreateNestedManyWithoutVaccine_historyInput
  }

  export type VaccineHistoryUncheckedCreateWithoutVaccine_typeInput = {
    id?: number
    uid: string
    pet_id: string
    veterinary: string
    vaccine_photo: string
    date_administered: Date | string
    is_manual: boolean
    date_valid_until: Date | string
    created_at?: Date | string
    updated_at: Date | string
    VaccineHistoryPhoto?: VaccineHistoryPhotoUncheckedCreateNestedManyWithoutVaccine_historyInput
  }

  export type VaccineHistoryCreateOrConnectWithoutVaccine_typeInput = {
    where: VaccineHistoryWhereUniqueInput
    create: XOR<VaccineHistoryCreateWithoutVaccine_typeInput, VaccineHistoryUncheckedCreateWithoutVaccine_typeInput>
  }

  export type VaccineHistoryCreateManyVaccine_typeInputEnvelope = {
    data: Enumerable<VaccineHistoryCreateManyVaccine_typeInput>
    skipDuplicates?: boolean
  }

  export type VaccineHistoryUpsertWithWhereUniqueWithoutVaccine_typeInput = {
    where: VaccineHistoryWhereUniqueInput
    update: XOR<VaccineHistoryUpdateWithoutVaccine_typeInput, VaccineHistoryUncheckedUpdateWithoutVaccine_typeInput>
    create: XOR<VaccineHistoryCreateWithoutVaccine_typeInput, VaccineHistoryUncheckedCreateWithoutVaccine_typeInput>
  }

  export type VaccineHistoryUpdateWithWhereUniqueWithoutVaccine_typeInput = {
    where: VaccineHistoryWhereUniqueInput
    data: XOR<VaccineHistoryUpdateWithoutVaccine_typeInput, VaccineHistoryUncheckedUpdateWithoutVaccine_typeInput>
  }

  export type VaccineHistoryUpdateManyWithWhereWithoutVaccine_typeInput = {
    where: VaccineHistoryScalarWhereInput
    data: XOR<VaccineHistoryUpdateManyMutationInput, VaccineHistoryUncheckedUpdateManyWithoutVaccineHistoryInput>
  }

  export type UserPetsCreateWithoutVaccineHistoryInput = {
    uid: string
    name: string
    species?: string | null
    breed?: string | null
    date_of_birth?: Date | string | null
    color?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    is_neutered?: boolean | null
    is_dog_friendly?: boolean | null
    is_cat_friendly?: boolean | null
    is_under_10_child_friendly?: boolean | null
    is_over_10_child_friendly?: boolean | null
    is_microchipped?: boolean | null
    is_purebred?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    User: UserCreateNestedOneWithoutUser_petsInput
    Consultations?: ConsultationsCreateNestedManyWithoutPetInput
  }

  export type UserPetsUncheckedCreateWithoutVaccineHistoryInput = {
    id?: number
    uid: string
    name: string
    species?: string | null
    breed?: string | null
    date_of_birth?: Date | string | null
    color?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    is_neutered?: boolean | null
    is_dog_friendly?: boolean | null
    is_cat_friendly?: boolean | null
    is_under_10_child_friendly?: boolean | null
    is_over_10_child_friendly?: boolean | null
    is_microchipped?: boolean | null
    is_purebred?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    UserId: string
    Consultations?: ConsultationsUncheckedCreateNestedManyWithoutPetInput
  }

  export type UserPetsCreateOrConnectWithoutVaccineHistoryInput = {
    where: UserPetsWhereUniqueInput
    create: XOR<UserPetsCreateWithoutVaccineHistoryInput, UserPetsUncheckedCreateWithoutVaccineHistoryInput>
  }

  export type VaccineTypeCreateWithoutVaccineHistoryInput = {
    name: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type VaccineTypeUncheckedCreateWithoutVaccineHistoryInput = {
    id?: number
    name: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type VaccineTypeCreateOrConnectWithoutVaccineHistoryInput = {
    where: VaccineTypeWhereUniqueInput
    create: XOR<VaccineTypeCreateWithoutVaccineHistoryInput, VaccineTypeUncheckedCreateWithoutVaccineHistoryInput>
  }

  export type VaccineHistoryPhotoCreateWithoutVaccine_historyInput = {
    uid: string
    path: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type VaccineHistoryPhotoUncheckedCreateWithoutVaccine_historyInput = {
    id?: number
    uid: string
    path: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type VaccineHistoryPhotoCreateOrConnectWithoutVaccine_historyInput = {
    where: VaccineHistoryPhotoWhereUniqueInput
    create: XOR<VaccineHistoryPhotoCreateWithoutVaccine_historyInput, VaccineHistoryPhotoUncheckedCreateWithoutVaccine_historyInput>
  }

  export type VaccineHistoryPhotoCreateManyVaccine_historyInputEnvelope = {
    data: Enumerable<VaccineHistoryPhotoCreateManyVaccine_historyInput>
    skipDuplicates?: boolean
  }

  export type UserPetsUpsertWithoutVaccineHistoryInput = {
    update: XOR<UserPetsUpdateWithoutVaccineHistoryInput, UserPetsUncheckedUpdateWithoutVaccineHistoryInput>
    create: XOR<UserPetsCreateWithoutVaccineHistoryInput, UserPetsUncheckedCreateWithoutVaccineHistoryInput>
  }

  export type UserPetsUpdateWithoutVaccineHistoryInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    species?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    is_neutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_dog_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_cat_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_under_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_over_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_microchipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_purebred?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutUser_petsInput
    Consultations?: ConsultationsUpdateManyWithoutPetInput
  }

  export type UserPetsUncheckedUpdateWithoutVaccineHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    species?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    is_neutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_dog_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_cat_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_under_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_over_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_microchipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_purebred?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserId?: StringFieldUpdateOperationsInput | string
    Consultations?: ConsultationsUncheckedUpdateManyWithoutPetInput
  }

  export type VaccineTypeUpsertWithoutVaccineHistoryInput = {
    update: XOR<VaccineTypeUpdateWithoutVaccineHistoryInput, VaccineTypeUncheckedUpdateWithoutVaccineHistoryInput>
    create: XOR<VaccineTypeCreateWithoutVaccineHistoryInput, VaccineTypeUncheckedCreateWithoutVaccineHistoryInput>
  }

  export type VaccineTypeUpdateWithoutVaccineHistoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccineTypeUncheckedUpdateWithoutVaccineHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccineHistoryPhotoUpsertWithWhereUniqueWithoutVaccine_historyInput = {
    where: VaccineHistoryPhotoWhereUniqueInput
    update: XOR<VaccineHistoryPhotoUpdateWithoutVaccine_historyInput, VaccineHistoryPhotoUncheckedUpdateWithoutVaccine_historyInput>
    create: XOR<VaccineHistoryPhotoCreateWithoutVaccine_historyInput, VaccineHistoryPhotoUncheckedCreateWithoutVaccine_historyInput>
  }

  export type VaccineHistoryPhotoUpdateWithWhereUniqueWithoutVaccine_historyInput = {
    where: VaccineHistoryPhotoWhereUniqueInput
    data: XOR<VaccineHistoryPhotoUpdateWithoutVaccine_historyInput, VaccineHistoryPhotoUncheckedUpdateWithoutVaccine_historyInput>
  }

  export type VaccineHistoryPhotoUpdateManyWithWhereWithoutVaccine_historyInput = {
    where: VaccineHistoryPhotoScalarWhereInput
    data: XOR<VaccineHistoryPhotoUpdateManyMutationInput, VaccineHistoryPhotoUncheckedUpdateManyWithoutVaccineHistoryPhotoInput>
  }

  export type VaccineHistoryPhotoScalarWhereInput = {
    AND?: Enumerable<VaccineHistoryPhotoScalarWhereInput>
    OR?: Enumerable<VaccineHistoryPhotoScalarWhereInput>
    NOT?: Enumerable<VaccineHistoryPhotoScalarWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    vaccine_history_id?: IntFilter | number
    path?: StringFilter | string
    description?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type VaccineHistoryCreateWithoutVaccineHistoryPhotoInput = {
    uid: string
    veterinary: string
    vaccine_photo: string
    date_administered: Date | string
    is_manual: boolean
    date_valid_until: Date | string
    created_at?: Date | string
    updated_at: Date | string
    pet?: UserPetsCreateNestedOneWithoutVaccineHistoryInput
    vaccine_type?: VaccineTypeCreateNestedOneWithoutVaccineHistoryInput
  }

  export type VaccineHistoryUncheckedCreateWithoutVaccineHistoryPhotoInput = {
    id?: number
    uid: string
    pet_id: string
    veterinary: string
    vaccine_photo: string
    date_administered: Date | string
    is_manual: boolean
    date_valid_until: Date | string
    vaccine_type_id?: number | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type VaccineHistoryCreateOrConnectWithoutVaccineHistoryPhotoInput = {
    where: VaccineHistoryWhereUniqueInput
    create: XOR<VaccineHistoryCreateWithoutVaccineHistoryPhotoInput, VaccineHistoryUncheckedCreateWithoutVaccineHistoryPhotoInput>
  }

  export type VaccineHistoryUpsertWithoutVaccineHistoryPhotoInput = {
    update: XOR<VaccineHistoryUpdateWithoutVaccineHistoryPhotoInput, VaccineHistoryUncheckedUpdateWithoutVaccineHistoryPhotoInput>
    create: XOR<VaccineHistoryCreateWithoutVaccineHistoryPhotoInput, VaccineHistoryUncheckedCreateWithoutVaccineHistoryPhotoInput>
  }

  export type VaccineHistoryUpdateWithoutVaccineHistoryPhotoInput = {
    uid?: StringFieldUpdateOperationsInput | string
    veterinary?: StringFieldUpdateOperationsInput | string
    vaccine_photo?: StringFieldUpdateOperationsInput | string
    date_administered?: DateTimeFieldUpdateOperationsInput | Date | string
    is_manual?: BoolFieldUpdateOperationsInput | boolean
    date_valid_until?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    pet?: UserPetsUpdateOneWithoutVaccineHistoryInput
    vaccine_type?: VaccineTypeUpdateOneWithoutVaccineHistoryInput
  }

  export type VaccineHistoryUncheckedUpdateWithoutVaccineHistoryPhotoInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    pet_id?: StringFieldUpdateOperationsInput | string
    veterinary?: StringFieldUpdateOperationsInput | string
    vaccine_photo?: StringFieldUpdateOperationsInput | string
    date_administered?: DateTimeFieldUpdateOperationsInput | Date | string
    is_manual?: BoolFieldUpdateOperationsInput | boolean
    date_valid_until?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccine_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Vendor_DocumentsCreateWithoutVendorsInput = {
    uid: string
    document_type: string
    document_path: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type Vendor_DocumentsUncheckedCreateWithoutVendorsInput = {
    id?: number
    uid: string
    document_type: string
    document_path: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type Vendor_DocumentsCreateOrConnectWithoutVendorsInput = {
    where: Vendor_DocumentsWhereUniqueInput
    create: XOR<Vendor_DocumentsCreateWithoutVendorsInput, Vendor_DocumentsUncheckedCreateWithoutVendorsInput>
  }

  export type Vendor_DocumentsCreateManyVendorsInputEnvelope = {
    data: Enumerable<Vendor_DocumentsCreateManyVendorsInput>
    skipDuplicates?: boolean
  }

  export type Vendor_MedtreatsCreateWithoutVendorsInput = {
    uid: string
    medical_treatment_id: string
    is_homecare: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type Vendor_MedtreatsUncheckedCreateWithoutVendorsInput = {
    id?: number
    uid: string
    medical_treatment_id: string
    is_homecare: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type Vendor_MedtreatsCreateOrConnectWithoutVendorsInput = {
    where: Vendor_MedtreatsWhereUniqueInput
    create: XOR<Vendor_MedtreatsCreateWithoutVendorsInput, Vendor_MedtreatsUncheckedCreateWithoutVendorsInput>
  }

  export type Vendor_MedtreatsCreateManyVendorsInputEnvelope = {
    data: Enumerable<Vendor_MedtreatsCreateManyVendorsInput>
    skipDuplicates?: boolean
  }

  export type FeedbacksCreateWithoutVendorInput = {
    user_id: number
    email: string
    title: string
    content: string
    rating: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type FeedbacksUncheckedCreateWithoutVendorInput = {
    id?: number
    user_id: number
    email: string
    title: string
    content: string
    rating: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type FeedbacksCreateOrConnectWithoutVendorInput = {
    where: FeedbacksWhereUniqueInput
    create: XOR<FeedbacksCreateWithoutVendorInput, FeedbacksUncheckedCreateWithoutVendorInput>
  }

  export type FeedbacksCreateManyVendorInputEnvelope = {
    data: Enumerable<FeedbacksCreateManyVendorInput>
    skipDuplicates?: boolean
  }

  export type Vendor_DocumentsUpsertWithWhereUniqueWithoutVendorsInput = {
    where: Vendor_DocumentsWhereUniqueInput
    update: XOR<Vendor_DocumentsUpdateWithoutVendorsInput, Vendor_DocumentsUncheckedUpdateWithoutVendorsInput>
    create: XOR<Vendor_DocumentsCreateWithoutVendorsInput, Vendor_DocumentsUncheckedCreateWithoutVendorsInput>
  }

  export type Vendor_DocumentsUpdateWithWhereUniqueWithoutVendorsInput = {
    where: Vendor_DocumentsWhereUniqueInput
    data: XOR<Vendor_DocumentsUpdateWithoutVendorsInput, Vendor_DocumentsUncheckedUpdateWithoutVendorsInput>
  }

  export type Vendor_DocumentsUpdateManyWithWhereWithoutVendorsInput = {
    where: Vendor_DocumentsScalarWhereInput
    data: XOR<Vendor_DocumentsUpdateManyMutationInput, Vendor_DocumentsUncheckedUpdateManyWithoutVendor_documentsInput>
  }

  export type Vendor_DocumentsScalarWhereInput = {
    AND?: Enumerable<Vendor_DocumentsScalarWhereInput>
    OR?: Enumerable<Vendor_DocumentsScalarWhereInput>
    NOT?: Enumerable<Vendor_DocumentsScalarWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    document_type?: StringFilter | string
    document_path?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    VendorsId?: IntFilter | number
  }

  export type Vendor_MedtreatsUpsertWithWhereUniqueWithoutVendorsInput = {
    where: Vendor_MedtreatsWhereUniqueInput
    update: XOR<Vendor_MedtreatsUpdateWithoutVendorsInput, Vendor_MedtreatsUncheckedUpdateWithoutVendorsInput>
    create: XOR<Vendor_MedtreatsCreateWithoutVendorsInput, Vendor_MedtreatsUncheckedCreateWithoutVendorsInput>
  }

  export type Vendor_MedtreatsUpdateWithWhereUniqueWithoutVendorsInput = {
    where: Vendor_MedtreatsWhereUniqueInput
    data: XOR<Vendor_MedtreatsUpdateWithoutVendorsInput, Vendor_MedtreatsUncheckedUpdateWithoutVendorsInput>
  }

  export type Vendor_MedtreatsUpdateManyWithWhereWithoutVendorsInput = {
    where: Vendor_MedtreatsScalarWhereInput
    data: XOR<Vendor_MedtreatsUpdateManyMutationInput, Vendor_MedtreatsUncheckedUpdateManyWithoutVendor_medtreatsInput>
  }

  export type Vendor_MedtreatsScalarWhereInput = {
    AND?: Enumerable<Vendor_MedtreatsScalarWhereInput>
    OR?: Enumerable<Vendor_MedtreatsScalarWhereInput>
    NOT?: Enumerable<Vendor_MedtreatsScalarWhereInput>
    id?: IntFilter | number
    uid?: StringFilter | string
    medical_treatment_id?: StringFilter | string
    is_homecare?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    VendorsId?: IntFilter | number
  }

  export type FeedbacksUpsertWithWhereUniqueWithoutVendorInput = {
    where: FeedbacksWhereUniqueInput
    update: XOR<FeedbacksUpdateWithoutVendorInput, FeedbacksUncheckedUpdateWithoutVendorInput>
    create: XOR<FeedbacksCreateWithoutVendorInput, FeedbacksUncheckedCreateWithoutVendorInput>
  }

  export type FeedbacksUpdateWithWhereUniqueWithoutVendorInput = {
    where: FeedbacksWhereUniqueInput
    data: XOR<FeedbacksUpdateWithoutVendorInput, FeedbacksUncheckedUpdateWithoutVendorInput>
  }

  export type FeedbacksUpdateManyWithWhereWithoutVendorInput = {
    where: FeedbacksScalarWhereInput
    data: XOR<FeedbacksUpdateManyMutationInput, FeedbacksUncheckedUpdateManyWithoutFeedbacksInput>
  }

  export type FeedbacksScalarWhereInput = {
    AND?: Enumerable<FeedbacksScalarWhereInput>
    OR?: Enumerable<FeedbacksScalarWhereInput>
    NOT?: Enumerable<FeedbacksScalarWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    vendor_id?: StringFilter | string
    email?: StringFilter | string
    title?: StringFilter | string
    content?: StringFilter | string
    rating?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type VendorsCreateWithoutVendor_documentsInput = {
    uid: string
    email: string
    is_verified: boolean
    vendor_role?: Type | null
    price: number
    total_patient?: number | null
    rating?: number | null
    name: string
    username: string
    address: string
    phone_number: string
    profile_picture_url: string
    gender?: Gender | null
    speciality: string
    birthdate: string
    google_maps_url: string
    str_number: string
    str_issued_date: string
    alumni: string
    city_id: number
    province_id: number
    lat: string
    long: string
    days: string
    ops_start_time: string
    ops_end_time: string
    duration: number
    rest: number
    total_poli: number
    image_url: string
    created_at?: Date | string
    updated_at?: Date | string
    vendor_medtreats?: Vendor_MedtreatsCreateNestedManyWithoutVendorsInput
    Feedbacks?: FeedbacksCreateNestedManyWithoutVendorInput
  }

  export type VendorsUncheckedCreateWithoutVendor_documentsInput = {
    id?: number
    uid: string
    email: string
    is_verified: boolean
    vendor_role?: Type | null
    price: number
    total_patient?: number | null
    rating?: number | null
    name: string
    username: string
    address: string
    phone_number: string
    profile_picture_url: string
    gender?: Gender | null
    speciality: string
    birthdate: string
    google_maps_url: string
    str_number: string
    str_issued_date: string
    alumni: string
    city_id: number
    province_id: number
    lat: string
    long: string
    days: string
    ops_start_time: string
    ops_end_time: string
    duration: number
    rest: number
    total_poli: number
    image_url: string
    created_at?: Date | string
    updated_at?: Date | string
    vendor_medtreats?: Vendor_MedtreatsUncheckedCreateNestedManyWithoutVendorsInput
    Feedbacks?: FeedbacksUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorsCreateOrConnectWithoutVendor_documentsInput = {
    where: VendorsWhereUniqueInput
    create: XOR<VendorsCreateWithoutVendor_documentsInput, VendorsUncheckedCreateWithoutVendor_documentsInput>
  }

  export type VendorsUpsertWithoutVendor_documentsInput = {
    update: XOR<VendorsUpdateWithoutVendor_documentsInput, VendorsUncheckedUpdateWithoutVendor_documentsInput>
    create: XOR<VendorsCreateWithoutVendor_documentsInput, VendorsUncheckedCreateWithoutVendor_documentsInput>
  }

  export type VendorsUpdateWithoutVendor_documentsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    vendor_role?: NullableEnumTypeFieldUpdateOperationsInput | Type | null
    price?: IntFieldUpdateOperationsInput | number
    total_patient?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    profile_picture_url?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    speciality?: StringFieldUpdateOperationsInput | string
    birthdate?: StringFieldUpdateOperationsInput | string
    google_maps_url?: StringFieldUpdateOperationsInput | string
    str_number?: StringFieldUpdateOperationsInput | string
    str_issued_date?: StringFieldUpdateOperationsInput | string
    alumni?: StringFieldUpdateOperationsInput | string
    city_id?: IntFieldUpdateOperationsInput | number
    province_id?: IntFieldUpdateOperationsInput | number
    lat?: StringFieldUpdateOperationsInput | string
    long?: StringFieldUpdateOperationsInput | string
    days?: StringFieldUpdateOperationsInput | string
    ops_start_time?: StringFieldUpdateOperationsInput | string
    ops_end_time?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    rest?: IntFieldUpdateOperationsInput | number
    total_poli?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor_medtreats?: Vendor_MedtreatsUpdateManyWithoutVendorsInput
    Feedbacks?: FeedbacksUpdateManyWithoutVendorInput
  }

  export type VendorsUncheckedUpdateWithoutVendor_documentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    vendor_role?: NullableEnumTypeFieldUpdateOperationsInput | Type | null
    price?: IntFieldUpdateOperationsInput | number
    total_patient?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    profile_picture_url?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    speciality?: StringFieldUpdateOperationsInput | string
    birthdate?: StringFieldUpdateOperationsInput | string
    google_maps_url?: StringFieldUpdateOperationsInput | string
    str_number?: StringFieldUpdateOperationsInput | string
    str_issued_date?: StringFieldUpdateOperationsInput | string
    alumni?: StringFieldUpdateOperationsInput | string
    city_id?: IntFieldUpdateOperationsInput | number
    province_id?: IntFieldUpdateOperationsInput | number
    lat?: StringFieldUpdateOperationsInput | string
    long?: StringFieldUpdateOperationsInput | string
    days?: StringFieldUpdateOperationsInput | string
    ops_start_time?: StringFieldUpdateOperationsInput | string
    ops_end_time?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    rest?: IntFieldUpdateOperationsInput | number
    total_poli?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor_medtreats?: Vendor_MedtreatsUncheckedUpdateManyWithoutVendorsInput
    Feedbacks?: FeedbacksUncheckedUpdateManyWithoutVendorInput
  }

  export type VendorsCreateWithoutVendor_medtreatsInput = {
    uid: string
    email: string
    is_verified: boolean
    vendor_role?: Type | null
    price: number
    total_patient?: number | null
    rating?: number | null
    name: string
    username: string
    address: string
    phone_number: string
    profile_picture_url: string
    gender?: Gender | null
    speciality: string
    birthdate: string
    google_maps_url: string
    str_number: string
    str_issued_date: string
    alumni: string
    city_id: number
    province_id: number
    lat: string
    long: string
    days: string
    ops_start_time: string
    ops_end_time: string
    duration: number
    rest: number
    total_poli: number
    image_url: string
    created_at?: Date | string
    updated_at?: Date | string
    vendor_documents?: Vendor_DocumentsCreateNestedManyWithoutVendorsInput
    Feedbacks?: FeedbacksCreateNestedManyWithoutVendorInput
  }

  export type VendorsUncheckedCreateWithoutVendor_medtreatsInput = {
    id?: number
    uid: string
    email: string
    is_verified: boolean
    vendor_role?: Type | null
    price: number
    total_patient?: number | null
    rating?: number | null
    name: string
    username: string
    address: string
    phone_number: string
    profile_picture_url: string
    gender?: Gender | null
    speciality: string
    birthdate: string
    google_maps_url: string
    str_number: string
    str_issued_date: string
    alumni: string
    city_id: number
    province_id: number
    lat: string
    long: string
    days: string
    ops_start_time: string
    ops_end_time: string
    duration: number
    rest: number
    total_poli: number
    image_url: string
    created_at?: Date | string
    updated_at?: Date | string
    vendor_documents?: Vendor_DocumentsUncheckedCreateNestedManyWithoutVendorsInput
    Feedbacks?: FeedbacksUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorsCreateOrConnectWithoutVendor_medtreatsInput = {
    where: VendorsWhereUniqueInput
    create: XOR<VendorsCreateWithoutVendor_medtreatsInput, VendorsUncheckedCreateWithoutVendor_medtreatsInput>
  }

  export type VendorsUpsertWithoutVendor_medtreatsInput = {
    update: XOR<VendorsUpdateWithoutVendor_medtreatsInput, VendorsUncheckedUpdateWithoutVendor_medtreatsInput>
    create: XOR<VendorsCreateWithoutVendor_medtreatsInput, VendorsUncheckedCreateWithoutVendor_medtreatsInput>
  }

  export type VendorsUpdateWithoutVendor_medtreatsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    vendor_role?: NullableEnumTypeFieldUpdateOperationsInput | Type | null
    price?: IntFieldUpdateOperationsInput | number
    total_patient?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    profile_picture_url?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    speciality?: StringFieldUpdateOperationsInput | string
    birthdate?: StringFieldUpdateOperationsInput | string
    google_maps_url?: StringFieldUpdateOperationsInput | string
    str_number?: StringFieldUpdateOperationsInput | string
    str_issued_date?: StringFieldUpdateOperationsInput | string
    alumni?: StringFieldUpdateOperationsInput | string
    city_id?: IntFieldUpdateOperationsInput | number
    province_id?: IntFieldUpdateOperationsInput | number
    lat?: StringFieldUpdateOperationsInput | string
    long?: StringFieldUpdateOperationsInput | string
    days?: StringFieldUpdateOperationsInput | string
    ops_start_time?: StringFieldUpdateOperationsInput | string
    ops_end_time?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    rest?: IntFieldUpdateOperationsInput | number
    total_poli?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor_documents?: Vendor_DocumentsUpdateManyWithoutVendorsInput
    Feedbacks?: FeedbacksUpdateManyWithoutVendorInput
  }

  export type VendorsUncheckedUpdateWithoutVendor_medtreatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    vendor_role?: NullableEnumTypeFieldUpdateOperationsInput | Type | null
    price?: IntFieldUpdateOperationsInput | number
    total_patient?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    profile_picture_url?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    speciality?: StringFieldUpdateOperationsInput | string
    birthdate?: StringFieldUpdateOperationsInput | string
    google_maps_url?: StringFieldUpdateOperationsInput | string
    str_number?: StringFieldUpdateOperationsInput | string
    str_issued_date?: StringFieldUpdateOperationsInput | string
    alumni?: StringFieldUpdateOperationsInput | string
    city_id?: IntFieldUpdateOperationsInput | number
    province_id?: IntFieldUpdateOperationsInput | number
    lat?: StringFieldUpdateOperationsInput | string
    long?: StringFieldUpdateOperationsInput | string
    days?: StringFieldUpdateOperationsInput | string
    ops_start_time?: StringFieldUpdateOperationsInput | string
    ops_end_time?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    rest?: IntFieldUpdateOperationsInput | number
    total_poli?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor_documents?: Vendor_DocumentsUncheckedUpdateManyWithoutVendorsInput
    Feedbacks?: FeedbacksUncheckedUpdateManyWithoutVendorInput
  }

  export type SpeciesCreateWithoutClassInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    Articles?: ArticlesCreateNestedManyWithoutSpeciesInput
  }

  export type SpeciesUncheckedCreateWithoutClassInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    Articles?: ArticlesUncheckedCreateNestedManyWithoutSpeciesInput
  }

  export type SpeciesCreateOrConnectWithoutClassInput = {
    where: SpeciesWhereUniqueInput
    create: XOR<SpeciesCreateWithoutClassInput, SpeciesUncheckedCreateWithoutClassInput>
  }

  export type SpeciesCreateManyClassInputEnvelope = {
    data: Enumerable<SpeciesCreateManyClassInput>
    skipDuplicates?: boolean
  }

  export type SpeciesUpsertWithWhereUniqueWithoutClassInput = {
    where: SpeciesWhereUniqueInput
    update: XOR<SpeciesUpdateWithoutClassInput, SpeciesUncheckedUpdateWithoutClassInput>
    create: XOR<SpeciesCreateWithoutClassInput, SpeciesUncheckedCreateWithoutClassInput>
  }

  export type SpeciesUpdateWithWhereUniqueWithoutClassInput = {
    where: SpeciesWhereUniqueInput
    data: XOR<SpeciesUpdateWithoutClassInput, SpeciesUncheckedUpdateWithoutClassInput>
  }

  export type SpeciesUpdateManyWithWhereWithoutClassInput = {
    where: SpeciesScalarWhereInput
    data: XOR<SpeciesUpdateManyMutationInput, SpeciesUncheckedUpdateManyWithoutSpeciesInput>
  }

  export type SpeciesScalarWhereInput = {
    AND?: Enumerable<SpeciesScalarWhereInput>
    OR?: Enumerable<SpeciesScalarWhereInput>
    NOT?: Enumerable<SpeciesScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    deleted_at?: DateTimeNullableFilter | Date | string | null
    ClassId?: IntFilter | number
  }

  export type ArticlesCreateWithoutSpeciesInput = {
    title: string
    content: string
    image_url: string
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ArticlesUncheckedCreateWithoutSpeciesInput = {
    id?: number
    title: string
    content: string
    image_url: string
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ArticlesCreateOrConnectWithoutSpeciesInput = {
    where: ArticlesWhereUniqueInput
    create: XOR<ArticlesCreateWithoutSpeciesInput, ArticlesUncheckedCreateWithoutSpeciesInput>
  }

  export type ArticlesCreateManySpeciesInputEnvelope = {
    data: Enumerable<ArticlesCreateManySpeciesInput>
    skipDuplicates?: boolean
  }

  export type ClassCreateWithoutSpeciesInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
  }

  export type ClassUncheckedCreateWithoutSpeciesInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
  }

  export type ClassCreateOrConnectWithoutSpeciesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSpeciesInput, ClassUncheckedCreateWithoutSpeciesInput>
  }

  export type ArticlesUpsertWithWhereUniqueWithoutSpeciesInput = {
    where: ArticlesWhereUniqueInput
    update: XOR<ArticlesUpdateWithoutSpeciesInput, ArticlesUncheckedUpdateWithoutSpeciesInput>
    create: XOR<ArticlesCreateWithoutSpeciesInput, ArticlesUncheckedCreateWithoutSpeciesInput>
  }

  export type ArticlesUpdateWithWhereUniqueWithoutSpeciesInput = {
    where: ArticlesWhereUniqueInput
    data: XOR<ArticlesUpdateWithoutSpeciesInput, ArticlesUncheckedUpdateWithoutSpeciesInput>
  }

  export type ArticlesUpdateManyWithWhereWithoutSpeciesInput = {
    where: ArticlesScalarWhereInput
    data: XOR<ArticlesUpdateManyMutationInput, ArticlesUncheckedUpdateManyWithoutArticlesInput>
  }

  export type ArticlesScalarWhereInput = {
    AND?: Enumerable<ArticlesScalarWhereInput>
    OR?: Enumerable<ArticlesScalarWhereInput>
    NOT?: Enumerable<ArticlesScalarWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    content?: StringFilter | string
    species_id?: IntFilter | number
    image_url?: StringFilter | string
    is_active?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type ClassUpsertWithoutSpeciesInput = {
    update: XOR<ClassUpdateWithoutSpeciesInput, ClassUncheckedUpdateWithoutSpeciesInput>
    create: XOR<ClassCreateWithoutSpeciesInput, ClassUncheckedCreateWithoutSpeciesInput>
  }

  export type ClassUpdateWithoutSpeciesInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClassUncheckedUpdateWithoutSpeciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutConsultationsInput = {
    uid: string
    email: string
    name?: string | null
    username?: string | null
    phone_number?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    birthdate?: string | null
    password?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    user_address?: User_AddressCreateNestedManyWithoutUserInput
    user_bank?: User_BankCreateNestedManyWithoutUserInput
    user_pets?: UserPetsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConsultationsInput = {
    id?: number
    uid: string
    email: string
    name?: string | null
    username?: string | null
    phone_number?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    birthdate?: string | null
    password?: string | null
    is_active?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    user_address?: User_AddressUncheckedCreateNestedManyWithoutUserInput
    user_bank?: User_BankUncheckedCreateNestedManyWithoutUserInput
    user_pets?: UserPetsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConsultationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConsultationsInput, UserUncheckedCreateWithoutConsultationsInput>
  }

  export type UserPetsCreateWithoutConsultationsInput = {
    uid: string
    name: string
    species?: string | null
    breed?: string | null
    date_of_birth?: Date | string | null
    color?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    is_neutered?: boolean | null
    is_dog_friendly?: boolean | null
    is_cat_friendly?: boolean | null
    is_under_10_child_friendly?: boolean | null
    is_over_10_child_friendly?: boolean | null
    is_microchipped?: boolean | null
    is_purebred?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    User: UserCreateNestedOneWithoutUser_petsInput
    VaccineHistory?: VaccineHistoryCreateNestedManyWithoutPetInput
  }

  export type UserPetsUncheckedCreateWithoutConsultationsInput = {
    id?: number
    uid: string
    name: string
    species?: string | null
    breed?: string | null
    date_of_birth?: Date | string | null
    color?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    is_neutered?: boolean | null
    is_dog_friendly?: boolean | null
    is_cat_friendly?: boolean | null
    is_under_10_child_friendly?: boolean | null
    is_over_10_child_friendly?: boolean | null
    is_microchipped?: boolean | null
    is_purebred?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    UserId: string
    VaccineHistory?: VaccineHistoryUncheckedCreateNestedManyWithoutPetInput
  }

  export type UserPetsCreateOrConnectWithoutConsultationsInput = {
    where: UserPetsWhereUniqueInput
    create: XOR<UserPetsCreateWithoutConsultationsInput, UserPetsUncheckedCreateWithoutConsultationsInput>
  }

  export type UserUpsertWithoutConsultationsInput = {
    update: XOR<UserUpdateWithoutConsultationsInput, UserUncheckedUpdateWithoutConsultationsInput>
    create: XOR<UserCreateWithoutConsultationsInput, UserUncheckedCreateWithoutConsultationsInput>
  }

  export type UserUpdateWithoutConsultationsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_address?: User_AddressUpdateManyWithoutUserInput
    user_bank?: User_BankUpdateManyWithoutUserInput
    user_pets?: UserPetsUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutConsultationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_address?: User_AddressUncheckedUpdateManyWithoutUserInput
    user_bank?: User_BankUncheckedUpdateManyWithoutUserInput
    user_pets?: UserPetsUncheckedUpdateManyWithoutUserInput
  }

  export type UserPetsUpsertWithoutConsultationsInput = {
    update: XOR<UserPetsUpdateWithoutConsultationsInput, UserPetsUncheckedUpdateWithoutConsultationsInput>
    create: XOR<UserPetsCreateWithoutConsultationsInput, UserPetsUncheckedCreateWithoutConsultationsInput>
  }

  export type UserPetsUpdateWithoutConsultationsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    species?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    is_neutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_dog_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_cat_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_under_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_over_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_microchipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_purebred?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutUser_petsInput
    VaccineHistory?: VaccineHistoryUpdateManyWithoutPetInput
  }

  export type UserPetsUncheckedUpdateWithoutConsultationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    species?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    is_neutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_dog_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_cat_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_under_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_over_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_microchipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_purebred?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserId?: StringFieldUpdateOperationsInput | string
    VaccineHistory?: VaccineHistoryUncheckedUpdateManyWithoutPetInput
  }

  export type SpeciesCreateWithoutArticlesInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    Class: ClassCreateNestedOneWithoutSpeciesInput
  }

  export type SpeciesUncheckedCreateWithoutArticlesInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    ClassId: number
  }

  export type SpeciesCreateOrConnectWithoutArticlesInput = {
    where: SpeciesWhereUniqueInput
    create: XOR<SpeciesCreateWithoutArticlesInput, SpeciesUncheckedCreateWithoutArticlesInput>
  }

  export type SpeciesUpsertWithoutArticlesInput = {
    update: XOR<SpeciesUpdateWithoutArticlesInput, SpeciesUncheckedUpdateWithoutArticlesInput>
    create: XOR<SpeciesCreateWithoutArticlesInput, SpeciesUncheckedCreateWithoutArticlesInput>
  }

  export type SpeciesUpdateWithoutArticlesInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Class?: ClassUpdateOneRequiredWithoutSpeciesInput
  }

  export type SpeciesUncheckedUpdateWithoutArticlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ClassId?: IntFieldUpdateOperationsInput | number
  }

  export type VendorsCreateWithoutFeedbacksInput = {
    uid: string
    email: string
    is_verified: boolean
    vendor_role?: Type | null
    price: number
    total_patient?: number | null
    rating?: number | null
    name: string
    username: string
    address: string
    phone_number: string
    profile_picture_url: string
    gender?: Gender | null
    speciality: string
    birthdate: string
    google_maps_url: string
    str_number: string
    str_issued_date: string
    alumni: string
    city_id: number
    province_id: number
    lat: string
    long: string
    days: string
    ops_start_time: string
    ops_end_time: string
    duration: number
    rest: number
    total_poli: number
    image_url: string
    created_at?: Date | string
    updated_at?: Date | string
    vendor_documents?: Vendor_DocumentsCreateNestedManyWithoutVendorsInput
    vendor_medtreats?: Vendor_MedtreatsCreateNestedManyWithoutVendorsInput
  }

  export type VendorsUncheckedCreateWithoutFeedbacksInput = {
    id?: number
    uid: string
    email: string
    is_verified: boolean
    vendor_role?: Type | null
    price: number
    total_patient?: number | null
    rating?: number | null
    name: string
    username: string
    address: string
    phone_number: string
    profile_picture_url: string
    gender?: Gender | null
    speciality: string
    birthdate: string
    google_maps_url: string
    str_number: string
    str_issued_date: string
    alumni: string
    city_id: number
    province_id: number
    lat: string
    long: string
    days: string
    ops_start_time: string
    ops_end_time: string
    duration: number
    rest: number
    total_poli: number
    image_url: string
    created_at?: Date | string
    updated_at?: Date | string
    vendor_documents?: Vendor_DocumentsUncheckedCreateNestedManyWithoutVendorsInput
    vendor_medtreats?: Vendor_MedtreatsUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type VendorsCreateOrConnectWithoutFeedbacksInput = {
    where: VendorsWhereUniqueInput
    create: XOR<VendorsCreateWithoutFeedbacksInput, VendorsUncheckedCreateWithoutFeedbacksInput>
  }

  export type VendorsUpsertWithoutFeedbacksInput = {
    update: XOR<VendorsUpdateWithoutFeedbacksInput, VendorsUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<VendorsCreateWithoutFeedbacksInput, VendorsUncheckedCreateWithoutFeedbacksInput>
  }

  export type VendorsUpdateWithoutFeedbacksInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    vendor_role?: NullableEnumTypeFieldUpdateOperationsInput | Type | null
    price?: IntFieldUpdateOperationsInput | number
    total_patient?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    profile_picture_url?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    speciality?: StringFieldUpdateOperationsInput | string
    birthdate?: StringFieldUpdateOperationsInput | string
    google_maps_url?: StringFieldUpdateOperationsInput | string
    str_number?: StringFieldUpdateOperationsInput | string
    str_issued_date?: StringFieldUpdateOperationsInput | string
    alumni?: StringFieldUpdateOperationsInput | string
    city_id?: IntFieldUpdateOperationsInput | number
    province_id?: IntFieldUpdateOperationsInput | number
    lat?: StringFieldUpdateOperationsInput | string
    long?: StringFieldUpdateOperationsInput | string
    days?: StringFieldUpdateOperationsInput | string
    ops_start_time?: StringFieldUpdateOperationsInput | string
    ops_end_time?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    rest?: IntFieldUpdateOperationsInput | number
    total_poli?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor_documents?: Vendor_DocumentsUpdateManyWithoutVendorsInput
    vendor_medtreats?: Vendor_MedtreatsUpdateManyWithoutVendorsInput
  }

  export type VendorsUncheckedUpdateWithoutFeedbacksInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    vendor_role?: NullableEnumTypeFieldUpdateOperationsInput | Type | null
    price?: IntFieldUpdateOperationsInput | number
    total_patient?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    profile_picture_url?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    speciality?: StringFieldUpdateOperationsInput | string
    birthdate?: StringFieldUpdateOperationsInput | string
    google_maps_url?: StringFieldUpdateOperationsInput | string
    str_number?: StringFieldUpdateOperationsInput | string
    str_issued_date?: StringFieldUpdateOperationsInput | string
    alumni?: StringFieldUpdateOperationsInput | string
    city_id?: IntFieldUpdateOperationsInput | number
    province_id?: IntFieldUpdateOperationsInput | number
    lat?: StringFieldUpdateOperationsInput | string
    long?: StringFieldUpdateOperationsInput | string
    days?: StringFieldUpdateOperationsInput | string
    ops_start_time?: StringFieldUpdateOperationsInput | string
    ops_end_time?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    rest?: IntFieldUpdateOperationsInput | number
    total_poli?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor_documents?: Vendor_DocumentsUncheckedUpdateManyWithoutVendorsInput
    vendor_medtreats?: Vendor_MedtreatsUncheckedUpdateManyWithoutVendorsInput
  }

  export type CityCreateManyProvinceInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type User_AddressCreateManyProvinceInput = {
    id?: number
    uid: string
    label: string
    address: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    city_id?: number | null
    user_id: string
  }

  export type CityUpdateWithoutProvinceInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Address?: User_AddressUpdateManyWithoutCityInput
  }

  export type CityUncheckedUpdateWithoutProvinceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User_Address?: User_AddressUncheckedUpdateManyWithoutCityInput
  }

  export type CityUncheckedUpdateManyWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type User_AddressUpdateWithoutProvinceInput = {
    uid?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    City?: CityUpdateOneWithoutUser_AddressInput
    User?: UserUpdateOneRequiredWithoutUser_addressInput
  }

  export type User_AddressUncheckedUpdateWithoutProvinceInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type User_AddressUncheckedUpdateManyWithoutUser_AddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type User_AddressCreateManyCityInput = {
    id?: number
    uid: string
    label: string
    address: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    province_id?: number | null
    user_id: string
  }

  export type User_AddressUpdateWithoutCityInput = {
    uid?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Province?: ProvinceUpdateOneWithoutUser_AddressInput
    User?: UserUpdateOneRequiredWithoutUser_addressInput
  }

  export type User_AddressUncheckedUpdateWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    province_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type User_AddressCreateManyUserInput = {
    id?: number
    uid: string
    label: string
    address: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
    city_id?: number | null
    province_id?: number | null
  }

  export type User_BankCreateManyUserInput = {
    id?: number
    uid: string
    alias: string
    bank_name: string
    account_number: string
    bank_username: string
    is_default: boolean
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
  }

  export type UserPetsCreateManyUserInput = {
    id?: number
    uid: string
    name: string
    species?: string | null
    breed?: string | null
    date_of_birth?: Date | string | null
    color?: string | null
    profile_picture_url?: string | null
    gender?: Gender | null
    is_neutered?: boolean | null
    is_dog_friendly?: boolean | null
    is_cat_friendly?: boolean | null
    is_under_10_child_friendly?: boolean | null
    is_over_10_child_friendly?: boolean | null
    is_microchipped?: boolean | null
    is_purebred?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type ConsultationsCreateManyUserInput = {
    id?: number
    uid: string
    pet_id: string
    vendor_id: string
    chat_room_id: string
    vendor_role?: Type | null
    diagnose: string
    prerequisite: string
    date: string
    time_start: string
    time_end: string
    order_status: string
    reject_reason: string
    total_payment: number
    payment_image_url: string
    rating: number
    comment: string
    user_bank_id: number
    vendor_bank_id: number
    user_address_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type User_AddressUpdateWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    City?: CityUpdateOneWithoutUser_AddressInput
    Province?: ProvinceUpdateOneWithoutUser_AddressInput
  }

  export type User_AddressUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city_id?: NullableIntFieldUpdateOperationsInput | number | null
    province_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type User_AddressUncheckedUpdateManyWithoutUser_addressInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city_id?: NullableIntFieldUpdateOperationsInput | number | null
    province_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type User_BankUpdateWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    bank_username?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type User_BankUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    bank_username?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type User_BankUncheckedUpdateManyWithoutUser_bankInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    account_number?: StringFieldUpdateOperationsInput | string
    bank_username?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPetsUpdateWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    species?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    is_neutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_dog_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_cat_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_under_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_over_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_microchipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_purebred?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    VaccineHistory?: VaccineHistoryUpdateManyWithoutPetInput
    Consultations?: ConsultationsUpdateManyWithoutPetInput
  }

  export type UserPetsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    species?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    is_neutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_dog_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_cat_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_under_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_over_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_microchipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_purebred?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    VaccineHistory?: VaccineHistoryUncheckedUpdateManyWithoutPetInput
    Consultations?: ConsultationsUncheckedUpdateManyWithoutPetInput
  }

  export type UserPetsUncheckedUpdateManyWithoutUser_petsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    species?: NullableStringFieldUpdateOperationsInput | string | null
    breed?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | Gender | null
    is_neutered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_dog_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_cat_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_under_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_over_10_child_friendly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_microchipped?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_purebred?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConsultationsUpdateWithoutUserInput = {
    uid?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    chat_room_id?: StringFieldUpdateOperationsInput | string
    vendor_role?: NullableEnumTypeFieldUpdateOperationsInput | Type | null
    diagnose?: StringFieldUpdateOperationsInput | string
    prerequisite?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time_start?: StringFieldUpdateOperationsInput | string
    time_end?: StringFieldUpdateOperationsInput | string
    order_status?: StringFieldUpdateOperationsInput | string
    reject_reason?: StringFieldUpdateOperationsInput | string
    total_payment?: IntFieldUpdateOperationsInput | number
    payment_image_url?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    user_bank_id?: IntFieldUpdateOperationsInput | number
    vendor_bank_id?: IntFieldUpdateOperationsInput | number
    user_address_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    Pet?: UserPetsUpdateOneWithoutConsultationsInput
  }

  export type ConsultationsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    pet_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    chat_room_id?: StringFieldUpdateOperationsInput | string
    vendor_role?: NullableEnumTypeFieldUpdateOperationsInput | Type | null
    diagnose?: StringFieldUpdateOperationsInput | string
    prerequisite?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time_start?: StringFieldUpdateOperationsInput | string
    time_end?: StringFieldUpdateOperationsInput | string
    order_status?: StringFieldUpdateOperationsInput | string
    reject_reason?: StringFieldUpdateOperationsInput | string
    total_payment?: IntFieldUpdateOperationsInput | number
    payment_image_url?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    user_bank_id?: IntFieldUpdateOperationsInput | number
    vendor_bank_id?: IntFieldUpdateOperationsInput | number
    user_address_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationsUncheckedUpdateManyWithoutConsultationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    pet_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    chat_room_id?: StringFieldUpdateOperationsInput | string
    vendor_role?: NullableEnumTypeFieldUpdateOperationsInput | Type | null
    diagnose?: StringFieldUpdateOperationsInput | string
    prerequisite?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time_start?: StringFieldUpdateOperationsInput | string
    time_end?: StringFieldUpdateOperationsInput | string
    order_status?: StringFieldUpdateOperationsInput | string
    reject_reason?: StringFieldUpdateOperationsInput | string
    total_payment?: IntFieldUpdateOperationsInput | number
    payment_image_url?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    user_bank_id?: IntFieldUpdateOperationsInput | number
    vendor_bank_id?: IntFieldUpdateOperationsInput | number
    user_address_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenCreateManyAdminsInput = {
    id?: number
    created_at: Date | string
    updated_at: Date | string
    valid: boolean
    expiration: Date | string
  }

  export type TokenUpdateWithoutAdminsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expiration?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateWithoutAdminsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expiration?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateManyWithoutTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    expiration?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccineHistoryCreateManyPetInput = {
    id?: number
    uid: string
    veterinary: string
    vaccine_photo: string
    date_administered: Date | string
    is_manual: boolean
    date_valid_until: Date | string
    vaccine_type_id?: number | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ConsultationsCreateManyPetInput = {
    id?: number
    uid: string
    user_id: string
    vendor_id: string
    chat_room_id: string
    vendor_role?: Type | null
    diagnose: string
    prerequisite: string
    date: string
    time_start: string
    time_end: string
    order_status: string
    reject_reason: string
    total_payment: number
    payment_image_url: string
    rating: number
    comment: string
    user_bank_id: number
    vendor_bank_id: number
    user_address_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VaccineHistoryUpdateWithoutPetInput = {
    uid?: StringFieldUpdateOperationsInput | string
    veterinary?: StringFieldUpdateOperationsInput | string
    vaccine_photo?: StringFieldUpdateOperationsInput | string
    date_administered?: DateTimeFieldUpdateOperationsInput | Date | string
    is_manual?: BoolFieldUpdateOperationsInput | boolean
    date_valid_until?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccine_type?: VaccineTypeUpdateOneWithoutVaccineHistoryInput
    VaccineHistoryPhoto?: VaccineHistoryPhotoUpdateManyWithoutVaccine_historyInput
  }

  export type VaccineHistoryUncheckedUpdateWithoutPetInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    veterinary?: StringFieldUpdateOperationsInput | string
    vaccine_photo?: StringFieldUpdateOperationsInput | string
    date_administered?: DateTimeFieldUpdateOperationsInput | Date | string
    is_manual?: BoolFieldUpdateOperationsInput | boolean
    date_valid_until?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccine_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    VaccineHistoryPhoto?: VaccineHistoryPhotoUncheckedUpdateManyWithoutVaccine_historyInput
  }

  export type VaccineHistoryUncheckedUpdateManyWithoutVaccineHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    veterinary?: StringFieldUpdateOperationsInput | string
    vaccine_photo?: StringFieldUpdateOperationsInput | string
    date_administered?: DateTimeFieldUpdateOperationsInput | Date | string
    is_manual?: BoolFieldUpdateOperationsInput | boolean
    date_valid_until?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccine_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationsUpdateWithoutPetInput = {
    uid?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    chat_room_id?: StringFieldUpdateOperationsInput | string
    vendor_role?: NullableEnumTypeFieldUpdateOperationsInput | Type | null
    diagnose?: StringFieldUpdateOperationsInput | string
    prerequisite?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time_start?: StringFieldUpdateOperationsInput | string
    time_end?: StringFieldUpdateOperationsInput | string
    order_status?: StringFieldUpdateOperationsInput | string
    reject_reason?: StringFieldUpdateOperationsInput | string
    total_payment?: IntFieldUpdateOperationsInput | number
    payment_image_url?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    user_bank_id?: IntFieldUpdateOperationsInput | number
    vendor_bank_id?: IntFieldUpdateOperationsInput | number
    user_address_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutConsultationsInput
  }

  export type ConsultationsUncheckedUpdateWithoutPetInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    chat_room_id?: StringFieldUpdateOperationsInput | string
    vendor_role?: NullableEnumTypeFieldUpdateOperationsInput | Type | null
    diagnose?: StringFieldUpdateOperationsInput | string
    prerequisite?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    time_start?: StringFieldUpdateOperationsInput | string
    time_end?: StringFieldUpdateOperationsInput | string
    order_status?: StringFieldUpdateOperationsInput | string
    reject_reason?: StringFieldUpdateOperationsInput | string
    total_payment?: IntFieldUpdateOperationsInput | number
    payment_image_url?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    user_bank_id?: IntFieldUpdateOperationsInput | number
    vendor_bank_id?: IntFieldUpdateOperationsInput | number
    user_address_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccineHistoryCreateManyVaccine_typeInput = {
    id?: number
    uid: string
    pet_id: string
    veterinary: string
    vaccine_photo: string
    date_administered: Date | string
    is_manual: boolean
    date_valid_until: Date | string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type VaccineHistoryUpdateWithoutVaccine_typeInput = {
    uid?: StringFieldUpdateOperationsInput | string
    veterinary?: StringFieldUpdateOperationsInput | string
    vaccine_photo?: StringFieldUpdateOperationsInput | string
    date_administered?: DateTimeFieldUpdateOperationsInput | Date | string
    is_manual?: BoolFieldUpdateOperationsInput | boolean
    date_valid_until?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    pet?: UserPetsUpdateOneWithoutVaccineHistoryInput
    VaccineHistoryPhoto?: VaccineHistoryPhotoUpdateManyWithoutVaccine_historyInput
  }

  export type VaccineHistoryUncheckedUpdateWithoutVaccine_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    pet_id?: StringFieldUpdateOperationsInput | string
    veterinary?: StringFieldUpdateOperationsInput | string
    vaccine_photo?: StringFieldUpdateOperationsInput | string
    date_administered?: DateTimeFieldUpdateOperationsInput | Date | string
    is_manual?: BoolFieldUpdateOperationsInput | boolean
    date_valid_until?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    VaccineHistoryPhoto?: VaccineHistoryPhotoUncheckedUpdateManyWithoutVaccine_historyInput
  }

  export type VaccineHistoryPhotoCreateManyVaccine_historyInput = {
    id?: number
    uid: string
    path: string
    description: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type VaccineHistoryPhotoUpdateWithoutVaccine_historyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccineHistoryPhotoUncheckedUpdateWithoutVaccine_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccineHistoryPhotoUncheckedUpdateManyWithoutVaccineHistoryPhotoInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Vendor_DocumentsCreateManyVendorsInput = {
    id?: number
    uid: string
    document_type: string
    document_path: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type Vendor_MedtreatsCreateManyVendorsInput = {
    id?: number
    uid: string
    medical_treatment_id: string
    is_homecare: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type FeedbacksCreateManyVendorInput = {
    id?: number
    user_id: number
    email: string
    title: string
    content: string
    rating: number
    created_at?: Date | string
    updated_at: Date | string
  }

  export type Vendor_DocumentsUpdateWithoutVendorsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    document_type?: StringFieldUpdateOperationsInput | string
    document_path?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Vendor_DocumentsUncheckedUpdateWithoutVendorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    document_type?: StringFieldUpdateOperationsInput | string
    document_path?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Vendor_DocumentsUncheckedUpdateManyWithoutVendor_documentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    document_type?: StringFieldUpdateOperationsInput | string
    document_path?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Vendor_MedtreatsUpdateWithoutVendorsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    medical_treatment_id?: StringFieldUpdateOperationsInput | string
    is_homecare?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Vendor_MedtreatsUncheckedUpdateWithoutVendorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    medical_treatment_id?: StringFieldUpdateOperationsInput | string
    is_homecare?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Vendor_MedtreatsUncheckedUpdateManyWithoutVendor_medtreatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    medical_treatment_id?: StringFieldUpdateOperationsInput | string
    is_homecare?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbacksUpdateWithoutVendorInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbacksUncheckedUpdateWithoutVendorInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbacksUncheckedUpdateManyWithoutFeedbacksInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeciesCreateManyClassInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    deleted_at?: Date | string | null
  }

  export type SpeciesUpdateWithoutClassInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Articles?: ArticlesUpdateManyWithoutSpeciesInput
  }

  export type SpeciesUncheckedUpdateWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Articles?: ArticlesUncheckedUpdateManyWithoutSpeciesInput
  }

  export type SpeciesUncheckedUpdateManyWithoutSpeciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArticlesCreateManySpeciesInput = {
    id?: number
    title: string
    content: string
    image_url: string
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type ArticlesUpdateWithoutSpeciesInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticlesUncheckedUpdateWithoutSpeciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticlesUncheckedUpdateManyWithoutArticlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}